diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/mach-mx2/Kconfig linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/Kconfig
--- linux-2.6.30-rc4-karo/arch/arm/mach-mx2/Kconfig	2009-06-08 11:15:16.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/Kconfig	2009-07-01 11:09:09.000000000 +0200
@@ -15,6 +15,9 @@ config MACH_MX27
 	bool "i.MX27 support"
 	select ARCH_MXC_IOMUX_V2
 	select ARCH_MXC_HAS_NFC_V1
+	select USB_ARCH_HAS_EHCI
+	select ARCH_MXC_HAS_USBH2
+	select ARCH_MXC_HAS_USBOTG
 	help
 	  This enables support for Freescale's MX2 based i.MX27 processor.
 
@@ -22,6 +25,9 @@ config MACH_MX25
 	bool "i.MX25 support"
 	select ARCH_MXC_IOMUX_V3
 	select ARCH_MXC_HAS_NFC_V1_1
+	select USB_ARCH_HAS_EHCI
+	select ARCH_MXC_HAS_USBH2
+	select ARCH_MXC_HAS_USBOTG
 	select PHYLIB if FEC
 	help
 	  This enables support for Freescale's MX2 based i.MX25 processor.
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/mach-mx2/clock_imx25.c linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/clock_imx25.c
--- linux-2.6.30-rc4-karo/arch/arm/mach-mx2/clock_imx25.c	2009-07-06 17:32:59.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/clock_imx25.c	2009-07-06 15:40:57.000000000 +0200
@@ -274,37 +274,42 @@ static void _perclk_disable(struct clk *
 static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
 {
 	unsigned long reg;
-	signed long pd = 1;	/* Pre-divider */
-	signed long mfi;	/* Multiplication Factor (Integer part) */
+	unsigned int pd = 1;	/* Pre-divider */
+	unsigned long mfi;	/* Multiplication Factor (Integer part) */
 	signed long mfn;	/* Multiplication Factor (Integer part) */
-	signed long mfd;	/* Multiplication Factor (Denominator Part) */
+	unsigned long mfd;	/* Multiplication Factor (Denominator Part) */
 	signed long tmp;
 	unsigned long ref_freq = clk_get_rate(clk->parent);
+	unsigned long err = ~0;
+	int best_mfn = -1;
+	int best_mfd = -1;
 
 	while (((ref_freq / pd) * 10) > rate)
 		pd++;
 
-	/* the ref_freq/2 in the following is to round up */
-	mfi = (((rate / 2) * pd) + (ref_freq / 2)) / ref_freq;
+	mfi = ((rate / 2) * pd) / ref_freq;
 	if (mfi < 5 || mfi > 15)
 		return -EINVAL;
 
-	/* pick a mfd value that will work
-	 * then solve for mfn */
-	mfd = ref_freq / 50000;
-
-	/*
-	 *          pll_freq * pd * mfd
-	 *   mfn = --------------------  -  (mfi * mfd)
-	 *           2 * ref_freq
-	 */
-	/* the tmp/2 is for rounding */
 	tmp = ref_freq / 10000;
-	mfn = ((((((rate / 2) + (tmp / 2)) / tmp) * pd) * mfd) / 10000) -
-		(mfi * mfd);
+	for (mfd = 1; mfd <= 1024; mfd++) {
+		unsigned long act_freq;
 
-	printk(KERN_DEBUG "pll freq: %lu PD=%ld MFI=%ld MFD=%ld MFN=%ld (0x%03lx)\n",
-	       rate, pd, mfi, mfd, mfn, (mfn + ((mfn < 0) ? 1024 : 0)) & 0x3ff);
+		mfn = ((((((rate / 2) + (tmp - 1)) / tmp) * pd) * mfd) / 10000) -
+			(mfi * mfd);
+
+		act_freq = (2 * ref_freq * mfi + (2 * ref_freq * mfn / mfd)) / pd;
+		act_freq -= rate;
+		if (abs(act_freq) < err) {
+			best_mfn = mfn;
+			best_mfd = mfd;
+			err = abs(act_freq);
+			if (err == 0)
+				break;
+		}
+	}
+	mfn = best_mfn;
+	mfd = best_mfd;
 
 	mfn = (mfn + ((mfn < 0) ? 1024 : 0)) & 0x3ff;
 	pd--;
@@ -333,7 +338,8 @@ static int _clk_pll_set_rate(struct clk 
 static unsigned long _clk_pll_getrate(struct clk *clk)
 {
 	unsigned long rate;
-	signed long mfi, mfn, mfd, pdf;
+	unsigned int mfi, mfd, pdf;
+	int mfn;
 	unsigned long ref_clk;
 	unsigned long reg;
 
@@ -355,6 +361,9 @@ static unsigned long _clk_pll_getrate(st
 		BUG();		/* oops */
 	}
 
+	if (mfn >= 512)
+		mfn = 1024 - mfn;
+
 	mfi = (mfi < 5) ? 5 : mfi;
 	rate = 2LL * ref_clk * mfn;
 	do_div(rate, mfd + 1);
@@ -436,8 +445,8 @@ static unsigned long _clk_perclkx_getrat
 
 	pcdr = __raw_readl(pcdr_a[clk->id >> 2]);
 
-	perclk_pdf =
-	    (pcdr >> ((clk->id & 3) << 3)) & MXC_CCM_PCDR1_PERDIV1_MASK;
+	perclk_pdf = (pcdr >> ((clk->id & 3) << 3)) &
+		MXC_CCM_PCDR1_PERDIV1_MASK;
 
 	return clk_get_rate(clk->parent) / (perclk_pdf + 1);
 }
@@ -466,8 +475,6 @@ static int _clk_perclkx_set_rate(struct 
 		return -EINVAL;
 
 	div = clk_get_rate(clk->parent) / rate;
-	printk(KERN_DEBUG "%s: perclk[%d] parent_rate=%lu rate=%lu div=%lu\n",
-	       __FUNCTION__, clk->id, clk_get_rate(clk->parent), rate, div);
 	if (div > 64 || div < 1 || ((clk_get_rate(clk->parent) / div) != rate))
 		return -EINVAL;
 	div--;
@@ -542,7 +549,8 @@ static int _clk_perclkx_set_parent3(stru
 
 static unsigned long _clk_ipg_getrate(struct clk *clk)
 {
-	return clk_get_rate(clk->parent) / 2;	/* Always AHB / 2 */
+	unsigned long rate = clk_get_rate(clk->parent) / 2;	/* Always AHB / 2 */
+	return rate;
 }
 
 /* Top-level clocks */
@@ -714,7 +722,7 @@ static struct clk per_clk[] = {
 	},
 	{
 		.id = 5,
-		.parent = &upll_clk,	/* can be AHB or UPLL */
+		.parent = &ahb_clk,	/* can be AHB or UPLL */
 		.round_rate = _clk_perclkx_round_rate,
 		.set_rate = _clk_perclkx_set_rate,
 		.set_parent = _clk_perclkx_set_parent,
@@ -1121,7 +1129,7 @@ static struct clk gpt2_clk[] = {
 	{
 		.id = 1,
 		.parent = &per_clk[5],
-		.secondary = &gpt1_clk[1],
+		.secondary = &gpt2_clk[1],
 	},
 	{
 		.id = 1,
@@ -1137,7 +1145,7 @@ static struct clk gpt3_clk[] = {
 	{
 		.id = 2,
 		.parent = &per_clk[5],
-		.secondary = &gpt1_clk[1],
+		.secondary = &gpt3_clk[1],
 	},
 	{
 		.id = 2,
@@ -1153,7 +1161,7 @@ static struct clk gpt4_clk[] = {
 	{
 		.id = 3,
 		.parent = &per_clk[5],
-		.secondary = &gpt1_clk[1],
+		.secondary = &gpt4_clk[1],
 	},
 	{
 		.id = 3,
@@ -1576,9 +1584,9 @@ static int _clk_usb_set_rate(struct clk 
 
 static unsigned long _clk_usb_getrate(struct clk *clk)
 {
-	unsigned long div =
-		__raw_readl(MXC_CCM_MCR) & MXC_CCM_CCTL_USB_DIV_MASK;
+	unsigned long div;
 
+	div = __raw_readl(MXC_CCM_MCR) & MXC_CCM_CCTL_USB_DIV_MASK;
 	div >>= MXC_CCM_CCTL_USB_DIV_OFFSET;
 
 	return clk_get_rate(clk->parent) / (div + 1);
@@ -1726,8 +1734,8 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("mxc_nand.0", NULL, nfc_clk)
 	_REGISTER_CLOCK(NULL, "audmux", audmux_clk)
 	_REGISTER_CLOCK(NULL, "ata", ata_clk[0])
-	_REGISTER_CLOCK("mxc-can.0", NULL, can_clk[0])
-	_REGISTER_CLOCK("mxc-can.1", NULL, can_clk[1])
+	_REGISTER_CLOCK("mxc-flexcan.0", NULL, can_clk[0])
+	_REGISTER_CLOCK("mxc-flexcan.1", NULL, can_clk[1])
 	_REGISTER_CLOCK(NULL, "csi", csi_clk[0])
 	_REGISTER_CLOCK(NULL, "cspi.0", cspi_clk[0])
 	_REGISTER_CLOCK(NULL, "cspi.1", cspi_clk[1])
@@ -1784,12 +1792,8 @@ int __init mx25_clocks_init(unsigned lon
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(lookups); i++) {
-		printk(KERN_DEBUG "Registering clock '%s' '%s'\n",
-		       lookups[i].dev_id ? lookups[i].dev_id : "",
-		       lookups[i].con_id ? lookups[i].con_id : "");
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
 		clkdev_add(&lookups[i]);
-	}
 
 	ckih_rate = fref;
 #ifndef CONFIG_DEBUG_LL
@@ -1825,23 +1829,19 @@ int __init mx25_clocks_init(unsigned lon
 			}
 		}
 	}
-#endif
+
 	/* the NFC clock must be derived from AHB clock */
 	clk_set_parent(&per_clk[8], &ahb_clk);
+#endif
 	clk_set_rate(&per_clk[8], clk_get_rate(&ahb_clk) / 6);
+	clk_set_rate(&per_clk[7], clk_get_rate(per_clk[7].parent));
 
 	/* This will propagate to all children and init all the clock rates */
 #ifdef CONFIG_DEBUG_LL
 	clk_enable(&uart1_clk[0]);
 #endif
 	clk_enable(&emi_clk);
-	clk_enable(&gpio_clk[0]);
-	clk_enable(&gpio_clk[1]);
-	clk_enable(&gpio_clk[2]);
 	clk_enable(&iim_clk);
-	clk_enable(&gpt1_clk[0]);
-	clk_enable(&iomuxc_clk);
-	clk_enable(&scc_clk);
 
 	pr_info("Clock input source is %ld\n", clk_get_rate(&osc24m_clk));
 
@@ -1856,6 +1856,6 @@ int __init mx25_clocks_init(unsigned lon
 	clk_set_rate(&mpll_clk, clk_get_rate(&mpll_clk));
 	clk_set_rate(&upll_clk, clk_get_rate(&upll_clk));
 
-	mxc_timer_init(&gpt1_clk[0]);
+	mxc_timer_init(&gpt1_clk[1]);
 	return 0;
 }
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/mach-mx2/devices.h linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/devices.h
--- linux-2.6.30-rc4-karo/arch/arm/mach-mx2/devices.h	2009-06-02 17:59:16.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/devices.h	2009-07-01 11:10:15.000000000 +0200
@@ -20,6 +20,9 @@ extern struct platform_device mxc_i2c_de
 extern struct platform_device mxc_i2c_device1;
 extern struct platform_device mxc_sdhc_device0;
 extern struct platform_device mxc_sdhc_device1;
+extern struct platform_device mxc_usbh1_device;
+extern struct platform_device mxc_usbh2_device;
+extern struct platform_device mxc_usbotg_device;
 #ifdef CONFIG_MACH_MX25
 extern struct platform_device mx25_i2c_device0;
 extern struct platform_device mx25_i2c_device1;
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/mach-mx2/devices_mx25.c linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/devices_mx25.c
--- linux-2.6.30-rc4-karo/arch/arm/mach-mx2/devices_mx25.c	2009-06-02 17:59:17.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/devices_mx25.c	2009-06-29 10:48:40.000000000 +0200
@@ -142,12 +142,12 @@ struct platform_device mxc_fb_device = {
  * Resource definition for the CSPI1
  */
 static struct resource mx25_spi1_resources[] = {
-	[0] = {
+	{
 	       .start = CSPI1_BASE_ADDR,
 	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
 	       .flags = IORESOURCE_MEM,
 	},
-	[1] = {
+	{
 	       .start = MXC_INT_CSPI1,
 	       .end = MXC_INT_CSPI1,
 	       .flags = IORESOURCE_IRQ,
@@ -178,12 +178,12 @@ static struct platform_device mx25_spi1_
  * Resource definition for the CSPI2
  */
 static struct resource mx25_spi2_resources[] = {
-	[0] = {
+	{
 	       .start = CSPI2_BASE_ADDR,
 	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
 	       .flags = IORESOURCE_MEM,
 	},
-	[1] = {
+	{
 	       .start = MXC_INT_CSPI2,
 	       .end = MXC_INT_CSPI2,
 	       .flags = IORESOURCE_IRQ,
@@ -213,12 +213,12 @@ static struct platform_device mx25_spi2_
  * Resource definition for the CSPI3
  */
 static struct resource mx25_spi3_resources[] = {
-	[0] = {
+	{
 	       .start = CSPI3_BASE_ADDR,
 	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
 	       .flags = IORESOURCE_MEM,
 	},
-	[1] = {
+	{
 	       .start = MXC_INT_CSPI3,
 	       .end = MXC_INT_CSPI3,
 	       .flags = IORESOURCE_IRQ,
@@ -267,6 +267,56 @@ static inline void mx25_init_spi(void)
 }
 #endif
 
+#if defined(CONFIG_USB_EHCI_MXC) || defined(CONFIG_USB_EHCI_MXC_MODULE)
+static struct resource mxc_usbotg_resources[] = {
+	{
+		.start = OTG_BASE_ADDR,
+		.end   = OTG_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 usbotg_dmamask = (u32)~0;
+
+struct platform_device mxc_usbotg_device = {
+	.name = "mxc-ehci",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = 0xffffffff,
+		.dma_mask = &usbotg_dmamask,
+	},
+	.num_resources = ARRAY_SIZE(mxc_usbotg_resources),
+	.resource = mxc_usbotg_resources,
+};
+
+static struct resource mxc_usbh2_resources[] = {
+	{
+		.start = USBH2_BASE_ADDR,
+		.end   = USBH2_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_USB_H2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 usbh2_dmamask = (u32)~0;
+
+struct platform_device mxc_usbh2_device = {
+	.name = "mxc-ehci",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = 0xffffffff,
+		.dma_mask = &usbh2_dmamask,
+	},
+	.num_resources = ARRAY_SIZE(mxc_usbh2_resources),
+	.resource = mxc_usbh2_resources,
+};
+#endif
+
 /* I2C controller and device data */
 #if defined(CONFIG_I2C_IMX) || defined(CONFIG_I2C_IMX_MODULE)
 
@@ -274,12 +324,12 @@ static inline void mx25_init_spi(void)
  * Resource definition for the I2C1
  */
 static struct resource mx25_i2c1_resources[] = {
-	[0] = {
+	{
 		.start = I2C_BASE_ADDR,
 		.end = I2C_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
 	},
-	[1] = {
+	{
 		.start = MXC_INT_I2C,
 		.end = MXC_INT_I2C,
 		.flags = IORESOURCE_IRQ,
@@ -290,12 +340,12 @@ static struct resource mx25_i2c1_resourc
  * Resource definition for the I2C2
  */
 static struct resource mx25_i2c2_resources[] = {
-	[0] = {
+	{
 		.start = I2C2_BASE_ADDR,
 		.end = I2C2_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
 	},
-	[1] = {
+	{
 		.start = MXC_INT_I2C2,
 		.end = MXC_INT_I2C2,
 		.flags = IORESOURCE_IRQ,
@@ -306,12 +356,12 @@ static struct resource mx25_i2c2_resourc
  * Resource definition for the I2C3
  */
 static struct resource mx25_i2c3_resources[] = {
-	[0] = {
+	{
 		.start = I2C3_BASE_ADDR,
 		.end = I2C3_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
 	},
-	[1] = {
+	{
 		.start = MXC_INT_I2C3,
 		.end = MXC_INT_I2C3,
 		.flags = IORESOURCE_IRQ,
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/mach-mx2/karo-tx25.c linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/karo-tx25.c
--- linux-2.6.30-rc4-karo/arch/arm/mach-mx2/karo-tx25.c	2009-07-06 17:32:59.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/karo-tx25.c	2009-07-06 16:02:49.000000000 +0200
@@ -31,8 +31,6 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/fb.h>
-//#include <linux/i2c.h>
-//#include <linux/i2c/at24.h>
 #include <linux/spi/spi.h>
 #include <linux/serial_8250.h>
 #include <linux/fec_enet.h>
@@ -61,15 +59,12 @@
 #include <mach/irqs.h>
 #include <mach/clock.h>
 #include <mach/imxfb.h>
-//#include <mach/imx_spi.h>
-//#include <mach/i2c.h>
 #include <mach/mmc.h>
 #include <mach/imx-uart.h>
 #include <mach/mxc_nand.h>
-//#include <mach/ulpi.h>
-//#include <mach/mxc_ehci.h>
-//#include <mach/board-tx25.h>
+#include <mach/mxc_ehci.h>
 #include <mach/mxc_tsadcc.h>
+#include <mach/mxc_can.h>
 
 #include "crm_regs.h"
 #include "devices.h"
@@ -83,161 +78,172 @@ static int tx25_debug;
 module_param(tx25_debug, int, 0);
 #endif
 
-//#include "karo.h"
-
 int karo_board_type = 0;
 int karo_mod_type = -1;
 
 
-#ifdef CONFIG_USB_EHCI_MXC
-
-#define SMSC_VENDOR_ID		0x0424
-#define USB3317_PROD_ID		0x0006
-#define ULPI_FCTL		7
-
-static inline const char *ulpi_name(void __iomem *view)
-{
-	if ((unsigned long)view & 0x400) {
-		return "USBH2";
-	} else {
-		return "USBOTG";
-	}
-}
-
-static int usb3317_init(void __iomem *view)
+static int karo_tx25_gpio_config(struct pad_desc *pd, int num)
 {
-	int vid, pid, ret;
-#if 1
-	/* This is a kludge until we know why we sometimes read a wrong
-	 * vendor or product ID!
-	 */
-	int retries = 3;
-
- retry:
-#endif
-	ret = ulpi_read(ISP1504_VID_HIGH, view);
-	if (ret < 0) {
-		goto err;
-	}
-	vid = ret << 8;
+	int ret;
+	int i;
+	int count = 0;
 
-	ret = ulpi_read(ISP1504_VID_LOW, view);
-	if (ret < 0) {
-		goto err;
+	for (i = 0; i < num; i++) {
+		ret = mxc_iomux_v3_setup_pad(&pd[i]);
+		if (ret == 0) {
+			DBG(0, "%s: PAD[%d] %s set up as GPIO\n", __FUNCTION__, i,
+			    MXC_PAD_NAME(&pd[i]));
+			count++;
+			mxc_iomux_v3_release_pad(&pd[i]);
+		} else {
+			DBG(0, "%s: PAD[%d] %s skipped\n", __FUNCTION__, i,
+			    MXC_PAD_NAME(&pd[i]));
+		}
 	}
-	vid |= ret;
+	return count;
+}
 
-	ret = ulpi_read(ISP1504_PID_HIGH, view);
-	if (ret < 0) {
-		goto err;
-	}
-	pid = ret << 8;
+#ifdef CONFIG_USB_EHCI_MXC
 
-	ret = ulpi_read(ISP1504_PID_LOW, view);
-	if (ret < 0) {
-		goto err;
-	}
-	pid |= ret;
+/* USB register offsets */
+#define REG_USBCTRL		0x600
+#define REG_PHY_CTRL		0x608
+
+#define PHY_CTRL_USBEN		(1 << 24)
+
+/* USB Host/OTG register offsets referenced to ULPI view port */
+#define REG_USBCMD		0x140
+#define REG_USBSTS		0x144
+#define REG_PORTSC1		0x184
+#define REG_USBMODE		0x1a8
+
+#define USBCMD_RST		(1 << 1)
+#define USBCMD_RUN		(1 << 0)
+
+#define USBSTS_HCH		(1 << 12)
+
+/* USB_CTRL register bits */
+#define USBCTRL_OCPOL_HST	(1 << 2)
+#define USBCTRL_OCPOL_OTG	(1 << 3)
+#define USBCTRL_USBTE		(1 << 4)
+#define USBCTRL_HSDT		(1 << 5)
+#define USBCTRL_XCSH		(1 << 9)
+#define USBCTRL_XCSO		(1 << 10)
+#define USBCTRL_PP_OTG		(1 << 11)
+#define USBCTRL_HLKEN		(1 << 12)
+#define USBCTRL_OLKEN		(1 << 13)
+#define USBCTRL_HPM		(1 << 16)
+#define USBCTRL_PP_HST		(1 << 18)
+#define USBCTRL_HWIE		(1 << 19)
+#define USBCTRL_HUIE		(1 << 20)
+#define USBCTRL_OPM		(1 << 24)
+#define USBCTRL_OEXTEN		(1 << 25)
+#define USBCTRL_HEXTEN		(1 << 26)
+#define USBCTRL_OWIE		(1 << 27)
+#define USBCTRL_OUIE		(1 << 28)
 
-	pr_info("ULPI on %s port Vendor ID 0x%x Product ID 0x%x\n",
-		ulpi_name(view), vid, pid);
-	if (vid != SMSC_VENDOR_ID || pid != USB3317_PROD_ID) {
-		if (retries-- < 0) {
-			pr_err("No USB3317 found\n");
-			return -ENODEV;
+static int tx25_usb_init(struct platform_device *pdev, void __iomem *base, int host_mode)
+{
+	u32 val;
+	unsigned long flags;
+	const char __maybe_unused *name = pdev->id ? "USBH2" : "USBOTG";
+	unsigned int loops = 0;
+	void __iomem *otg_base = IO_ADDRESS(OTG_BASE_ADDR);
+
+	if (!(__raw_readl(base + REG_USBSTS) & USBSTS_HCH)) {
+		DBG(0, "%s: %s[%p] is busy: %08x\n", __FUNCTION__, name,
+		    base + REG_USBSTS, __raw_readl(base + REG_USBSTS));
+		__raw_writel(__raw_readl(base + REG_USBCTRL) & ~USBCMD_RUN,
+			 base + REG_USBCTRL);
+		while (__raw_readl(base + REG_USBCTRL) & USBCMD_RUN) {
+			cpu_relax();
 		}
-		goto retry;
 	}
- err:
-	if (ret < 0) {
-		printk(KERN_ERR "ULPI read on %s port failed with error %d\n",
-		       ulpi_name(view), ret);
-		return ret;
+	DBG(0, "%s: PHY_CTRL[%p]=%08x\n", __FUNCTION__, otg_base + REG_PHY_CTRL,
+	    __raw_readl(otg_base + REG_PHY_CTRL));
+	DBG(0, "%s: USBCMD[%p]=%08x\n", __FUNCTION__, base + REG_USBCMD,
+	    __raw_readl(base + REG_USBCMD));
+	DBG(0, "%s: USBSTS[%p]=%08x\n", __FUNCTION__, base + REG_USBSTS,
+	    __raw_readl(base + REG_USBSTS));
+
+	/* reset USB Host controller */
+	__raw_writel(USBCMD_RST, base + REG_USBCMD);
+	while (__raw_readl(base + REG_USBCMD) & USBCMD_RST) {
+		cpu_relax();
+		loops++;
 	}
-	return 0;
-}
-
-static int usb3317_set_vbus_power(void __iomem *view, int on)
-{
-	int ret;
-
-	DBG(0, "%s: Switching %s port VBUS power %s\n", __FUNCTION__,
-	    ulpi_name(view), on ? "on" : "off");
+	DBG(0, "USB controller reset finished after %u loops\n", loops);
+	local_irq_save(flags);
+	val = __raw_readl(otg_base + REG_USBCTRL);
+	if (pdev->id == 1) {
+		val &= ~(USBCTRL_OCPOL_HST | USBCTRL_HPM |
+			 USBCTRL_HEXTEN | USBCTRL_HWIE);
+		val |= USBCTRL_PP_HST | USBCTRL_HSDT | USBCTRL_USBTE |
+			USBCTRL_XCSH;
+	} else {
+		val &= ~(USBCTRL_OCPOL_OTG | USBCTRL_OPM |
+			 USBCTRL_OEXTEN | USBCTRL_OWIE);
+		val |= USBCTRL_PP_OTG | USBCTRL_XCSO;
+	}
+	DBG(0, "%s: Changing %s_USBCTRL from %08x to %08x\n", __FUNCTION__, name,
+	    __raw_readl(otg_base + REG_USBCTRL), val);
+	__raw_writel(val, otg_base + REG_USBCTRL);
+	local_irq_restore(flags);
 
-	if (on) {
-		ret = ulpi_set(DRV_VBUS_EXT |		/* enable external Vbus */
-			       DRV_VBUS |		/* enable internal Vbus */
-			       CHRG_VBUS,		/* charge Vbus */
-			       ISP1504_OTGCTL, view);
+	val = __raw_readl(base + REG_PORTSC1);
+	if (pdev->id == 1) {
+		/* select serial transceiver */
+		val = (val & ~(3 << 30)) | (3 << 30) | (1 << 28);
 	} else {
-		ret = ulpi_clear(DRV_VBUS_EXT |		/* disable external Vbus */
-				 DRV_VBUS,		/* disable internal Vbus */
-				 ISP1504_OTGCTL, view);
-		if (ret == 0) {
-			ret = ulpi_set(DISCHRG_VBUS,	   /* discharge Vbus */
-				       ISP1504_OTGCTL, view);
-		}
-	}
-	if (ret < 0) {
-		printk(KERN_ERR "ULPI read on %s port failed with error %d\n",
-		       ulpi_name(view), ret);
-		return ret;
+		/* select UTMI transceiver */
+		val = (val & ~(3 << 30)) | (0 << 30) | (1 << 28);
 	}
+	DBG(0, "%s: Changing %s_PORTSC1 from %08x to %08x\n", __FUNCTION__, name,
+	    __raw_readl(base + REG_PORTSC1), val);
+	__raw_writel(val, base + REG_PORTSC1);
+
+	val = __raw_readl(otg_base + REG_PHY_CTRL);
+	__raw_writel(val & ~PHY_CTRL_USBEN, otg_base + REG_PHY_CTRL);
+	//__raw_writel(val | PHY_CTRL_USBEN, otg_base + REG_PHY_CTRL);
+	DBG(0, "%s: PHY_CTRL[%p]=%08x\n", __FUNCTION__, otg_base + REG_PHY_CTRL,
+	    __raw_readl(otg_base + REG_PHY_CTRL));
+
+	/* Switch to Host mode */
+	val = __raw_readl(base + REG_USBMODE);
+	DBG(0, "%s: Changing %s_USBMODE from %08x to %08x\n", __FUNCTION__, name,
+	    val, val | (host_mode ? 0x3 : 0x02));
+	__raw_writel(val | (host_mode ? 0x3 : 0x02), base + REG_USBMODE);
+
 	return 0;
 }
 
+#ifdef CONFIG_ARCH_MXC_EHCI_USBH2
+static struct pad_desc karo_tx25_usbh2_pads[] = {
+	MX25_PAD_D9__USBH2_PWR,
+	MX25_PAD_D8__USBH2_OC,
+};
+
 static int tx25_usbh2_init(struct platform_device *pdev)
 {
 	int ret;
-	u32 temp;
-	unsigned long flags;
-	void __iomem *view = IO_ADDRESS(OTG_BASE_ADDR + 0x570);
+	void __iomem *base = IO_ADDRESS(OTG_BASE_ADDR + 0x400);
 
-	local_irq_save(flags);
-	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
-	temp &= ~((3 << 21) | (1 << 0));
-	temp |= (1 << 5) | (1 << 16) | (1 << 19) | (1 << 20);
-	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
-	local_irq_restore(flags);
-
-	/* select ULPI transceiver */
-	/* this must be done _before_ setting up the GPIOs! */
-	temp = readl(view + 0x14);
-	DBG(0, "%s: Changing USBH2_PORTSC1 from %08x to %08x\n", __FUNCTION__,
-	    temp, (temp & ~(3 << 30)) | (2 << 30));
-	temp &= ~(3 << 30);
-	temp |= 2 << 30;
-	writel(temp, view + 0x14);
-
-	/* Set to Host mode */
-	temp = readl(view + 0x38);
-	DBG(0, "%s: Changing USBH2_USBMODE from %08x to %08x\n", __FUNCTION__,
-	    temp, temp | 3);
-	writel(temp | 0x3, view + 0x38);
+	DBG(0, "%s: \n", __FUNCTION__);
 
-	ret = gpio_usbh2_active();
+	ret = tx25_usb_init(pdev, base, 1);
 	if (ret != 0) {
 		return ret;
 	}
 
-	ret = usb3317_init(view);
-	if (ret != 0) {
-		goto err;
-	}
-	ret = usb3317_set_vbus_power(view, 1);
-	if (ret != 0) {
-		goto err;
-	}
-	return 0;
-
- err:
-	gpio_usbh2_inactive();
+	ret = mxc_iomux_v3_setup_multiple_pads(karo_tx25_usbh2_pads,
+					       ARRAY_SIZE(karo_tx25_usbh2_pads));
 	return ret;
 }
 
 static int tx25_usbh2_exit(struct platform_device *pdev)
 {
-	gpio_usbh2_inactive();
+	mxc_iomux_v3_release_multiple_pads(karo_tx25_usbh2_pads,
+					   ARRAY_SIZE(karo_tx25_usbh2_pads));
 	return 0;
 }
 
@@ -250,10 +256,55 @@ int tx25_usbh2_register(void)
 {
 	int ret;
 
-	ret = mxc_register_device(&mxc_ehci2, &tx25_usbh2_data);
+	ret = mxc_register_device(&mxc_usbh2_device, &tx25_usbh2_data);
 	return ret;
 }
 device_initcall(tx25_usbh2_register);
+#endif // CONFIG_ARCH_MXC_EHCI_USBH2
+
+#ifdef CONFIG_ARCH_MXC_EHCI_USBOTG
+static struct pad_desc karo_tx25_usbotg_pads[] = {
+	MX25_PAD_GPIO_A__USBOTG_PWR,
+	MX25_PAD_GPIO_B__USBOTG_OC,
+};
+
+static int tx25_usbotg_init(struct platform_device *pdev)
+{
+	int ret;
+	void __iomem *base = IO_ADDRESS(OTG_BASE_ADDR + 0x000);
+
+	DBG(0, "%s: \n", __FUNCTION__);
+
+	ret = tx25_usb_init(pdev, base, 1);
+	if (ret != 0) {
+		return ret;
+	}
+	ret = mxc_iomux_v3_setup_multiple_pads(karo_tx25_usbotg_pads,
+					       ARRAY_SIZE(karo_tx25_usbotg_pads));
+	return 0;
+}
+
+static int tx25_usbotg_exit(struct platform_device *pdev)
+{
+	mxc_iomux_v3_release_multiple_pads(karo_tx25_usbotg_pads,
+					   ARRAY_SIZE(karo_tx25_usbotg_pads));
+	return 0;
+}
+
+static struct mxc_usbh_platform_data tx25_usbotg_data = {
+	.init = tx25_usbotg_init,
+	.exit = tx25_usbotg_exit,
+};
+
+int tx25_usbotg_register(void)
+{
+	int ret;
+
+	ret = mxc_register_device(&mxc_usbotg_device, &tx25_usbotg_data);
+	return ret;
+}
+device_initcall(tx25_usbotg_register);
+#endif // CONFIG_ARCH_MXC_EHCI_USBOTG
 #endif // CONFIG_USB_EHCI_MXC
 
 //#define FEC_MII_IRQ		IRQ_GPIOD(8)
@@ -382,17 +433,7 @@ static int gpio_fec_active(void)
 			return ret;
 		}
 		DBG(0, "%s: Switching FEC PHY power on\n", __FUNCTION__);
-		//gpio_set_value(TX25_FEC_PWR_GPIO, 1);
-#if 0
-		while (1) {
-			gpio_set_value(TX25_FEC_PWR_GPIO, 1);
-			mdelay(1000);
-			gpio_set_value(TX25_FEC_PWR_GPIO, 0);
-			mdelay(1000);
-		}
-#endif
 		DBG(0, "%s: Asserting FEC PHY reset\n", __FUNCTION__);
-//		gpio_set_value(TX25_FEC_RST_GPIO, 0);
 		for (i = 0; i < ARRAY_SIZE(karo_tx25_fec_strap_gpios); i++) {
 			struct gpio_desc *pd = &karo_tx25_fec_strap_gpios[i];
 
@@ -462,13 +503,6 @@ static int gpio_fec_active(void)
  rel_gpio:
 	while (--i >= 0) {
 		struct gpio_desc *pd = &karo_tx25_fec_strap_gpios[i];
-#ifdef DEBUG
-		int grp = pd->gpio / 32 + 1;
-		int ofs = pd->gpio % 32;
-
-		DBG(0, "%s: Freeing GPIO%d_%d\n", __FUNCTION__,
-		    grp, ofs);
-#endif
 		gpio_free(pd->gpio);
 	}
 	mxc_iomux_v3_release_multiple_pads(karo_tx25_fec_pwr_gpios,
@@ -499,13 +533,6 @@ static void gpio_fec_inactive(void)
 					   ARRAY_SIZE(karo_tx25_fec_pwr_gpios));
 	for (i = 0; i < ARRAY_SIZE(karo_tx25_fec_strap_gpios); i++) {
 		struct gpio_desc *pd = &karo_tx25_fec_strap_gpios[i];
-#ifdef DEBUG
-		int grp = pd->gpio / 32 + 1;
-		int ofs = pd->gpio % 32;
-
-		DBG(0, "%s: Freeing GPIO%d_%d\n", __FUNCTION__,
-		    grp, ofs);
-#endif
 		gpio_free(pd->gpio);
 	}
 }
@@ -530,45 +557,6 @@ static int tx25_fec_resume(struct platfo
 	return 0;
 }
 
-#if 0
-/*
- * i.MX25 allows RMII mode to be configured via a gasket
- */
-#define FEC_MIIGSK_CFGR_FRCONT (1 << 6)
-#define FEC_MIIGSK_CFGR_LBMODE (1 << 4)
-#define FEC_MIIGSK_CFGR_EMODE (1 << 3)
-#define FEC_MIIGSK_CFGR_IF_MODE_MASK (3 << 0)
-#define FEC_MIIGSK_CFGR_IF_MODE_MII (0 << 0)
-#define FEC_MIIGSK_CFGR_IF_MODE_RMII (1 << 0)
-
-#define FEC_MIIGSK_ENR_READY (1 << 2)
-#define FEC_MIIGSK_ENR_EN (1 << 1)
-
-#include "../arch/arm/mach-mx25/crm_regs.h"
-static void __inline__ fec_localhw_setup(struct net_device *dev)
-{
-	struct fec_enet_private *fep = netdev_priv(dev);
-
-	/*
-	 * Set up the MII gasket for RMII mode
-	 */
-	printk("%s: enable RMII gasket\n", dev->name);
-
-	/* disable the gasket and wait */
-	fec_reg_write16(fep, FEC_MIIGSK_ENR, 0);
-	while (fec_reg_read16(fep, FEC_MIIGSK_ENR) & FEC_MIIGSK_ENR_READY)
-		udelay(1);
-
-	/* configure the gasket for RMII, 50 MHz, no loopback, no echo */
-	fec_reg_write16(fep, FEC_MIIGSK_CFGR, FEC_MIIGSK_CFGR_IF_MODE_RMII);
-
-	/* re-enable the gasket */
-	fec_reg_write16(fep, FEC_MIIGSK_ENR, FEC_MIIGSK_ENR_EN);
-	fec_reg_read16(fep, FEC_MIIGSK_CFGR);
-	fec_reg_read16(fep, FEC_MIIGSK_ENR);
-}
-#endif
-
 static int fec_arch_init(struct platform_device *pdev)
 {
 	int ret;
@@ -648,62 +636,6 @@ static struct pad_desc karo_tx25_nand_pa
 	MX25_PAD_D0__D0,
 };
 
-#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2
-static struct mtd_partition tx25_nand_partitions[] = {
-	{
-		.name = "RedBoot",
-		.offset = 0,
-		.size = 0x00040000,
-	}, {
-		.name = "kernel",
-		.offset = MTDPART_OFS_APPEND,
-		.size = 0x001A0000,
-	}, {
-		.name = "rootfs",
-		.offset = MTDPART_OFS_APPEND,
-		.size = 0x07E000000,
-	}, {
-		.name = "FIS directory",
-		.offset = MTDPART_OFS_APPEND,
-		.size = 0x00003000,
-		.mask_flags = MTD_WRITEABLE,
-	}, {
-		.name = "RedBoot config",
-		.offset = MTDPART_OFS_APPEND,
-		.size = 0x00001000,
-		.mask_flags = MTD_WRITEABLE,
-	},
-};
-
-static int tx25_nand_init(void)
-{
-	int ret;
-
-	DBG(0, "%s: Configuring NAND pins\n", __FUNCTION__);
-	ret = mxc_iomux_v3_setup_multiple_pads(karo_tx25_nand_pads,
-					       ARRAY_SIZE(karo_tx25_nand_pads));
-	if (ret) {
-		return ret;
-	}
-	return 0;
-}
-
-static void tx25_nand_exit(void)
-{
-	mxc_iomux_v3_release_multiple_pads(karo_tx25_nand_pads,
-					   ARRAY_SIZE(karo_tx25_nand_pads));
-}
-
-static struct flash_platform_data tx25_nand_data = {
-	.map_name = "nand_probe",
-	.name = "tx25-nand",
-	.parts = tx25_nand_partitions,
-	.nr_parts = ARRAY_SIZE(tx25_nand_partitions),
-	.width = 1,
-	.init = tx25_nand_init,
-	.exit = tx25_nand_exit,
-};
-#else
 static struct mxc_nand_platform_data tx25_nand_data = {
 	.hw_ecc = 1,
 	.width = 1,
@@ -722,7 +654,6 @@ static int tx25_nand_init(void)
 	return 0;
 }
 arch_initcall(tx25_nand_init);
-#endif
 
 static struct resource tx25_nand_resources[] = {
 	{
@@ -767,10 +698,6 @@ static struct platform_device tx25_v4l2o
 #if 0
 #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 static struct pad_desc mxc_i2c0_pins[] = {
-	/*
-	 * it seems the data line misses a pullup, so we must enable
-	 * the internal pullup as a local workaround
-	 */
 	MX25_PAD_I2C1_CLK__I2C1_CLK,
 	MX25_PAD_I2C1_DAT__I2C1_DAT,
 };
@@ -847,7 +774,7 @@ static struct resource mxc_tsadcc_resour
 static struct mxc_tsadcc_pdata mxc_tsadcc_pdata = {
 	.pen_debounce_time = 32,
 	.intref = 1,
-	.adc_clk = 1666667,
+	.adc_clk = 1750000,
 	.tsc_mode = MXC_TSC_4WIRE,
 	.hsyncen = 0,
 };
@@ -863,6 +790,113 @@ static struct platform_device mxc_tsadcc
 };
 #endif
 
+#if defined(CONFIG_CAN_FLEXCAN) || defined(CONFIG_CAN_FLEXCAN_MODULE)
+
+#ifdef CONFIG_CAN_FLEXCAN_CAN1
+static struct pad_desc tx25_flexcan1_pads[] = {
+	MX25_PAD_GPIO_A__CAN1_TX,
+	MX25_PAD_GPIO_B__CAN1_RX,
+};
+
+static struct resource tx25_flexcan1_resources[] = {
+	{
+		.start = CAN1_BASE_ADDR,
+		.end = CAN1_BASE_ADDR + 0x97f,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_CAN1,
+		.end = MXC_INT_CAN1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static int tx25_flexcan1_active(struct platform_device *pdev)
+{
+	return mxc_iomux_v3_setup_multiple_pads(tx25_flexcan1_pads,
+					       ARRAY_SIZE(tx25_flexcan1_pads));
+}
+
+static void tx25_flexcan1_inactive(struct platform_device *pdev)
+{
+	mxc_iomux_v3_release_multiple_pads(tx25_flexcan1_pads,
+					   ARRAY_SIZE(tx25_flexcan1_pads));
+	karo_tx25_gpio_config(tx25_flexcan1_pads,
+			      ARRAY_SIZE(tx25_flexcan1_pads));
+}
+
+static struct flexcan_platform_data tx25_flexcan1_pdata = {
+	//.core_reg = NULL;
+	//.io_reg = NULL;
+	//.xcvr_enable = NULL,
+	.active = tx25_flexcan1_active,
+	.inactive = tx25_flexcan1_inactive,
+};
+
+static struct platform_device tx25_flexcan1_device = {
+	.id = 0,
+	.name = "mxc-flexcan",
+	.num_resources = ARRAY_SIZE(tx25_flexcan1_resources),
+	.resource = tx25_flexcan1_resources,
+	.dev = {
+		.platform_data = &tx25_flexcan1_pdata,
+	},
+};
+#endif // CONFIG_CAN_FLEXCAN_CAN1
+
+#ifdef CONFIG_CAN_FLEXCAN_CAN2
+static struct pad_desc tx25_flexcan2_pads[] = {
+	MX25_PAD_GPIO_C__CAN2_TX,
+	MX25_PAD_GPIO_D__CAN2_RX,
+};
+
+static struct resource tx25_flexcan2_resources[] = {
+	{
+		.start = CAN2_BASE_ADDR,
+		.end = CAN2_BASE_ADDR + 0x97f,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_CAN2,
+		.end = MXC_INT_CAN2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static int tx25_flexcan2_active(struct platform_device *pdev)
+{
+	return mxc_iomux_v3_setup_multiple_pads(tx25_flexcan2_pads,
+					       ARRAY_SIZE(tx25_flexcan2_pads));
+}
+
+static void tx25_flexcan2_inactive(struct platform_device *pdev)
+{
+	mxc_iomux_v3_release_multiple_pads(tx25_flexcan2_pads,
+					   ARRAY_SIZE(tx25_flexcan2_pads));
+	karo_tx25_gpio_config(tx25_flexcan2_pads,
+			      ARRAY_SIZE(tx25_flexcan2_pads));
+}
+
+static struct flexcan_platform_data tx25_flexcan2_pdata = {
+	//.core_reg = NULL;
+	//.io_reg = NULL;
+	//.xcvr_enable = NULL,
+	.active = tx25_flexcan2_active,
+	.inactive = tx25_flexcan2_inactive,
+};
+
+static struct platform_device tx25_flexcan2_device = {
+	.id = 1,
+	.name = "mxc-flexcan",
+	.num_resources = ARRAY_SIZE(tx25_flexcan2_resources),
+	.resource = tx25_flexcan2_resources,
+	.dev = {
+		.platform_data = &tx25_flexcan2_pdata,
+	},
+};
+#endif // CONFIG_CAN_FLEXCAN_CAN2
+#endif // CONFIG_CAN_FLEXCAN || CONFIG_CAN_FLEXCAN_MODULE
+
 struct platform_dev_list {
 	struct platform_device *pdev;
 	int flag;
@@ -871,22 +905,28 @@ struct platform_dev_list {
 	{ .pdev = &mxc_rtc_device, .flag = -1, },
 #endif
 #if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)
-	{ .pdev = &tx25_nand_mtd_device, .flag = 1, },
+	{ .pdev = &tx25_nand_mtd_device, .flag = -1, },
 #endif
 #if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
-	{ .pdev = &fec_device, .flag = 1, },
+	{ .pdev = &fec_device, .flag = -1, },
 #endif
 #if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
-	{ .pdev = &mxcspi1_device, .flag = 1, },
+	{ .pdev = &mxcspi1_device, .flag = -1, },
 #endif
 #if defined(CONFIG_VIDEO_MXC_EMMA_OUTPUT) || defined(CONFIG_VIDEO_MXC_EMMA_OUTPUT_MODULE)
-	{ .pdev = &tx25_v4l2out_device, .flag = 1, },
+	{ .pdev = &tx25_v4l2out_device, .flag = -1, },
 #endif
 #if defined(CONFIG_MXC_VPU) || defined(CONFIG_MXC_VPU_MODULE)
-	{ .pdev = &mxc_vpu_device, .flag = 1, },
+	{ .pdev = &mxc_vpu_device, .flag = -1, },
 #endif
 #if defined(CONFIG_TOUCHSCREEN_MXC_TSADCC) || defined(CONFIG_TOUCHSCREEN_MXC_TSADCC_MODULE)
-	{ .pdev = &mxc_tsadcc_device, .flag = 1, },
+	{ .pdev = &mxc_tsadcc_device, .flag = -1, },
+#endif
+#ifdef CONFIG_CAN_FLEXCAN_CAN1
+	{ .pdev = &tx25_flexcan1_device, .flag = -1, },
+#endif
+#ifdef CONFIG_CAN_FLEXCAN_CAN2
+	{ .pdev = &tx25_flexcan2_device, .flag = -1, },
 #endif
 };
 #define TX25_NUM_DEVICES		ARRAY_SIZE(tx25_devices)
@@ -1057,17 +1097,20 @@ static struct pad_desc karo_tx25_gpios[]
 
 static int __init karo_tx25_setup_gpios(void)
 {
+#if 1
+	int count;
+
+	count = karo_tx25_gpio_config(karo_tx25_gpios, ARRAY_SIZE(karo_tx25_gpios));
+	DBG(0, "%s: %d out of %d pins set up as GPIO\n", __FUNCTION__,
+	    count, ARRAY_SIZE(karo_tx25_gpios));
+#else
 	int i;
 	int ret;
 	int count = 0;
 
 	for (i = 0; i < ARRAY_SIZE(karo_tx25_gpios); i++) {
 		struct pad_desc *pd = &karo_tx25_gpios[i];
-#if 0
-		if (i - 64 >= 16 && i - 64 < 32) {
-			continue;
-		}
-#endif
+
 		ret = mxc_iomux_v3_setup_pad(pd);
 		if (ret == 0) {
 #ifdef IOMUX_DEBUG
@@ -1086,23 +1129,6 @@ static int __init karo_tx25_setup_gpios(
 		}
 	}
 	DBG(0, "%s: %d out of %d pins set up as GPIO\n", __FUNCTION__, count, i);
-#if 0
-	if (gpio_request(42, "TEST") == 0) {
-		gpio_direction_output(42, 1);
-		while (1) {
-			gpio_set_value(42, 0);
-			if (gpio_get_value(42)) {
-				DBG(0, "%s: GPIO 42 is HIGH instead of LOW\n", __FUNCTION__);
-			}
-			msleep(1000);
-			gpio_set_value(42, 1);
-			if (!gpio_get_value(42)) {
-				DBG(0, "%s: GPIO 42 is LOW instead of HIGH\n", __FUNCTION__);
-			}
-			msleep(1000);
-		}
-	}
-	gpio_free(42);
 #endif
 	return 0;
 }
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/mach-mx2/stk5-baseboard.c linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/stk5-baseboard.c
--- linux-2.6.30-rc4-karo/arch/arm/mach-mx2/stk5-baseboard.c	2009-06-02 17:59:18.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/mach-mx2/stk5-baseboard.c	2009-07-06 15:40:58.000000000 +0200
@@ -34,7 +34,6 @@
 #include <linux/i2c.h>
 #include <linux/i2c/at24.h>
 #include <linux/spi/spi.h>
-//#include <linux/serial_8250.h>
 
 #include <linux/serial.h>
 #include <linux/fsl_devices.h>
@@ -59,8 +58,6 @@
 #include <mach/i2c.h>
 #include <mach/mmc.h>
 #include <mach/imx-uart.h>
-//#include <mach/ulpi.h>
-//#include <mach/mxc_ehci.h>
 #include <mach/board-stk5.h>
 
 #include "crm_regs.h"
@@ -184,167 +181,6 @@ static void __init karo_stk5_serial_init
 }
 #endif
 
-#ifdef CONFIG_USB_EHCI_MXC
-
-#define SMSC_VENDOR_ID		0x0424
-#define USB3317_PROD_ID		0x0006
-#define ULPI_FCTL		7
-
-static inline const char *ulpi_name(void __iomem *view)
-{
-	if ((unsigned long)view & 0x400) {
-		return "USBH2";
-	} else {
-		return "USBOTG";
-	}
-}
-
-static int usb3317_init(void __iomem *view)
-{
-	int vid, pid, ret;
-
-	ret = ulpi_read(ISP1504_VID_HIGH, view);
-	if (ret < 0) {
-		goto err;
-	}
-	vid = ret << 8;
-
-	ret = ulpi_read(ISP1504_VID_LOW, view);
-	if (ret < 0) {
-		goto err;
-	}
-	vid |= ret;
-
-	ret = ulpi_read(ISP1504_PID_HIGH, view);
-	if (ret < 0) {
-		goto err;
-	}
-	pid = ret << 8;
-
-	ret = ulpi_read(ISP1504_PID_LOW, view);
-	if (ret < 0) {
-		goto err;
-	}
-	pid |= ret;
-
-	pr_info("ULPI on %s port Vendor ID 0x%x Product ID 0x%x\n",
-		ulpi_name(view), vid, pid);
-	if (vid != SMSC_VENDOR_ID || pid != USB3317_PROD_ID) {
-		pr_err("No USB3317 found\n");
-		return -ENODEV;
-	}
- err:
-	if (ret < 0) {
-		printk(KERN_ERR "ULPI read on %s port failed with error %d\n",
-		       ulpi_name(view), ret);
-		return ret;
-	}
-	return 0;
-}
-
-static int usb3317_set_vbus_power(void __iomem *view, int on)
-{
-	int ret;
-
-	DBG(0, "%s: Switching %s port VBUS power %s\n", __FUNCTION__,
-	    ulpi_name(view), on ? "on" : "off");
-
-	if (on) {
-		ret = ulpi_set(DRV_VBUS_EXT |		/* enable external Vbus */
-			       DRV_VBUS |		/* enable internal Vbus */
-			       CHRG_VBUS,		/* charge Vbus */
-			       ISP1504_OTGCTL, view);
-	} else {
-		ret = ulpi_clear(DRV_VBUS_EXT |		/* disable external Vbus */
-				 DRV_VBUS,		/* disable internal Vbus */
-				 ISP1504_OTGCTL, view);
-		if (ret == 0) {
-			ret = ulpi_set(DISCHRG_VBUS,	   /* discharge Vbus */
-				       ISP1504_OTGCTL, view);
-		}
-	}
-	if (ret < 0) {
-		printk(KERN_ERR "ULPI read on %s port failed with error %d\n",
-		       ulpi_name(view), ret);
-		return ret;
-	}
-	return 0;
-}
-
-static int stk5_usbh2_init(struct platform_device *pdev)
-{
-	int ret;
-	u32 temp;
-	unsigned long flags;
-	void __iomem *view = IO_ADDRESS(OTG_BASE_ADDR + 0x570);
-
-	local_irq_save(flags);
-	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
-	temp &= ~((3 << 21) | (1 << 0));
-	temp |= (1 << 5) | (1 << 16) | (1 << 19) | (1 << 20);
-	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
-	local_irq_restore(flags);
-
-	/* select ULPI transceiver */
-	/* this must be done _before_ setting up the GPIOs! */
-	temp = readl(view + 0x14);
-	DBG(0, "%s: Changing USBH2_PORTSC1 from %08x to %08x\n", __FUNCTION__,
-	    temp, (temp & ~(3 << 30)) | (2 << 30));
-	temp &= ~(3 << 30);
-	temp |= 2 << 30;
-	writel(temp, view + 0x14);
-
-	/* Set to Host mode */
-	temp = readl(view + 0x38);
-	DBG(0, "%s: Changing USBH2_USBMODE from %08x to %08x\n", __FUNCTION__,
-	    temp, temp | 3);
-	writel(temp | 0x3, view + 0x38);
-
-	ret = gpio_usbh2_active();
-	if (ret != 0) {
-		return ret;
-	}
-
-	ret = usb3317_init(view);
-	if (ret != 0) {
-		goto err;
-	}
-	ret = usb3317_set_vbus_power(view, 1);
-	if (ret != 0) {
-		goto err;
-	}
-	return 0;
-
- err:
-	gpio_usbh2_inactive();
-	return ret;
-}
-
-static int stk5_usbh2_exit(struct platform_device *pdev)
-{
-	gpio_usbh2_inactive();
-	return 0;
-}
-
-static struct mxc_usbh_platform_data stk5_usbh2_data = {
-	.init = stk5_usbh2_init,
-	.exit = stk5_usbh2_exit,
-};
-
-static int __init karo_stk5_usbh2_register(void)
-{
-	int ret;
-
-	ret = mxc_register_device(&mxc_ehci2, &stk5_usbh2_data);
-	return ret;
-}
-#else
-static inline int karo_stk5_usbh2_register(void)
-{
-	return 0;
-}
-#endif // CONFIG_USB_EHCI_MXC
-
 #if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
 static struct gpio_led stk5_leds[] = {
 	{
@@ -470,25 +306,71 @@ static void stk5_gpio_lcdc_inactive(stru
 
 static struct imx_fb_platform_data stk5_fb_data[] __initdata = {
 	{
+#if 1
 		//.fb_mode = "Xenarc_700_Y-18",
 		.init = stk5_gpio_lcdc_active,
 		.exit = stk5_gpio_lcdc_inactive,
 		.lcd_power = NULL,
 		.backlight_power = NULL,
 
+		.pixclock	= 45833,
+
+		.xres		= 640,
+		.yres		= 480,
+
+		.bpp		= 8,
+
+		.hsync_len	= 64,
+		.right_margin	= 28 + 1,
+		.left_margin	= 20 + 3,
+
+		.vsync_len	= 1,
+		.lower_margin	= 0,
+		.upper_margin	= 16,
+
+		.pcr		= PCR_TFT | PCR_COLOR | PCR_END_BYTE_SWAP |
+		PCR_BPIX_8 | PCR_FLMPOL | PCR_LPPOL | PCR_SCLK_SEL,
+		.dmacr		= 0x80040060,
+
+		.cmap_greyscale	= 0,
+		.cmap_inverse	= 0,
+		.cmap_static	= 0,
+
+		.fixed_screen_cpu = NULL,
+	}, {
+#endif
+		//.fb_mode = "Xenarc_700_Y-18",
+		.init = stk5_gpio_lcdc_active,
+		.exit = stk5_gpio_lcdc_inactive,
+		.lcd_power = NULL,
+		.backlight_power = NULL,
+#if 1
 		.pixclock	= 34576,
+#else
+		.pixclock	= 38033,
+#endif
 		.xres		= 640,
 		.yres		= 480,
 
 		.bpp		= 32,
-
+#if 1
 		.hsync_len	= 64,
 		.right_margin	= 60 + 1,
 		.left_margin	= 80 + 3,
-
+#else
+		.hsync_len	= 64,
+		.right_margin	= 79 + 1,
+		.left_margin	= 57 + 3,
+#endif
+#if 1
 		.vsync_len	= 2,
+		.lower_margin	= 54,
 		.upper_margin	= 54,
+#else
+		.vsync_len	= 4,
 		.lower_margin	= 54,
+		.upper_margin	= 54,
+#endif
 #if 0
 		/* currently not used by driver! */
 		.sync		= ((0*FB_SYNC_HOR_HIGH_ACT) |
@@ -497,7 +379,7 @@ static struct imx_fb_platform_data stk5_
 #else
 		.pcr		= PCR_TFT | PCR_COLOR | PCR_PBSIZ_8 |
 		PCR_BPIX_18 | PCR_END_SEL | PCR_FLMPOL | PCR_LPPOL | PCR_SCLK_SEL,
-		.dmacr		= 0x800a0078,
+		.dmacr		= 0x80040060,
 #endif
 		.cmap_greyscale	= 0,
 		.cmap_inverse	= 0,
@@ -522,8 +404,8 @@ static struct imx_fb_platform_data stk5_
 		.left_margin	= 118 + 3,
 
 		.vsync_len	= 7,
-		.upper_margin	= 44,
 		.lower_margin	= 44,
+		.upper_margin	= 44,
 #if 0
 		/* currently not used by driver! */
 		.sync		= ((0*FB_SYNC_HOR_HIGH_ACT) |
@@ -560,8 +442,8 @@ static struct imx_fb_platform_data stk5_
 		.left_margin	= 118 + 3,
 
 		.vsync_len	= 7,
-		.upper_margin	= 28,
 		.lower_margin	= 60,
+		.upper_margin	= 28,
 #if 0
 		/* currently not used by driver! */
 		.sync		= ((0*FB_SYNC_HOR_HIGH_ACT) |
@@ -602,8 +484,8 @@ static struct imx_fb_platform_data stk5_
 		.left_margin	= 0 + 3,
 
 		.vsync_len	= 35,
-		.upper_margin	= 0,
 		.lower_margin	= 0,
+		.upper_margin	= 0,
 #if 0
 		/* currently not used by driver! */
 		.sync		= ((0*FB_SYNC_HOR_HIGH_ACT) |
@@ -974,11 +856,6 @@ static __init int karo_stk5_board_init(v
 		printk(KERN_WARNING "%s: karo_stk5_fb_register() failed: %d\n",
 		       __FUNCTION__, ret);
 	}
-	ret = karo_stk5_usbh2_register();
-	if (ret) {
-		printk(KERN_WARNING "%s: karo_stk5_usbh2_register() failed: %d\n",
-		       __FUNCTION__, ret);
-	}
 
 	for (i = 0; i < STK5_NUM_DEVICES; i++) {
 		if (stk5_devices[i].pdev == NULL) continue;
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/iomux-mx25.h linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/iomux-mx25.h
--- linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/iomux-mx25.h	2009-07-06 17:00:57.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/iomux-mx25.h	2009-07-06 15:41:30.000000000 +0200
@@ -34,475 +34,345 @@
  * IOMUX/PAD Bit field definitions
  */
 
-#define MX25_PAD_A10__A10			IOMUX_PAD(A10, A10, 0x000, 0x008, 0x00, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_A10__GPIO_4_0			IOMUX_PAD(A10, GPIO_4_0, 0x000, 0x008, 0x05, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_A13__A13			IOMUX_PAD(A13, A13, 0x22C, 0x00c, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A13__GPIO_4_1			IOMUX_PAD(A13, GPIO_4_1, 0x22C, 0x00c, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A14__A14			IOMUX_PAD(A14, A14, 0x230, 0x010, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A14__GPIO_2_0			IOMUX_PAD(A14, GPIO_2_0, 0x230, 0x010, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A15__A15			IOMUX_PAD(A15, A15, 0x234, 0x014, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A15__GPIO_2_1			IOMUX_PAD(A15, GPIO_2_1, 0x234, 0x014, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A16__A16			IOMUX_PAD(A16, A16, 0x000, 0x018, 0x10, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_A16__GPIO_2_2			IOMUX_PAD(A16, GPIO_2_2, 0x000, 0x018, 0x15, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_A17__A17			IOMUX_PAD(A17, A17, 0x238, 0x01c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A17__GPIO_2_3			IOMUX_PAD(A17, GPIO_2_3, 0x238, 0x01c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A18__A18			IOMUX_PAD(A18, A18, 0x23c, 0x020, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A18__GPIO_2_4			IOMUX_PAD(A18, GPIO_2_4, 0x23c, 0x020, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A18__FEC_COL			IOMUX_PAD(A18, FEC_COL, 0x23c, 0x020, 0x17, 0x504, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_A19__A19			IOMUX_PAD(A19, A19, 0x240, 0x024, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A19__FEC_RX_ER			IOMUX_PAD(A19, FEC_RX_ER, 0x240, 0x024, 0x17, 0x518, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_A19__GPIO_2_5			IOMUX_PAD(A19, GPIO_2_5, 0x240, 0x024, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A20__A20			IOMUX_PAD(A20, A20, 0x244, 0x028, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A20__GPIO_2_6			IOMUX_PAD(A20, GPIO_2_6, 0x244, 0x028, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A20__FEC_RDATA2		IOMUX_PAD(A20, FEC_RDATA2, 0x244, 0x028, 0x17, 0x50c, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_A21__A21			IOMUX_PAD(A21, A21, 0x248, 0x02c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A21__GPIO_2_7			IOMUX_PAD(A21, GPIO_2_7, 0x248, 0x02c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A21__FEC_RDATA3		IOMUX_PAD(A21, FEC_RDATA3, 0x248, 0x02c, 0x17, 0x510, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_A22__A22			IOMUX_PAD(A22, A22, 0x000, 0x030, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A22__GPIO_2_8			IOMUX_PAD(A22, GPIO_2_8, 0x000, 0x030, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A23__A23			IOMUX_PAD(A23, A23, 0x24c, 0x034, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A23__GPIO_2_9			IOMUX_PAD(A23, GPIO_2_9, 0x24c, 0x034, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A24__A24			IOMUX_PAD(A24, A24, 0x250, 0x038, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A24__GPIO_2_10			IOMUX_PAD(A24, GPIO_2_10, 0x250, 0x038, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A24__FEC_RX_CLK		IOMUX_PAD(A24, FEC_RX_CLK, 0x250, 0x038, 0x17, 0x514, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_A25__A25			IOMUX_PAD(A25, A25, 0x254, 0x03c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A25__GPIO_2_11			IOMUX_PAD(A25, GPIO_2_11, 0x254, 0x03c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_A25__FEC_CRS			IOMUX_PAD(A25, FEC_CRS, 0x254, 0x03c, 0x17, 0x508, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_EB0__EB0			IOMUX_PAD(EB0, EB0, 0x258, 0x040, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_EB0__AUD4_TXD			IOMUX_PAD(EB0, AUD4_TXD, 0x258, 0x040, 0x14, 0x464, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_EB0__GPIO_2_12			IOMUX_PAD(EB0, GPIO_2_12, 0x258, 0x040, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_EB1__EB1			IOMUX_PAD(EB1, EB1, 0x25c, 0x044, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_EB1__AUD4_RXD			IOMUX_PAD(EB1, AUD4_RXD, 0x25c, 0x044, 0x14, 0x460, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_EB1__GPIO_2_13			IOMUX_PAD(EB1, GPIO_2_13, 0x25c, 0x044, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_OE__OE				IOMUX_PAD(OE, OE, 0x260, 0x048, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_OE__AUD4_TXC			IOMUX_PAD(OE, AUD4_TXC, 0x260, 0x048, 0x14, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_OE__GPIO_2_14			IOMUX_PAD(OE, GPIO_2_14, 0x260, 0x048, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CS0__CS0			IOMUX_PAD(CS0, CS0, 0x000, 0x04c, 0x00, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CS0__GPIO_4_2			IOMUX_PAD(CS0, GPIO_4_2, 0x000, 0x04c, 0x05, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CS1__CS1			IOMUX_PAD(CS1, CS1, 0x000, 0x050, 0x00, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CS1__GPIO_4_3			IOMUX_PAD(CS1, GPIO_4_3, 0x000, 0x050, 0x05, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CS4__CS4			IOMUX_PAD(CS4, CS4, 0x264, 0x054, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CS4__UART5_CTS			IOMUX_PAD(CS4, UART5_CTS, 0x264, 0x054, 0x13, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CS4__GPIO_3_20			IOMUX_PAD(CS4, GPIO_3_20, 0x264, 0x054, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CS5__CS5			IOMUX_PAD(CS5, CS5, 0x268, 0x058, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CS5__UART5_RTS			IOMUX_PAD(CS5, UART5_RTS, 0x268, 0x058, 0x13, 0x574, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CS5__GPIO_3_21			IOMUX_PAD(CS5, GPIO_3_21, 0x268, 0x058, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_NF_CE0__NF_CE0			IOMUX_PAD(NF_CE0, NF_CE0, 0x26c, 0x05c, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_NF_CE0__GPIO_3_22		IOMUX_PAD(NF_CE0, GPIO_3_22, 0x26c, 0x05c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_ECB__ECB			IOMUX_PAD(ECB, ECB, 0x270, 0x060, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_ECB__UART5_TXD_MUX		IOMUX_PAD(ECB, UART5_TXD_MUX, 0x270, 0x060, 0x13, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_ECB__GPIO_3_23			IOMUX_PAD(ECB, GPIO_3_23, 0x270, 0x060, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LBA__LBA			IOMUX_PAD(LBA, LBA, 0x274, 0x064, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LBA__UART5_RXD_MUX		IOMUX_PAD(LBA, UART5_RXD_MUX, 0x274, 0x064, 0x13, 0x578, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LBA__GPIO_3_24			IOMUX_PAD(LBA, GPIO_3_24, 0x274, 0x064, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_BCLK__BCLK			IOMUX_PAD(BCLK, BCLK, 0x000, 0x068, 0x00, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_BCLK__GPIO_4_4			IOMUX_PAD(BCLK, GPIO_4_4, 0x000, 0x068, 0x05, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_RW__RW				IOMUX_PAD(RW, RW, 0x278, 0x06c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_RW__AUD4_TXFS			IOMUX_PAD(RW, AUD4_TXFS, 0x278, 0x06c, 0x14, 0x474, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_RW__GPIO_3_25			IOMUX_PAD(RW, GPIO_3_25, 0x278, 0x06c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_NFWE_B__NFWE_B			IOMUX_PAD(NFWE_B, NFWE_B, 0x000, 0x070, 0x10, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFWE_B__GPIO_3_26		IOMUX_PAD(NFWE_B, GPIO_3_26, 0x000, 0x070, 0x15, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFRE_B__NFRE_B			IOMUX_PAD(NFRE_B, NFRE_B, 0x000, 0x074, 0x10, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFRE_B__GPIO_3_27		IOMUX_PAD(NFRE_B, GPIO_3_27, 0x000, 0x074, 0x15, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFALE__NFALE			IOMUX_PAD(NFALE, NFALE, 0x000, 0x078, 0x10, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFALE__GPIO_3_28		IOMUX_PAD(NFALE, GPIO_3_28, 0x000, 0x078, 0x15, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFCLE__NFCLE			IOMUX_PAD(NFCLE, NFCLE, 0x000, 0x07c, 0x10, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFCLE__GPIO_3_29		IOMUX_PAD(NFCLE, GPIO_3_29, 0x000, 0x07c, 0x15, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFWP_B__NFWP_B			IOMUX_PAD(NFWP_B, NFWP_B, 0x000, 0x080, 0x10, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFWP_B__GPIO_3_30		IOMUX_PAD(NFWP_B, GPIO_3_30, 0x000, 0x080, 0x15, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_NFRB__NFRB			IOMUX_PAD(NFRB, NFRB, 0x27c, 0x084, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
-#define MX25_PAD_NFRB__GPIO_3_31		IOMUX_PAD(NFRB, GPIO_3_31, 0x27c, 0x084, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D15__D15			IOMUX_PAD(D15, D15, 0x280, 0x088, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D15__LD16			IOMUX_PAD(D15, LD16, 0x280, 0x088, 0x01, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D15__GPIO_4_5			IOMUX_PAD(D15, GPIO_4_5, 0x280, 0x088, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D14__D14			IOMUX_PAD(D14, D14, 0x284, 0x08c, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D14__LD17			IOMUX_PAD(D14, LD17, 0x284, 0x08c, 0x01, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D14__GPIO_4_6			IOMUX_PAD(D14, GPIO_4_6, 0x284, 0x08c, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D13__D13			IOMUX_PAD(D13, D13, 0x288, 0x090, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D13__LD18			IOMUX_PAD(D13, LD18, 0x288, 0x090, 0x01, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D13__GPIO_4_7			IOMUX_PAD(D13, GPIO_4_7, 0x288, 0x090, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D12__D12			IOMUX_PAD(D12, D12, 0x28c, 0x094, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D12__GPIO_4_8			IOMUX_PAD(D12, GPIO_4_8, 0x28c, 0x094, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D11__D11			IOMUX_PAD(D11, D11, 0x290, 0x098, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D11__GPIO_4_9			IOMUX_PAD(D11, GPIO_4_9, 0x290, 0x098, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D10__D10			IOMUX_PAD(D10, D10, 0x294, 0x09c, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D10__GPIO_4_10			IOMUX_PAD(D10, GPIO_4_10, 0x294, 0x09c, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D10__USBOTG_OC			IOMUX_PAD(D10, USBOTG_OC, 0x294, 0x09c, 0x06, 0x57c, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D9__D9				IOMUX_PAD(D9, D9, 0x298, 0x0a0, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D9__GPIO_4_11			IOMUX_PAD(D9, GPIO_4_11, 0x298, 0x0a0, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D9__USBH2_PWR			IOMUX_PAD(D9, USBH2_PWR, 0x298, 0x0a0, 0x06, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D8__D8				IOMUX_PAD(D8, D8, 0x29c, 0x0a4, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D8__GPIO_4_12			IOMUX_PAD(D8, GPIO_4_12, 0x29c, 0x0a4, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D8__USBH2_OC			IOMUX_PAD(D8, USBH2_OC, 0x29c, 0x0a4, 0x06, 0x580, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D7__D7				IOMUX_PAD(D7, D7, 0x2a0, 0x0a8, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D7__GPIO_4_13			IOMUX_PAD(D7, GPIO_4_13, 0x2a0, 0x0a8, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D6__D6				IOMUX_PAD(D6, D6, 0x2a4, 0x0ac, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D6__GPIO_4_14			IOMUX_PAD(D6, GPIO_4_14, 0x2a4, 0x0ac, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D5__D5				IOMUX_PAD(D5, D5, 0x2a8, 0x0b0, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D5__GPIO_4_15			IOMUX_PAD(D5, GPIO_4_15, 0x2a8, 0x0b0, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D4__D4				IOMUX_PAD(D4, D4, 0x2ac, 0x0b4, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D4__GPIO_4_16			IOMUX_PAD(D4, GPIO_4_16, 0x2ac, 0x0b4, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D3__D3				IOMUX_PAD(D3, D3, 0x2b0, 0x0b8, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D3__GPIO_4_17			IOMUX_PAD(D3, GPIO_4_17, 0x2b0, 0x0b8, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D2__D2				IOMUX_PAD(D2, D2, 0x2b4, 0x0bc, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D2__GPIO_4_18			IOMUX_PAD(D2, GPIO_4_18, 0x2b4, 0x0bc, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D1__D1				IOMUX_PAD(D1, D1, 0x2b8, 0x0c0, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D1__GPIO_4_19			IOMUX_PAD(D1, GPIO_4_19, 0x2b8, 0x0c0, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D0__D0				IOMUX_PAD(D0, D0, 0x2bc, 0x0c4, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_D0__GPIO_4_20			IOMUX_PAD(D0, GPIO_4_20, 0x2bc, 0x0c4, 0x05, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD0__LD0			IOMUX_PAD(LD0, LD0, 0x2c0, 0x0c8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD0__CSI_D0			IOMUX_PAD(LD0, CSI_D0, 0x2c0, 0x0c8, 0x12, 0x488, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD0__GPIO_2_15			IOMUX_PAD(LD0, GPIO_2_15, 0x2c0, 0x0c8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD1__LD1			IOMUX_PAD(LD1, LD1, 0x2c4, 0x0cc, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD1__CSI_D1			IOMUX_PAD(LD1, CSI_D1, 0x2c4, 0x0cc, 0x12, 0x48c, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD1__GPIO_2_16			IOMUX_PAD(LD1, GPIO_2_16, 0x2c4, 0x0cc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD2__LD2			IOMUX_PAD(LD2, LD2, 0x2c8, 0x0d0, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD2__GPIO_2_17			IOMUX_PAD(LD2, GPIO_2_17, 0x2c8, 0x0d0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD3__LD3			IOMUX_PAD(LD3, LD3, 0x2cc, 0x0d4, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD3__GPIO_2_18			IOMUX_PAD(LD3, GPIO_2_18, 0x2cc, 0x0d4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD4__LD4			IOMUX_PAD(LD4, LD4, 0x2d0, 0x0d8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD4__GPIO_2_19			IOMUX_PAD(LD4, GPIO_2_19, 0x2d0, 0x0d8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD5__LD5			IOMUX_PAD(LD5, LD5, 0x2d4, 0x0dc, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD5__GPIO_1_19			IOMUX_PAD(LD5, GPIO_1_19, 0x2d4, 0x0dc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD6__LD6			IOMUX_PAD(LD6, LD6, 0x2d8, 0x0e0, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD6__GPIO_1_20			IOMUX_PAD(LD6, GPIO_1_20, 0x2d8, 0x0e0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD7__LD7			IOMUX_PAD(LD7, LD7, 0x2dc, 0x0e4, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD7__GPIO_1_21			IOMUX_PAD(LD7, GPIO_1_21, 0x2dc, 0x0e4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD8__LD8			IOMUX_PAD(LD8, LD8, 0x2e0, 0x0e8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD8__FEC_TX_ERR		IOMUX_PAD(LD8, FEC_TX_ERR, 0x2e0, 0x0e8, 0x15, 0, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_LD9__LD9			IOMUX_PAD(LD9, LD9, 0x2e4, 0x0ec, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD9__FEC_COL			IOMUX_PAD(LD9, FEC_COL, 0x2e4, 0x0ec, 0x15, 0x504, 1, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_LD10__LD10			IOMUX_PAD(LD10, LD10, 0x2e8, 0x0f0, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD10__FEC_RX_ER		IOMUX_PAD(LD10, FEC_RX_ER, 0x2e8, 0x0f0, 0x15, 0x518, 1, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_LD11__LD11			IOMUX_PAD(LD11, LD11, 0x2ec, 0x0f4, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD11__FEC_RDATA2		IOMUX_PAD(LD11, FEC_RDATA2, 0x2ec, 0x0f4, 0x15, 0x50c, 1, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_LD12__LD12			IOMUX_PAD(LD12, LD12, 0x2f0, 0x0f8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD12__FEC_RDATA3		IOMUX_PAD(LD12, FEC_RDATA3, 0x2f0, 0x0f8, 0x15, 0x510, 1, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_LD13__LD13			IOMUX_PAD(LD13, LD13, 0x2f4, 0x0fc, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD13__FEC_TDATA2		IOMUX_PAD(LD13, FEC_TDATA2, 0x2f4, 0x0fc, 0x15, 0, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_LD14__LD14			IOMUX_PAD(LD14, LD14, 0x2f8, 0x100, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD14__FEC_TDATA3		IOMUX_PAD(LD14, FEC_TDATA3, 0x2f8, 0x100, 0x15, 0, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_LD15__LD15			IOMUX_PAD(LD15, LD15, 0x2fc, 0x104, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LD15__FEC_RX_CLK		IOMUX_PAD(LD15, FEC_RX_CLK, 0x2fc, 0x104, 0x15, 0x514, 1, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_HSYNC__HSYNC			IOMUX_PAD(HSYNC, HSYNC, 0x300, 0x108, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_HSYNC__GPIO_1_22		IOMUX_PAD(HSYNC, GPIO_1_22, 0x300, 0x108, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_VSYNC__VSYNC			IOMUX_PAD(VSYNC, VSYNC, 0x304, 0x10c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_VSYNC__GPIO_1_23		IOMUX_PAD(VSYNC, GPIO_1_23, 0x304, 0x10c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LSCLK__LSCLK			IOMUX_PAD(LSCLK, LSCLK, 0x308, 0x110, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_LSCLK__GPIO_1_24		IOMUX_PAD(LSCLK, GPIO_1_24, 0x308, 0x110, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_OE_ACD__OE_ACD			IOMUX_PAD(OE_ACD, OE_ACD, 0x30c, 0x114, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_OE_ACD__GPIO_1_25		IOMUX_PAD(OE_ACD, GPIO_1_25, 0x30c, 0x114, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CONTRAST__CONTRAST		IOMUX_PAD(CONTRAST, CONTRAST, 0x310, 0x118, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CONTRAST__FEC_CRS		IOMUX_PAD(CONTRAST, FEC_CRS, 0x310, 0x118, 0x15, 0x508, 1, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_PWM__PWM			IOMUX_PAD(PWM, PWM, 0x314, 0x11c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_PWM__GPIO_1_26			IOMUX_PAD(PWM, GPIO_1_26, 0x314, 0x11c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_PWM__USBH2_OC			IOMUX_PAD(PWM, USBH2_OC, 0x314, 0x11c, 0x16, 0x580, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D2__CSI_D2			IOMUX_PAD(CSI_D2, CSI_D2, 0x318, 0x120, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D2__UART5_RXD_MUX		IOMUX_PAD(CSI_D2, UART5_RXD_MUX, 0x318, 0x120, 0x11, 0x578, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D2__GPIO_1_27		IOMUX_PAD(CSI_D2, GPIO_1_27, 0x318, 0x120, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D3__CSI_D3			IOMUX_PAD(CSI_D3, CSI_D3, 0x31c, 0x124, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D3__GPIO_1_28		IOMUX_PAD(CSI_D3, GPIO_1_28, 0x31c, 0x124, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D4__CSI_D4			IOMUX_PAD(CSI_D4, CSI_D4, 0x320, 0x128, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D4__UART5_RTS		IOMUX_PAD(CSI_D4, UART5_RTS, 0x320, 0x128, 0x11, 0x574, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D4__GPIO_1_29		IOMUX_PAD(CSI_D4, GPIO_1_29, 0x320, 0x128, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D5__CSI_D5			IOMUX_PAD(CSI_D5, CSI_D5, 0x324, 0x12c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D5__GPIO_1_30		IOMUX_PAD(CSI_D5, GPIO_1_30, 0x324, 0x12c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D6__CSI_D6			IOMUX_PAD(CSI_D6, CSI_D6, 0x328, 0x130, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D6__GPIO_1_31		IOMUX_PAD(CSI_D6, GPIO_1_31, 0x328, 0x130, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D7__CSI_D7			IOMUX_PAD(CSI_D7, CSI_D7, 0x32c, 0x134, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D7__GPIO_1_6		IOMUX_PAD(CSI_D7, GPIO_1_6, 0x32c, 0x134, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D8__CSI_D8			IOMUX_PAD(CSI_D8, CSI_D8, 0x330, 0x138, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D8__GPIO_1_7		IOMUX_PAD(CSI_D8, GPIO_1_7, 0x330, 0x138, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D9__CSI_D9			IOMUX_PAD(CSI_D9, CSI_D9, 0x334, 0x13c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_D9__GPIO_4_21		IOMUX_PAD(CSI_D9, GPIO_4_21, 0x334, 0x13c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_MCLK__CSI_MCLK		IOMUX_PAD(CSI_MCLK, CSI_MCLK, 0x338, 0x140, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_MCLK__GPIO_1_8		IOMUX_PAD(CSI_MCLK, GPIO_1_8, 0x338, 0x140, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_VSYNC__CSI_VSYNC		IOMUX_PAD(CSI_VSYNC, CSI_VSYNC, 0x33c, 0x144, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_VSYNC__GPIO_1_9		IOMUX_PAD(CSI_VSYNC, GPIO_1_9, 0x33c, 0x144, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_HSYNC__CSI_HSYNC		IOMUX_PAD(CSI_HSYNC, CSI_HSYNC, 0x340, 0x148, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_HSYNC__GPIO_1_10		IOMUX_PAD(CSI_HSYNC, GPIO_1_10, 0x340, 0x148, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_PIXCLK__CSI_PIXCLK		IOMUX_PAD(CSI_PIXCLK, CSI_PIXCLK, 0x344, 0x14c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSI_PIXCLK__GPIO_1_11		IOMUX_PAD(CSI_PIXCLK, GPIO_1_11, 0x344, 0x14c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_I2C1_CLK__I2C1_CLK		IOMUX_PAD(I2C1_CLK, I2C1_CLK, 0x348, 0x150, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_I2C1_CLK__GPIO_1_12		IOMUX_PAD(I2C1_CLK, GPIO_1_12, 0x348, 0x150, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_I2C1_DAT__I2C1_DAT		IOMUX_PAD(I2C1_DAT, I2C1_DAT, 0x34c, 0x154, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_I2C1_DAT__GPIO_1_13		IOMUX_PAD(I2C1_DAT, GPIO_1_13, 0x34c, 0x154, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_MOSI__CSPI1_MOSI		IOMUX_PAD(CSPI1_MOSI, CSPI1_MOSI, 0x350, 0x158, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_MOSI__GPIO_1_14		IOMUX_PAD(CSPI1_MOSI, GPIO_1_14, 0x350, 0x158, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_MISO__CSPI1_MISO		IOMUX_PAD(CSPI1_MISO, CSPI1_MISO, 0x354, 0x15c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_MISO__GPIO_1_15		IOMUX_PAD(CSPI1_MISO, GPIO_1_15, 0x354, 0x15c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_SS0__CSPI1_SS0		IOMUX_PAD(CSPI1_SS0, CSPI1_SS0, 0x358, 0x160, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_SS0__GPIO_1_16		IOMUX_PAD(CSPI1_SS0, GPIO_1_16, 0x358, 0x160, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_SS1__CSPI1_SS1		IOMUX_PAD(CSPI1_SS1, CSPI1_SS1, 0x35c, 0x164, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_SS1__GPIO_1_17		IOMUX_PAD(CSPI1_SS1, GPIO_1_17, 0x35c, 0x164, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_SCLK__CSPI1_SCLK		IOMUX_PAD(CSPI1_SCLK, CSPI1_SCLK, 0x360, 0x168, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_SCLK__GPIO_1_18		IOMUX_PAD(CSPI1_SCLK, GPIO_1_18, 0x360, 0x168, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CSPI1_RDY__CSPI1_RDY		IOMUX_PAD(CSPI1_RDY, CSPI1_RDY, 0x364, 0x16c, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
-#define MX25_PAD_CSPI1_RDY__GPIO_2_22		IOMUX_PAD(CSPI1_RDY, GPIO_2_22, 0x364, 0x16c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART1_RXD__UART1_RXD		IOMUX_PAD(UART1_RXD, UART1_RXD, 0x368, 0x170, 0x10, 0, 0, PAD_CTL_PULL_DOWN_100K)
-#define MX25_PAD_UART1_RXD__GPIO_4_22		IOMUX_PAD(UART1_RXD, GPIO_4_22, 0x368, 0x170, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART1_TXD__UART1_TXD		IOMUX_PAD(UART1_TXD, UART1_TXD, 0x36c, 0x174, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART1_TXD__GPIO_4_23		IOMUX_PAD(UART1_TXD, GPIO_4_23, 0x36c, 0x174, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART1_RTS__UART1_RTS		IOMUX_PAD(UART1_RTS, UART1_RTS, 0x370, 0x178, 0x10, 0, 0, PAD_CTL_PULL_UP_100K)
-#define MX25_PAD_UART1_RTS__CSI_D0		IOMUX_PAD(UART1_RTS, CSI_D0, 0x370, 0x178, 0x11, 0x488, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART1_RTS__GPIO_4_24		IOMUX_PAD(UART1_RTS, GPIO_4_24, 0x370, 0x178, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART1_CTS__UART1_CTS		IOMUX_PAD(UART1_CTS, UART1_CTS, 0x374, 0x17c, 0x10, 0, 0, PAD_CTL_PULL_UP_100K)
-#define MX25_PAD_UART1_CTS__CSI_D1		IOMUX_PAD(UART1_CTS, CSI_D1, 0x374, 0x17c, 0x11, 0x48c, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART1_CTS__GPIO_4_25		IOMUX_PAD(UART1_CTS, GPIO_4_25, 0x374, 0x17c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART2_RXD__UART2_RXD		IOMUX_PAD(UART2_RXD, UART2_RXD, 0x378, 0x180, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART2_RXD__GPIO_4_26		IOMUX_PAD(UART2_RXD, GPIO_4_26, 0x378, 0x180, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART2_TXD__UART2_TXD		IOMUX_PAD(UART2_TXD, UART2_TXD, 0x37c, 0x184, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART2_TXD__GPIO_4_27		IOMUX_PAD(UART2_TXD, GPIO_4_27, 0x37c, 0x184, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART2_RTS__UART2_RTS		IOMUX_PAD(UART2_RTS, UART2_RTS, 0x380, 0x188, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART2_RTS__FEC_COL		IOMUX_PAD(UART2_RTS, FEC_COL, 0x380, 0x188, 0x12, 0x504, 2, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_UART2_RTS__GPIO_4_28		IOMUX_PAD(UART2_RTS, GPIO_4_28, 0x380, 0x188, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART2_CTS__FEC_RX_ER		IOMUX_PAD(UART2_CTS, FEC_RX_ER, 0x384, 0x18c, 0x12, 0x518, 2, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_UART2_CTS__UART2_CTS		IOMUX_PAD(UART2_CTS, UART2_CTS, 0x384, 0x18c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_UART2_CTS__GPIO_4_29		IOMUX_PAD(UART2_CTS, GPIO_4_29, 0x384, 0x18c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_SD1_CMD__SD1_CMD		IOMUX_PAD(SD1_CMD, SD1_CMD, 0x388, 0x190, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_CMD__FEC_RDATA2		IOMUX_PAD(SD1_CMD, FEC_RDATA2, 0x388, 0x190, 0x12, 0x50c, 2, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_CMD__GPIO_2_23		IOMUX_PAD(SD1_CMD, GPIO_2_23, 0x388, 0x190, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_SD1_CLK__SD1_CLK		IOMUX_PAD(SD1_CLK, SD1_CLK, 0x38c, 0x194, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_CLK__FEC_RDATA3		IOMUX_PAD(SD1_CLK, FEC_RDATA3, 0x38c, 0x194, 0x12, 0x510, 2, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_CLK__GPIO_2_24		IOMUX_PAD(SD1_CLK, GPIO_2_24, 0x38c, 0x194, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_SD1_DATA0__SD1_DATA0		IOMUX_PAD(SD1_DATA0, SD1_DATA0, 0x390, 0x198, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_DATA0__GPIO_2_25		IOMUX_PAD(SD1_DATA0, GPIO_2_25, 0x390, 0x198, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_SD1_DATA1__SD1_DATA1		IOMUX_PAD(SD1_DATA1, SD1_DATA1, 0x394, 0x19c, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_DATA1__AUD7_RXD		IOMUX_PAD(SD1_DATA1, AUD7_RXD, 0x394, 0x19c, 0x13, 0x478, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_SD1_DATA1__GPIO_2_26		IOMUX_PAD(SD1_DATA1, GPIO_2_26, 0x394, 0x19c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_SD1_DATA2__SD1_DATA2		IOMUX_PAD(SD1_DATA2, SD1_DATA2, 0x398, 0x1a0, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_DATA2__FEC_RX_CLK		IOMUX_PAD(SD1_DATA2, FEC_RX_CLK, 0x398, 0x1a0, 0x15, 0x514, 2, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_DATA2__GPIO_2_27		IOMUX_PAD(SD1_DATA2, GPIO_2_27, 0x398, 0x1a0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_SD1_DATA3__SD1_DATA3		IOMUX_PAD(SD1_DATA3, SD1_DATA3, 0x39c, 0x1a4, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_DATA3__FEC_CRS		IOMUX_PAD(SD1_DATA3, FEC_CRS, 0x39c, 0x1a4, 0x10, 0x508, 2, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_SD1_DATA3__GPIO_2_28		IOMUX_PAD(SD1_DATA3, GPIO_2_28, 0x39c, 0x1a4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_ROW0__KPP_ROW0		IOMUX_PAD(KPP_ROW0, KPP_ROW0, 0x3a0, 0x1a8, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
-#define MX25_PAD_KPP_ROW0__GPIO_2_29		IOMUX_PAD(KPP_ROW0, GPIO_2_29, 0x3a0, 0x1a8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_ROW1__KPP_ROW1		IOMUX_PAD(KPP_ROW1, KPP_ROW1, 0x3a4, 0x1ac, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
-#define MX25_PAD_KPP_ROW1__GPIO_2_30		IOMUX_PAD(KPP_ROW1, GPIO_2_30, 0x3a4, 0x1ac, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_ROW2__KPP_ROW2		IOMUX_PAD(KPP_ROW2, KPP_ROW2, 0x3a8, 0x1b0, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
-#define MX25_PAD_KPP_ROW2__CSI_D0		IOMUX_PAD(KPP_ROW2, CSI_D0, 0x3a8, 0x1b0, 0x13, 0x488, 2, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_ROW2__GPIO_2_31		IOMUX_PAD(KPP_ROW2, GPIO_2_31, 0x3a8, 0x1b0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_ROW3__KPP_ROW3		IOMUX_PAD(KPP_ROW3, KPP_ROW3, 0x3ac, 0x1b4, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
-#define MX25_PAD_KPP_ROW3__CSI_LD1		IOMUX_PAD(KPP_ROW3, CSI_LD1, 0x3ac, 0x1b4, 0x13, 0x48c, 2, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_ROW3__GPIO_3_0		IOMUX_PAD(KPP_ROW3, GPIO_3_0, 0x3ac, 0x1b4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_COL0__KPP_COL0		IOMUX_PAD(KPP_COL0, KPP_COL0, 0x3b0, 0x1b8, 0x10, 0, 0, PAD_CTL_PULL_KEEPER | PAD_CTL_OUTPUT_OPEN_DRAIN)
-#define MX25_PAD_KPP_COL0__GPIO_3_1		IOMUX_PAD(KPP_COL0, GPIO_3_1, 0x3b0, 0x1b8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_COL1__KPP_COL1		IOMUX_PAD(KPP_COL1, KPP_COL1, 0x3b4, 0x1bc, 0x10, 0, 0, PAD_CTL_PULL_KEEPER | PAD_CTL_OUTPUT_OPEN_DRAIN)
-#define MX25_PAD_KPP_COL1__GPIO_3_2		IOMUX_PAD(KPP_COL1, GPIO_3_2, 0x3b4, 0x1bc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_COL2__KPP_COL2		IOMUX_PAD(KPP_COL2, KPP_COL2, 0x3b8, 0x1c0, 0x10, 0, 0, PAD_CTL_PULL_KEEPER | PAD_CTL_OUTPUT_OPEN_DRAIN)
-#define MX25_PAD_KPP_COL2__GPIO_3_3		IOMUX_PAD(KPP_COL2, GPIO_3_3, 0x3b8, 0x1c0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_KPP_COL3__KPP_COL3		IOMUX_PAD(KPP_COL3, KPP_COL3, 0x3bc, 0x1c4, 0x10, 0, 0, PAD_CTL_PULL_KEEPER | PAD_CTL_OUTPUT_OPEN_DRAIN)
-#define MX25_PAD_KPP_COL3__GPIO_3_4		IOMUX_PAD(KPP_COL3, GPIO_3_4, 0x3bc, 0x1c4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_MDC__FEC_MDC		IOMUX_PAD(FEC_MDC, FEC_MDC, 0x3c0, 0x1c8, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_MDC__AUD4_TXD		IOMUX_PAD(FEC_MDC, AUD4_TXD, 0x3c0, 0x1c8, 0x12, 0x464, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_MDC__GPIO_3_5		IOMUX_PAD(FEC_MDC, GPIO_3_5, 0x3c0, 0x1c8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_MDIO__FEC_MDIO		IOMUX_PAD(FEC_MDIO, FEC_MDIO, 0x3c4, 0x1cc, 0x10, 0, 0, PAD_CTL_HYSTERESIS | PAD_CTL_PULL_UP_22K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_MDIO__AUD4_RXD		IOMUX_PAD(FEC_MDIO, AUD4_RXD, 0x3c4, 0x1cc, 0x12, 0x460, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_MDIO__GPIO_3_6		IOMUX_PAD(FEC_MDIO, GPIO_3_6, 0x3c4, 0x1cc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_TDATA0__FEC_TDATA0		IOMUX_PAD(FEC_TDATA0, FEC_TDATA0, 0x3c8, 0x1d0, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_TDATA0__GPIO_3_7		IOMUX_PAD(FEC_TDATA0, GPIO_3_7, 0x3c8, 0x1d0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_TDATA1__FEC_TDATA1		IOMUX_PAD(FEC_TDATA1, FEC_TDATA1, 0x3cc, 0x1d4, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_TDATA1__AUD4_TXFS		IOMUX_PAD(FEC_TDATA1, AUD4_TXFS, 0x3cc, 0x1d4, 0x12, 0x474, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_TDATA1__GPIO_3_8		IOMUX_PAD(FEC_TDATA1, GPIO_3_8, 0x3cc, 0x1d4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_TX_EN__FEC_TX_EN		IOMUX_PAD(FEC_TX_EN, FEC_TX_EN, 0x3d0, 0x1d8, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_TX_EN__GPIO_3_9   		IOMUX_PAD(FEC_TX_EN, GPIO_3_9   , 0x3d0, 0x1d8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_RDATA0__FEC_RDATA0		IOMUX_PAD(FEC_RDATA0, FEC_RDATA0, 0x3d4, 0x1dc, 0x10, 0, 0, PAD_CTL_PULL_DOWN_100K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_RDATA0__GPIO_3_10		IOMUX_PAD(FEC_RDATA0, GPIO_3_10, 0x3d4, 0x1dc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_RDATA1__FEC_RDATA1		IOMUX_PAD(FEC_RDATA1, FEC_RDATA1, 0x3d8, 0x1e0, 0x10, 0, 0, PAD_CTL_PULL_DOWN_100K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_RDATA1__GPIO_3_11		IOMUX_PAD(FEC_RDATA1, GPIO_3_11, 0x3d8, 0x1e0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_RX_DV__FEC_RX_DV		IOMUX_PAD(FEC_RX_DV, FEC_RX_DV, 0x3dc, 0x1e4, 0x10, 0, 0, PAD_CTL_PULL_DOWN_100K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_RX_DV__CAN2_RX		IOMUX_PAD(FEC_RX_DV, CAN2_RX, 0x3dc, 0x1e4, 0x14, 0x484, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_RX_DV__GPIO_3_12		IOMUX_PAD(FEC_RX_DV, GPIO_3_12, 0x3dc, 0x1e4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_FEC_TX_CLK__FEC_TX_CLK		IOMUX_PAD(FEC_TX_CLK, FEC_TX_CLK, 0x3e0, 0x1e8, 0x10, 0, 0, PAD_CTL_HYSTERESIS | PAD_CTL_PULL_DOWN_100K | PAD_CTL_SLEW_RATE_FAST)
-#define MX25_PAD_FEC_TX_CLK__GPIO_3_13		IOMUX_PAD(FEC_TX_CLK, GPIO_3_13, 0x3e0, 0x1e8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_RTCK__RTCK			IOMUX_PAD(RTCK, RTCK, 0x3e4, 0x1ec, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_RTCK__OWIRE			IOMUX_PAD(RTCK, OWIRE, 0x3e4, 0x1ec, 0x11, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_RTCK__GPIO_3_14		IOMUX_PAD(RTCK, GPIO_3_14, 0x3e4, 0x1ec, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_DE_B__DE_B			IOMUX_PAD(DE_B, DE_B, 0x3ec, 0x1f0, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_DE_B__GPIO_2_20		IOMUX_PAD(DE_B, GPIO_2_20, 0x3ec, 0x1f0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_TDO__TDO			IOMUX_PAD(TDO, TDO, 0x3e8, 0x000, 0x00, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_A__GPIO_A			IOMUX_PAD(GPIO_A, GPIO_A, 0x3f0, 0x1f4, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_A__USBOTG_PWR		IOMUX_PAD(GPIO_A, USBOTG_PWR, 0x3f0, 0x1f4, 0x12, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_B__GPIO_B			IOMUX_PAD(GPIO_B, GPIO_B, 0x3f4, 0x1f8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_B__USBOTG_OC		IOMUX_PAD(GPIO_B, USBOTG_OC, 0x3f4, 0x1f8, 0x12, 0x57c, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_C__GPIO_C			IOMUX_PAD(GPIO_C, GPIO_C, 0x3f8, 0x1fc, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_C__CAN2_TX		IOMUX_PAD(GPIO_C, CAN2_TX, 0x3f8, 0x1fc, 0x16, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_D__GPIO_D			IOMUX_PAD(GPIO_D, GPIO_D, 0x3fc, 0x200, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_D__CAN2_RX		IOMUX_PAD(GPIO_D, CAN2_RX, 0x3fc, 0x200, 0x16, 0x484, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_E__GPIO_E			IOMUX_PAD(GPIO_E, GPIO_E, 0x400, 0x204, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_E__AUD7_TXD		IOMUX_PAD(GPIO_E, AUD7_TXD, 0x400, 0x204, 0x14, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_F__GPIO_F			IOMUX_PAD(GPIO_F, GPIO_F, 0x404, 0x208, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_GPIO_F__AUD7_TXC		IOMUX_PAD(GPIO_F, AUD7_TXC, 0x404, 0x208, 0x14, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_EXT_ARMCLK__EXT_ARMCLK		IOMUX_PAD(EXT_ARMCLK, EXT_ARMCLK, 0x000, 0x20c, 0x10, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_EXT_ARMCLK__GPIO_3_15		IOMUX_PAD(EXT_ARMCLK, GPIO_3_15, 0x000, 0x20c, 0x15, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_UPLL_BYPCLK__UPLL_BYPCLK	IOMUX_PAD(UPLL_BYPCLK, UPLL_BYPCLK, 0x000, 0x210, 0x10, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_UPLL_BYPCLK__GPIO_3_16		IOMUX_PAD(UPLL_BYPCLK, GPIO_3_16, 0x000, 0x210, 0x15, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_VSTBY_REQ__VSTBY_REQ		IOMUX_PAD(VSTBY_REQ, VSTBY_REQ, 0x408, 0x214, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_VSTBY_REQ__AUD7_TXFS		IOMUX_PAD(VSTBY_REQ, AUD7_TXFS, 0x408, 0x214, 0x14, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_VSTBY_REQ__GPIO_3_17		IOMUX_PAD(VSTBY_REQ, GPIO_3_17, 0x408, 0x214, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_VSTBY_ACK__VSTBY_ACK		IOMUX_PAD(VSTBY_ACK, VSTBY_ACK, 0x40c, 0x218, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_VSTBY_ACK__GPIO_3_18		IOMUX_PAD(VSTBY_ACK, GPIO_3_18, 0x40c, 0x218, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_POWER_FAIL__POWER_FAIL		IOMUX_PAD(POWER_FAIL, POWER_FAIL, 0x410, 0x21c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_POWER_FAIL__AUD7_RXD		IOMUX_PAD(POWER_FAIL, AUD7_RXD, 0x410, 0x21c, 0x14, 0x478, 1, 0 | NO_PAD_CTRL)
-#define MX25_PAD_POWER_FAIL__GPIO_3_19		IOMUX_PAD(POWER_FAIL, GPIO_3_19, 0x410, 0x21c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CLKO__CLKO			IOMUX_PAD(CLKO, CLKO, 0x414, 0x220, 0x10, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_CLKO__GPIO_2_21		IOMUX_PAD(CLKO, GPIO_2_21, 0x414, 0x220, 0x15, 0, 0, 0 | NO_PAD_CTRL)
-#define MX25_PAD_BOOT_MODE0__BOOT_MODE0		IOMUX_PAD(BOOT_MODE0, BOOT_MODE0, 0x000, 0x224, 0x00, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_BOOT_MODE0__GPIO_4_30		IOMUX_PAD(BOOT_MODE0, GPIO_4_30, 0x000, 0x224, 0x05, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_BOOT_MODE1__BOOT_MODE1		IOMUX_PAD(BOOT_MODE1, BOOT_MODE1, 0x000, 0x228, 0x00, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_BOOT_MODE1__GPIO_4_31		IOMUX_PAD(BOOT_MODE1, GPIO_4_31, 0x000, 0x228, 0x05, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_A10__A10		IOMUX_PAD(A10, A10, 0x000, 0x008, 0x00, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_A10__GPIO_4_0		IOMUX_PAD(A10, GPIO_4_0, 0x000, 0x008, 0x05, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_A13__A13		IOMUX_PAD(A13, A13, 0x22C, 0x00c, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A13__GPIO_4_1		IOMUX_PAD(A13, GPIO_4_1, 0x22C, 0x00c, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A14__A14		IOMUX_PAD(A14, A14, 0x230, 0x010, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A14__GPIO_2_0		IOMUX_PAD(A14, GPIO_2_0, 0x230, 0x010, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A15__A15		IOMUX_PAD(A15, A15, 0x234, 0x014, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A15__GPIO_2_1		IOMUX_PAD(A15, GPIO_2_1, 0x234, 0x014, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A16__A16		IOMUX_PAD(A16, A16, 0x000, 0x018, 0x10, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_A16__GPIO_2_2		IOMUX_PAD(A16, GPIO_2_2, 0x000, 0x018, 0x15, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_A17__A17		IOMUX_PAD(A17, A17, 0x238, 0x01c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A17__GPIO_2_3		IOMUX_PAD(A17, GPIO_2_3, 0x238, 0x01c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A18__A18		IOMUX_PAD(A18, A18, 0x23c, 0x020, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A18__GPIO_2_4		IOMUX_PAD(A18, GPIO_2_4, 0x23c, 0x020, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A18__FEC_COL		IOMUX_PAD(A18, FEC_COL, 0x23c, 0x020, 0x17, 0x504, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_A19__A19		IOMUX_PAD(A19, A19, 0x240, 0x024, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A19__FEC_RX_ER		IOMUX_PAD(A19, FEC_RX_ER, 0x240, 0x024, 0x17, 0x518, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_A19__GPIO_2_5		IOMUX_PAD(A19, GPIO_2_5, 0x240, 0x024, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A20__A20		IOMUX_PAD(A20, A20, 0x244, 0x028, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A20__GPIO_2_6		IOMUX_PAD(A20, GPIO_2_6, 0x244, 0x028, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A20__FEC_RDATA2	IOMUX_PAD(A20, FEC_RDATA2, 0x244, 0x028, 0x17, 0x50c, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_A21__A21		IOMUX_PAD(A21, A21, 0x248, 0x02c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A21__GPIO_2_7		IOMUX_PAD(A21, GPIO_2_7, 0x248, 0x02c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A21__FEC_RDATA3	IOMUX_PAD(A21, FEC_RDATA3, 0x248, 0x02c, 0x17, 0x510, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_A22__A22		IOMUX_PAD(A22, A22, 0x000, 0x030, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A22__GPIO_2_8		IOMUX_PAD(A22, GPIO_2_8, 0x000, 0x030, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A23__A23		IOMUX_PAD(A23, A23, 0x24c, 0x034, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A23__GPIO_2_9		IOMUX_PAD(A23, GPIO_2_9, 0x24c, 0x034, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A24__A24		IOMUX_PAD(A24, A24, 0x250, 0x038, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A24__GPIO_2_10		IOMUX_PAD(A24, GPIO_2_10, 0x250, 0x038, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A24__FEC_RX_CLK	IOMUX_PAD(A24, FEC_RX_CLK, 0x250, 0x038, 0x17, 0x514, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_A25__A25		IOMUX_PAD(A25, A25, 0x254, 0x03c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A25__GPIO_2_11		IOMUX_PAD(A25, GPIO_2_11, 0x254, 0x03c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_A25__FEC_CRS		IOMUX_PAD(A25, FEC_CRS, 0x254, 0x03c, 0x17, 0x508, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_EB0__EB0		IOMUX_PAD(EB0, EB0, 0x258, 0x040, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_EB0__AUD4_TXD		IOMUX_PAD(EB0, AUD4_TXD, 0x258, 0x040, 0x14, 0x464, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_EB0__GPIO_2_12		IOMUX_PAD(EB0, GPIO_2_12, 0x258, 0x040, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_EB1__EB1		IOMUX_PAD(EB1, EB1, 0x25c, 0x044, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_EB1__AUD4_RXD		IOMUX_PAD(EB1, AUD4_RXD, 0x25c, 0x044, 0x14, 0x460, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_EB1__GPIO_2_13		IOMUX_PAD(EB1, GPIO_2_13, 0x25c, 0x044, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_OE__OE			IOMUX_PAD(OE, OE, 0x260, 0x048, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_OE__AUD4_TXC		IOMUX_PAD(OE, AUD4_TXC, 0x260, 0x048, 0x14, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_OE__GPIO_2_14		IOMUX_PAD(OE, GPIO_2_14, 0x260, 0x048, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CS0__CS0		IOMUX_PAD(CS0, CS0, 0x000, 0x04c, 0x00, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CS0__GPIO_4_2		IOMUX_PAD(CS0, GPIO_4_2, 0x000, 0x04c, 0x05, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CS1__CS1		IOMUX_PAD(CS1, CS1, 0x000, 0x050, 0x00, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CS1__GPIO_4_3		IOMUX_PAD(CS1, GPIO_4_3, 0x000, 0x050, 0x05, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CS4__CS4		IOMUX_PAD(CS4, CS4, 0x264, 0x054, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CS4__UART5_CTS		IOMUX_PAD(CS4, UART5_CTS, 0x264, 0x054, 0x13, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CS4__GPIO_3_20		IOMUX_PAD(CS4, GPIO_3_20, 0x264, 0x054, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CS5__CS5		IOMUX_PAD(CS5, CS5, 0x268, 0x058, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CS5__UART5_RTS		IOMUX_PAD(CS5, UART5_RTS, 0x268, 0x058, 0x13, 0x574, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CS5__GPIO_3_21		IOMUX_PAD(CS5, GPIO_3_21, 0x268, 0x058, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_NF_CE0__NF_CE0		IOMUX_PAD(NF_CE0, NF_CE0, 0x26c, 0x05c, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_NF_CE0__GPIO_3_22	IOMUX_PAD(NF_CE0, GPIO_3_22, 0x26c, 0x05c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_ECB__ECB		IOMUX_PAD(ECB, ECB, 0x270, 0x060, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_ECB__UART5_TXD_MUX	IOMUX_PAD(ECB, UART5_TXD_MUX, 0x270, 0x060, 0x13, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_ECB__GPIO_3_23		IOMUX_PAD(ECB, GPIO_3_23, 0x270, 0x060, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LBA__LBA		IOMUX_PAD(LBA, LBA, 0x274, 0x064, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LBA__UART5_RXD_MUX	IOMUX_PAD(LBA, UART5_RXD_MUX, 0x274, 0x064, 0x13, 0x578, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LBA__GPIO_3_24		IOMUX_PAD(LBA, GPIO_3_24, 0x274, 0x064, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_BCLK__BCLK		IOMUX_PAD(BCLK, BCLK, 0x000, 0x068, 0x00, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_BCLK__GPIO_4_4		IOMUX_PAD(BCLK, GPIO_4_4, 0x000, 0x068, 0x05, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_RW__RW			IOMUX_PAD(RW, RW, 0x278, 0x06c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_RW__AUD4_TXFS		IOMUX_PAD(RW, AUD4_TXFS, 0x278, 0x06c, 0x14, 0x474, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_RW__GPIO_3_25		IOMUX_PAD(RW, GPIO_3_25, 0x278, 0x06c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_NFWE_B__NFWE_B		IOMUX_PAD(NFWE_B, NFWE_B, 0x000, 0x070, 0x10, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFWE_B__GPIO_3_26	IOMUX_PAD(NFWE_B, GPIO_3_26, 0x000, 0x070, 0x15, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFRE_B__NFRE_B		IOMUX_PAD(NFRE_B, NFRE_B, 0x000, 0x074, 0x10, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFRE_B__GPIO_3_27	IOMUX_PAD(NFRE_B, GPIO_3_27, 0x000, 0x074, 0x15, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFALE__NFALE		IOMUX_PAD(NFALE, NFALE, 0x000, 0x078, 0x10, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFALE__GPIO_3_28	IOMUX_PAD(NFALE, GPIO_3_28, 0x000, 0x078, 0x15, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFCLE__NFCLE		IOMUX_PAD(NFCLE, NFCLE, 0x000, 0x07c, 0x10, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFCLE__GPIO_3_29	IOMUX_PAD(NFCLE, GPIO_3_29, 0x000, 0x07c, 0x15, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFWP_B__NFWP_B		IOMUX_PAD(NFWP_B, NFWP_B, 0x000, 0x080, 0x10, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFWP_B__GPIO_3_30	IOMUX_PAD(NFWP_B, GPIO_3_30, 0x000, 0x080, 0x15, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_NFRB__NFRB		IOMUX_PAD(NFRB, NFRB, 0x27c, 0x084, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
+#define MX25_PAD_NFRB__GPIO_3_31	IOMUX_PAD(NFRB, GPIO_3_31, 0x27c, 0x084, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D15__D15		IOMUX_PAD(D15, D15, 0x280, 0x088, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D15__LD16		IOMUX_PAD(D15, LD16, 0x280, 0x088, 0x01, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D15__GPIO_4_5		IOMUX_PAD(D15, GPIO_4_5, 0x280, 0x088, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D14__D14		IOMUX_PAD(D14, D14, 0x284, 0x08c, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D14__LD17		IOMUX_PAD(D14, LD17, 0x284, 0x08c, 0x01, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D14__GPIO_4_6		IOMUX_PAD(D14, GPIO_4_6, 0x284, 0x08c, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D13__D13		IOMUX_PAD(D13, D13, 0x288, 0x090, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D13__LD18		IOMUX_PAD(D13, LD18, 0x288, 0x090, 0x01, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D13__GPIO_4_7		IOMUX_PAD(D13, GPIO_4_7, 0x288, 0x090, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D12__D12		IOMUX_PAD(D12, D12, 0x28c, 0x094, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D12__GPIO_4_8		IOMUX_PAD(D12, GPIO_4_8, 0x28c, 0x094, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D11__D11		IOMUX_PAD(D11, D11, 0x290, 0x098, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D11__GPIO_4_9		IOMUX_PAD(D11, GPIO_4_9, 0x290, 0x098, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D10__D10		IOMUX_PAD(D10, D10, 0x294, 0x09c, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D10__GPIO_4_10		IOMUX_PAD(D10, GPIO_4_10, 0x294, 0x09c, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D10__USBOTG_OC		IOMUX_PAD(D10, USBOTG_OC, 0x294, 0x09c, 0x06, 0x57c, 0, PAD_CTL_PULL_UP_100K)
+#define MX25_PAD_D9__D9			IOMUX_PAD(D9, D9, 0x298, 0x0a0, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D9__GPIO_4_11		IOMUX_PAD(D9, GPIO_4_11, 0x298, 0x0a0, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D9__USBH2_PWR		IOMUX_PAD(D9, USBH2_PWR, 0x298, 0x0a0, 0x06, 0, 0, PAD_CTL_PULL_KEEPER)
+#define MX25_PAD_D8__D8			IOMUX_PAD(D8, D8, 0x29c, 0x0a4, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D8__GPIO_4_12		IOMUX_PAD(D8, GPIO_4_12, 0x29c, 0x0a4, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D8__USBH2_OC		IOMUX_PAD(D8, USBH2_OC, 0x29c, 0x0a4, 0x06, 0x580, 0, PAD_CTL_PULL_UP_100K)
+#define MX25_PAD_D7__D7			IOMUX_PAD(D7, D7, 0x2a0, 0x0a8, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D7__GPIO_4_13		IOMUX_PAD(D7, GPIO_4_13, 0x2a0, 0x0a8, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D6__D6			IOMUX_PAD(D6, D6, 0x2a4, 0x0ac, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D6__GPIO_4_14		IOMUX_PAD(D6, GPIO_4_14, 0x2a4, 0x0ac, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D5__D5			IOMUX_PAD(D5, D5, 0x2a8, 0x0b0, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D5__GPIO_4_15		IOMUX_PAD(D5, GPIO_4_15, 0x2a8, 0x0b0, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D4__D4			IOMUX_PAD(D4, D4, 0x2ac, 0x0b4, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D4__GPIO_4_16		IOMUX_PAD(D4, GPIO_4_16, 0x2ac, 0x0b4, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D3__D3			IOMUX_PAD(D3, D3, 0x2b0, 0x0b8, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D3__GPIO_4_17		IOMUX_PAD(D3, GPIO_4_17, 0x2b0, 0x0b8, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D2__D2			IOMUX_PAD(D2, D2, 0x2b4, 0x0bc, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D2__GPIO_4_18		IOMUX_PAD(D2, GPIO_4_18, 0x2b4, 0x0bc, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D1__D1			IOMUX_PAD(D1, D1, 0x2b8, 0x0c0, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D1__GPIO_4_19		IOMUX_PAD(D1, GPIO_4_19, 0x2b8, 0x0c0, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D0__D0			IOMUX_PAD(D0, D0, 0x2bc, 0x0c4, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_D0__GPIO_4_20		IOMUX_PAD(D0, GPIO_4_20, 0x2bc, 0x0c4, 0x05, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD0__LD0		IOMUX_PAD(LD0, LD0, 0x2c0, 0x0c8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD0__CSI_D0		IOMUX_PAD(LD0, CSI_D0, 0x2c0, 0x0c8, 0x12, 0x488, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD0__GPIO_2_15		IOMUX_PAD(LD0, GPIO_2_15, 0x2c0, 0x0c8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD1__LD1		IOMUX_PAD(LD1, LD1, 0x2c4, 0x0cc, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD1__CSI_D1		IOMUX_PAD(LD1, CSI_D1, 0x2c4, 0x0cc, 0x12, 0x48c, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD1__GPIO_2_16		IOMUX_PAD(LD1, GPIO_2_16, 0x2c4, 0x0cc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD2__LD2		IOMUX_PAD(LD2, LD2, 0x2c8, 0x0d0, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD2__GPIO_2_17		IOMUX_PAD(LD2, GPIO_2_17, 0x2c8, 0x0d0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD3__LD3		IOMUX_PAD(LD3, LD3, 0x2cc, 0x0d4, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD3__GPIO_2_18		IOMUX_PAD(LD3, GPIO_2_18, 0x2cc, 0x0d4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD4__LD4		IOMUX_PAD(LD4, LD4, 0x2d0, 0x0d8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD4__GPIO_2_19		IOMUX_PAD(LD4, GPIO_2_19, 0x2d0, 0x0d8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD5__LD5		IOMUX_PAD(LD5, LD5, 0x2d4, 0x0dc, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD5__GPIO_1_19		IOMUX_PAD(LD5, GPIO_1_19, 0x2d4, 0x0dc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD6__LD6		IOMUX_PAD(LD6, LD6, 0x2d8, 0x0e0, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD6__GPIO_1_20		IOMUX_PAD(LD6, GPIO_1_20, 0x2d8, 0x0e0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD7__LD7		IOMUX_PAD(LD7, LD7, 0x2dc, 0x0e4, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD7__GPIO_1_21		IOMUX_PAD(LD7, GPIO_1_21, 0x2dc, 0x0e4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD8__LD8		IOMUX_PAD(LD8, LD8, 0x2e0, 0x0e8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD8__FEC_TX_ERR	IOMUX_PAD(LD8, FEC_TX_ERR, 0x2e0, 0x0e8, 0x15, 0, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_LD9__LD9		IOMUX_PAD(LD9, LD9, 0x2e4, 0x0ec, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD9__FEC_COL		IOMUX_PAD(LD9, FEC_COL, 0x2e4, 0x0ec, 0x15, 0x504, 1, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_LD10__LD10		IOMUX_PAD(LD10, LD10, 0x2e8, 0x0f0, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD10__FEC_RX_ER	IOMUX_PAD(LD10, FEC_RX_ER, 0x2e8, 0x0f0, 0x15, 0x518, 1, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_LD11__LD11		IOMUX_PAD(LD11, LD11, 0x2ec, 0x0f4, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD11__FEC_RDATA2	IOMUX_PAD(LD11, FEC_RDATA2, 0x2ec, 0x0f4, 0x15, 0x50c, 1, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_LD12__LD12		IOMUX_PAD(LD12, LD12, 0x2f0, 0x0f8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD12__FEC_RDATA3	IOMUX_PAD(LD12, FEC_RDATA3, 0x2f0, 0x0f8, 0x15, 0x510, 1, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_LD13__LD13		IOMUX_PAD(LD13, LD13, 0x2f4, 0x0fc, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD13__FEC_TDATA2	IOMUX_PAD(LD13, FEC_TDATA2, 0x2f4, 0x0fc, 0x15, 0, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_LD14__LD14		IOMUX_PAD(LD14, LD14, 0x2f8, 0x100, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD14__FEC_TDATA3	IOMUX_PAD(LD14, FEC_TDATA3, 0x2f8, 0x100, 0x15, 0, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_LD15__LD15		IOMUX_PAD(LD15, LD15, 0x2fc, 0x104, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LD15__FEC_RX_CLK	IOMUX_PAD(LD15, FEC_RX_CLK, 0x2fc, 0x104, 0x15, 0x514, 1, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_HSYNC__HSYNC		IOMUX_PAD(HSYNC, HSYNC, 0x300, 0x108, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_HSYNC__GPIO_1_22	IOMUX_PAD(HSYNC, GPIO_1_22, 0x300, 0x108, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_VSYNC__VSYNC		IOMUX_PAD(VSYNC, VSYNC, 0x304, 0x10c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_VSYNC__GPIO_1_23	IOMUX_PAD(VSYNC, GPIO_1_23, 0x304, 0x10c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LSCLK__LSCLK		IOMUX_PAD(LSCLK, LSCLK, 0x308, 0x110, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_LSCLK__GPIO_1_24	IOMUX_PAD(LSCLK, GPIO_1_24, 0x308, 0x110, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_OE_ACD__OE_ACD		IOMUX_PAD(OE_ACD, OE_ACD, 0x30c, 0x114, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_OE_ACD__GPIO_1_25	IOMUX_PAD(OE_ACD, GPIO_1_25, 0x30c, 0x114, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CONTRAST__CONTRAST	IOMUX_PAD(CONTRAST, CONTRAST, 0x310, 0x118, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CONTRAST__FEC_CRS	IOMUX_PAD(CONTRAST, FEC_CRS, 0x310, 0x118, 0x15, 0x508, 1, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_PWM__PWM		IOMUX_PAD(PWM, PWM, 0x314, 0x11c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_PWM__GPIO_1_26		IOMUX_PAD(PWM, GPIO_1_26, 0x314, 0x11c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_PWM__USBH2_OC		IOMUX_PAD(PWM, USBH2_OC, 0x314, 0x11c, 0x16, 0x580, 1, PAD_CTL_PULL_UP_100K)
+#define MX25_PAD_CSI_D2__CSI_D2		IOMUX_PAD(CSI_D2, CSI_D2, 0x318, 0x120, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D2__UART5_RXD_MUX	IOMUX_PAD(CSI_D2, UART5_RXD_MUX, 0x318, 0x120, 0x11, 0x578, 1, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D2__GPIO_1_27	IOMUX_PAD(CSI_D2, GPIO_1_27, 0x318, 0x120, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D3__CSI_D3		IOMUX_PAD(CSI_D3, CSI_D3, 0x31c, 0x124, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D3__GPIO_1_28	IOMUX_PAD(CSI_D3, GPIO_1_28, 0x31c, 0x124, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D4__CSI_D4		IOMUX_PAD(CSI_D4, CSI_D4, 0x320, 0x128, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D4__UART5_RTS	IOMUX_PAD(CSI_D4, UART5_RTS, 0x320, 0x128, 0x11, 0x574, 1, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D4__GPIO_1_29	IOMUX_PAD(CSI_D4, GPIO_1_29, 0x320, 0x128, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D5__CSI_D5		IOMUX_PAD(CSI_D5, CSI_D5, 0x324, 0x12c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D5__GPIO_1_30	IOMUX_PAD(CSI_D5, GPIO_1_30, 0x324, 0x12c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D6__CSI_D6		IOMUX_PAD(CSI_D6, CSI_D6, 0x328, 0x130, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D6__GPIO_1_31	IOMUX_PAD(CSI_D6, GPIO_1_31, 0x328, 0x130, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D7__CSI_D7		IOMUX_PAD(CSI_D7, CSI_D7, 0x32c, 0x134, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D7__GPIO_1_6	IOMUX_PAD(CSI_D7, GPIO_1_6, 0x32c, 0x134, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D8__CSI_D8		IOMUX_PAD(CSI_D8, CSI_D8, 0x330, 0x138, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D8__GPIO_1_7	IOMUX_PAD(CSI_D8, GPIO_1_7, 0x330, 0x138, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D9__CSI_D9		IOMUX_PAD(CSI_D9, CSI_D9, 0x334, 0x13c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_D9__GPIO_4_21	IOMUX_PAD(CSI_D9, GPIO_4_21, 0x334, 0x13c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_MCLK__CSI_MCLK	IOMUX_PAD(CSI_MCLK, CSI_MCLK, 0x338, 0x140, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_MCLK__GPIO_1_8	IOMUX_PAD(CSI_MCLK, GPIO_1_8, 0x338, 0x140, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_VSYNC__CSI_VSYNC	IOMUX_PAD(CSI_VSYNC, CSI_VSYNC, 0x33c, 0x144, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_VSYNC__GPIO_1_9	IOMUX_PAD(CSI_VSYNC, GPIO_1_9, 0x33c, 0x144, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_HSYNC__CSI_HSYNC	IOMUX_PAD(CSI_HSYNC, CSI_HSYNC, 0x340, 0x148, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_HSYNC__GPIO_1_10	IOMUX_PAD(CSI_HSYNC, GPIO_1_10, 0x340, 0x148, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_PIXCLK__CSI_PIXCLK	IOMUX_PAD(CSI_PIXCLK, CSI_PIXCLK, 0x344, 0x14c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSI_PIXCLK__GPIO_1_11	IOMUX_PAD(CSI_PIXCLK, GPIO_1_11, 0x344, 0x14c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_I2C1_CLK__I2C1_CLK	IOMUX_PAD(I2C1_CLK, I2C1_CLK, 0x348, 0x150, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_I2C1_CLK__GPIO_1_12	IOMUX_PAD(I2C1_CLK, GPIO_1_12, 0x348, 0x150, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_I2C1_DAT__I2C1_DAT	IOMUX_PAD(I2C1_DAT, I2C1_DAT, 0x34c, 0x154, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_I2C1_DAT__GPIO_1_13	IOMUX_PAD(I2C1_DAT, GPIO_1_13, 0x34c, 0x154, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_MOSI__CSPI1_MOSI	IOMUX_PAD(CSPI1_MOSI, CSPI1_MOSI, 0x350, 0x158, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_MOSI__GPIO_1_14	IOMUX_PAD(CSPI1_MOSI, GPIO_1_14, 0x350, 0x158, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_MISO__CSPI1_MISO	IOMUX_PAD(CSPI1_MISO, CSPI1_MISO, 0x354, 0x15c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_MISO__GPIO_1_15	IOMUX_PAD(CSPI1_MISO, GPIO_1_15, 0x354, 0x15c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_SS0__CSPI1_SS0	IOMUX_PAD(CSPI1_SS0, CSPI1_SS0, 0x358, 0x160, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_SS0__GPIO_1_16	IOMUX_PAD(CSPI1_SS0, GPIO_1_16, 0x358, 0x160, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_SS1__CSPI1_SS1	IOMUX_PAD(CSPI1_SS1, CSPI1_SS1, 0x35c, 0x164, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_SS1__GPIO_1_17	IOMUX_PAD(CSPI1_SS1, GPIO_1_17, 0x35c, 0x164, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_SCLK__CSPI1_SCLK	IOMUX_PAD(CSPI1_SCLK, CSPI1_SCLK, 0x360, 0x168, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_SCLK__GPIO_1_18	IOMUX_PAD(CSPI1_SCLK, GPIO_1_18, 0x360, 0x168, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CSPI1_RDY__CSPI1_RDY	IOMUX_PAD(CSPI1_RDY, CSPI1_RDY, 0x364, 0x16c, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
+#define MX25_PAD_CSPI1_RDY__GPIO_2_22	IOMUX_PAD(CSPI1_RDY, GPIO_2_22, 0x364, 0x16c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART1_RXD__UART1_RXD	IOMUX_PAD(UART1_RXD, UART1_RXD, 0x368, 0x170, 0x10, 0, 0, PAD_CTL_PULL_DOWN_100K)
+#define MX25_PAD_UART1_RXD__GPIO_4_22	IOMUX_PAD(UART1_RXD, GPIO_4_22, 0x368, 0x170, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART1_TXD__UART1_TXD	IOMUX_PAD(UART1_TXD, UART1_TXD, 0x36c, 0x174, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART1_TXD__GPIO_4_23	IOMUX_PAD(UART1_TXD, GPIO_4_23, 0x36c, 0x174, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART1_RTS__UART1_RTS	IOMUX_PAD(UART1_RTS, UART1_RTS, 0x370, 0x178, 0x10, 0, 0, PAD_CTL_PULL_UP_100K)
+#define MX25_PAD_UART1_RTS__CSI_D0	IOMUX_PAD(UART1_RTS, CSI_D0, 0x370, 0x178, 0x11, 0x488, 1, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART1_RTS__GPIO_4_24	IOMUX_PAD(UART1_RTS, GPIO_4_24, 0x370, 0x178, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART1_CTS__UART1_CTS	IOMUX_PAD(UART1_CTS, UART1_CTS, 0x374, 0x17c, 0x10, 0, 0, PAD_CTL_PULL_UP_100K)
+#define MX25_PAD_UART1_CTS__CSI_D1	IOMUX_PAD(UART1_CTS, CSI_D1, 0x374, 0x17c, 0x11, 0x48c, 1, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART1_CTS__GPIO_4_25	IOMUX_PAD(UART1_CTS, GPIO_4_25, 0x374, 0x17c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART2_RXD__UART2_RXD	IOMUX_PAD(UART2_RXD, UART2_RXD, 0x378, 0x180, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART2_RXD__GPIO_4_26	IOMUX_PAD(UART2_RXD, GPIO_4_26, 0x378, 0x180, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART2_TXD__UART2_TXD	IOMUX_PAD(UART2_TXD, UART2_TXD, 0x37c, 0x184, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART2_TXD__GPIO_4_27	IOMUX_PAD(UART2_TXD, GPIO_4_27, 0x37c, 0x184, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART2_RTS__UART2_RTS	IOMUX_PAD(UART2_RTS, UART2_RTS, 0x380, 0x188, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART2_RTS__FEC_COL	IOMUX_PAD(UART2_RTS, FEC_COL, 0x380, 0x188, 0x12, 0x504, 2, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_UART2_RTS__GPIO_4_28	IOMUX_PAD(UART2_RTS, GPIO_4_28, 0x380, 0x188, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART2_CTS__FEC_RX_ER	IOMUX_PAD(UART2_CTS, FEC_RX_ER, 0x384, 0x18c, 0x12, 0x518, 2, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_UART2_CTS__UART2_CTS	IOMUX_PAD(UART2_CTS, UART2_CTS, 0x384, 0x18c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_UART2_CTS__GPIO_4_29	IOMUX_PAD(UART2_CTS, GPIO_4_29, 0x384, 0x18c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_SD1_CMD__SD1_CMD	IOMUX_PAD(SD1_CMD, SD1_CMD, 0x388, 0x190, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_CMD__FEC_RDATA2	IOMUX_PAD(SD1_CMD, FEC_RDATA2, 0x388, 0x190, 0x12, 0x50c, 2, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_CMD__GPIO_2_23	IOMUX_PAD(SD1_CMD, GPIO_2_23, 0x388, 0x190, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_SD1_CLK__SD1_CLK	IOMUX_PAD(SD1_CLK, SD1_CLK, 0x38c, 0x194, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_CLK__FEC_RDATA3	IOMUX_PAD(SD1_CLK, FEC_RDATA3, 0x38c, 0x194, 0x12, 0x510, 2, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_CLK__GPIO_2_24	IOMUX_PAD(SD1_CLK, GPIO_2_24, 0x38c, 0x194, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_SD1_DATA0__SD1_DATA0	IOMUX_PAD(SD1_DATA0, SD1_DATA0, 0x390, 0x198, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_DATA0__GPIO_2_25	IOMUX_PAD(SD1_DATA0, GPIO_2_25, 0x390, 0x198, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_SD1_DATA1__SD1_DATA1	IOMUX_PAD(SD1_DATA1, SD1_DATA1, 0x394, 0x19c, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_DATA1__AUD7_RXD	IOMUX_PAD(SD1_DATA1, AUD7_RXD, 0x394, 0x19c, 0x13, 0x478, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_SD1_DATA1__GPIO_2_26	IOMUX_PAD(SD1_DATA1, GPIO_2_26, 0x394, 0x19c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_SD1_DATA2__SD1_DATA2	IOMUX_PAD(SD1_DATA2, SD1_DATA2, 0x398, 0x1a0, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_DATA2__FEC_RX_CLK	IOMUX_PAD(SD1_DATA2, FEC_RX_CLK, 0x398, 0x1a0, 0x15, 0x514, 2, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_DATA2__GPIO_2_27	IOMUX_PAD(SD1_DATA2, GPIO_2_27, 0x398, 0x1a0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_SD1_DATA3__SD1_DATA3	IOMUX_PAD(SD1_DATA3, SD1_DATA3, 0x39c, 0x1a4, 0x10, 0, 0, PAD_CTL_PULL_UP_47K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_DATA3__FEC_CRS	IOMUX_PAD(SD1_DATA3, FEC_CRS, 0x39c, 0x1a4, 0x10, 0x508, 2, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_SD1_DATA3__GPIO_2_28	IOMUX_PAD(SD1_DATA3, GPIO_2_28, 0x39c, 0x1a4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_ROW0__KPP_ROW0	IOMUX_PAD(KPP_ROW0, KPP_ROW0, 0x3a0, 0x1a8, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
+#define MX25_PAD_KPP_ROW0__GPIO_2_29	IOMUX_PAD(KPP_ROW0, GPIO_2_29, 0x3a0, 0x1a8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_ROW1__KPP_ROW1	IOMUX_PAD(KPP_ROW1, KPP_ROW1, 0x3a4, 0x1ac, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
+#define MX25_PAD_KPP_ROW1__GPIO_2_30	IOMUX_PAD(KPP_ROW1, GPIO_2_30, 0x3a4, 0x1ac, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_ROW2__KPP_ROW2	IOMUX_PAD(KPP_ROW2, KPP_ROW2, 0x3a8, 0x1b0, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
+#define MX25_PAD_KPP_ROW2__CSI_D0	IOMUX_PAD(KPP_ROW2, CSI_D0, 0x3a8, 0x1b0, 0x13, 0x488, 2, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_ROW2__GPIO_2_31	IOMUX_PAD(KPP_ROW2, GPIO_2_31, 0x3a8, 0x1b0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_ROW3__KPP_ROW3	IOMUX_PAD(KPP_ROW3, KPP_ROW3, 0x3ac, 0x1b4, 0x10, 0, 0, PAD_CTL_PULL_KEEPER)
+#define MX25_PAD_KPP_ROW3__CSI_LD1	IOMUX_PAD(KPP_ROW3, CSI_LD1, 0x3ac, 0x1b4, 0x13, 0x48c, 2, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_ROW3__GPIO_3_0	IOMUX_PAD(KPP_ROW3, GPIO_3_0, 0x3ac, 0x1b4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_COL0__KPP_COL0	IOMUX_PAD(KPP_COL0, KPP_COL0, 0x3b0, 0x1b8, 0x10, 0, 0, PAD_CTL_PULL_KEEPER | PAD_CTL_OUTPUT_OPEN_DRAIN)
+#define MX25_PAD_KPP_COL0__GPIO_3_1	IOMUX_PAD(KPP_COL0, GPIO_3_1, 0x3b0, 0x1b8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_COL1__KPP_COL1	IOMUX_PAD(KPP_COL1, KPP_COL1, 0x3b4, 0x1bc, 0x10, 0, 0, PAD_CTL_PULL_KEEPER | PAD_CTL_OUTPUT_OPEN_DRAIN)
+#define MX25_PAD_KPP_COL1__GPIO_3_2	IOMUX_PAD(KPP_COL1, GPIO_3_2, 0x3b4, 0x1bc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_COL2__KPP_COL2	IOMUX_PAD(KPP_COL2, KPP_COL2, 0x3b8, 0x1c0, 0x10, 0, 0, PAD_CTL_PULL_KEEPER | PAD_CTL_OUTPUT_OPEN_DRAIN)
+#define MX25_PAD_KPP_COL2__GPIO_3_3	IOMUX_PAD(KPP_COL2, GPIO_3_3, 0x3b8, 0x1c0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_KPP_COL3__KPP_COL3	IOMUX_PAD(KPP_COL3, KPP_COL3, 0x3bc, 0x1c4, 0x10, 0, 0, PAD_CTL_PULL_KEEPER | PAD_CTL_OUTPUT_OPEN_DRAIN)
+#define MX25_PAD_KPP_COL3__GPIO_3_4	IOMUX_PAD(KPP_COL3, GPIO_3_4, 0x3bc, 0x1c4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_MDC__FEC_MDC	IOMUX_PAD(FEC_MDC, FEC_MDC, 0x3c0, 0x1c8, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_MDC__AUD4_TXD	IOMUX_PAD(FEC_MDC, AUD4_TXD, 0x3c0, 0x1c8, 0x12, 0x464, 1, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_MDC__GPIO_3_5	IOMUX_PAD(FEC_MDC, GPIO_3_5, 0x3c0, 0x1c8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_MDIO__FEC_MDIO	IOMUX_PAD(FEC_MDIO, FEC_MDIO, 0x3c4, 0x1cc, 0x10, 0, 0, PAD_CTL_HYSTERESIS | PAD_CTL_PULL_UP_22K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_MDIO__AUD4_RXD	IOMUX_PAD(FEC_MDIO, AUD4_RXD, 0x3c4, 0x1cc, 0x12, 0x460, 1, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_MDIO__GPIO_3_6	IOMUX_PAD(FEC_MDIO, GPIO_3_6, 0x3c4, 0x1cc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_TDATA0__FEC_TDATA0	IOMUX_PAD(FEC_TDATA0, FEC_TDATA0, 0x3c8, 0x1d0, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_TDATA0__GPIO_3_7	IOMUX_PAD(FEC_TDATA0, GPIO_3_7, 0x3c8, 0x1d0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_TDATA1__FEC_TDATA1	IOMUX_PAD(FEC_TDATA1, FEC_TDATA1, 0x3cc, 0x1d4, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_TDATA1__AUD4_TXFS	IOMUX_PAD(FEC_TDATA1, AUD4_TXFS, 0x3cc, 0x1d4, 0x12, 0x474, 1, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_TDATA1__GPIO_3_8	IOMUX_PAD(FEC_TDATA1, GPIO_3_8, 0x3cc, 0x1d4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_TX_EN__FEC_TX_EN	IOMUX_PAD(FEC_TX_EN, FEC_TX_EN, 0x3d0, 0x1d8, 0x10, 0, 0, PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_TX_EN__GPIO_3_9   	IOMUX_PAD(FEC_TX_EN, GPIO_3_9   , 0x3d0, 0x1d8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_RDATA0__FEC_RDATA0	IOMUX_PAD(FEC_RDATA0, FEC_RDATA0, 0x3d4, 0x1dc, 0x10, 0, 0, PAD_CTL_PULL_DOWN_100K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_RDATA0__GPIO_3_10	IOMUX_PAD(FEC_RDATA0, GPIO_3_10, 0x3d4, 0x1dc, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_RDATA1__FEC_RDATA1	IOMUX_PAD(FEC_RDATA1, FEC_RDATA1, 0x3d8, 0x1e0, 0x10, 0, 0, PAD_CTL_PULL_DOWN_100K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_RDATA1__GPIO_3_11	IOMUX_PAD(FEC_RDATA1, GPIO_3_11, 0x3d8, 0x1e0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_RX_DV__FEC_RX_DV	IOMUX_PAD(FEC_RX_DV, FEC_RX_DV, 0x3dc, 0x1e4, 0x10, 0, 0, PAD_CTL_PULL_DOWN_100K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_RX_DV__CAN2_RX	IOMUX_PAD(FEC_RX_DV, CAN2_RX, 0x3dc, 0x1e4, 0x14, 0x484, 0, PAD_CTL_PULL_UP_22K)
+#define MX25_PAD_FEC_RX_DV__GPIO_3_12	IOMUX_PAD(FEC_RX_DV, GPIO_3_12, 0x3dc, 0x1e4, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_FEC_TX_CLK__FEC_TX_CLK	IOMUX_PAD(FEC_TX_CLK, FEC_TX_CLK, 0x3e0, 0x1e8, 0x10, 0, 0, PAD_CTL_HYSTERESIS | PAD_CTL_PULL_DOWN_100K | PAD_CTL_SLEW_RATE_FAST)
+#define MX25_PAD_FEC_TX_CLK__GPIO_3_13	IOMUX_PAD(FEC_TX_CLK, GPIO_3_13, 0x3e0, 0x1e8, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_RTCK__RTCK		IOMUX_PAD(RTCK, RTCK, 0x3e4, 0x1ec, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_RTCK__OWIRE		IOMUX_PAD(RTCK, OWIRE, 0x3e4, 0x1ec, 0x11, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_RTCK__GPIO_3_14	IOMUX_PAD(RTCK, GPIO_3_14, 0x3e4, 0x1ec, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_DE_B__DE_B		IOMUX_PAD(DE_B, DE_B, 0x3ec, 0x1f0, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_DE_B__GPIO_2_20	IOMUX_PAD(DE_B, GPIO_2_20, 0x3ec, 0x1f0, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_TDO__TDO		IOMUX_PAD(TDO, TDO, 0x3e8, 0x000, 0x00, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_GPIO_A__GPIO_A		IOMUX_PAD(GPIO_A, GPIO_A, 0x3f0, 0x1f4, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_GPIO_A__CAN1_TX	IOMUX_PAD(GPIO_A, CAN1_TX, 0x3f0, 0x1f4, 0x16, 0, 0, PAD_CTL_PULL_UP_22K | PAD_CTL_OUTPUT_OPEN_DRAIN | PAD_CTL_DRIVE_STRENGTH_MAX)
+#define MX25_PAD_GPIO_A__USBOTG_PWR	IOMUX_PAD(GPIO_A, USBOTG_PWR, 0x3f0, 0x1f4, 0x12, 0, 0, PAD_CTL_PULL_KEEPER)
+#define MX25_PAD_GPIO_B__GPIO_B		IOMUX_PAD(GPIO_B, GPIO_B, 0x3f4, 0x1f8, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_GPIO_B__CAN1_RX	IOMUX_PAD(GPIO_B, CAN1_RX, 0x3f4, 0x1f8, 0x16, 0x480, 1, PAD_CTL_PULL_UP_22K | PAD_CTL_OUTPUT_OPEN_DRAIN)
+#define MX25_PAD_GPIO_B__USBOTG_OC	IOMUX_PAD(GPIO_B, USBOTG_OC, 0x3f4, 0x1f8, 0x12, 0x57c, 1, PAD_CTL_PULL_UP_100K)
+#define MX25_PAD_GPIO_C__GPIO_C		IOMUX_PAD(GPIO_C, GPIO_C, 0x3f8, 0x1fc, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_GPIO_C__CAN2_TX	IOMUX_PAD(GPIO_C, CAN2_TX, 0x3f8, 0x1fc, 0x16, 0, 0, PAD_CTL_PULL_UP_22K | PAD_CTL_OUTPUT_OPEN_DRAIN | PAD_CTL_DRIVE_STRENGTH_MAX)
+#define MX25_PAD_GPIO_D__GPIO_D		IOMUX_PAD(GPIO_D, GPIO_D, 0x3fc, 0x200, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_GPIO_D__CAN2_RX	IOMUX_PAD(GPIO_D, CAN2_RX, 0x3fc, 0x200, 0x16, 0x484, 1, PAD_CTL_PULL_UP_22K)
+#define MX25_PAD_GPIO_E__GPIO_E		IOMUX_PAD(GPIO_E, GPIO_E, 0x400, 0x204, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_GPIO_E__AUD7_TXD	IOMUX_PAD(GPIO_E, AUD7_TXD, 0x400, 0x204, 0x14, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_GPIO_F__GPIO_F		IOMUX_PAD(GPIO_F, GPIO_F, 0x404, 0x208, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_GPIO_F__AUD7_TXC	IOMUX_PAD(GPIO_F, AUD7_TXC, 0x404, 0x208, 0x14, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_EXT_ARMCLK__EXT_ARMCLK	IOMUX_PAD(EXT_ARMCLK, EXT_ARMCLK, 0x000, 0x20c, 0x10, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_EXT_ARMCLK__GPIO_3_15	IOMUX_PAD(EXT_ARMCLK, GPIO_3_15, 0x000, 0x20c, 0x15, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_UPLL_BYPCLK__UPLL_BYPCLK IOMUX_PAD(UPLL_BYPCLK, UPLL_BYPCLK, 0x000, 0x210, 0x10, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_UPLL_BYPCLK__GPIO_3_16	IOMUX_PAD(UPLL_BYPCLK, GPIO_3_16, 0x000, 0x210, 0x15, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_VSTBY_REQ__VSTBY_REQ	IOMUX_PAD(VSTBY_REQ, VSTBY_REQ, 0x408, 0x214, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_VSTBY_REQ__AUD7_TXFS	IOMUX_PAD(VSTBY_REQ, AUD7_TXFS, 0x408, 0x214, 0x14, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_VSTBY_REQ__GPIO_3_17	IOMUX_PAD(VSTBY_REQ, GPIO_3_17, 0x408, 0x214, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_VSTBY_ACK__VSTBY_ACK	IOMUX_PAD(VSTBY_ACK, VSTBY_ACK, 0x40c, 0x218, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_VSTBY_ACK__GPIO_3_18	IOMUX_PAD(VSTBY_ACK, GPIO_3_18, 0x40c, 0x218, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_POWER_FAIL__POWER_FAIL	IOMUX_PAD(POWER_FAIL, POWER_FAIL, 0x410, 0x21c, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_POWER_FAIL__AUD7_RXD	IOMUX_PAD(POWER_FAIL, AUD7_RXD, 0x410, 0x21c, 0x14, 0x478, 1, 0 | NO_PAD_CTRL)
+#define MX25_PAD_POWER_FAIL__GPIO_3_19	IOMUX_PAD(POWER_FAIL, GPIO_3_19, 0x410, 0x21c, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CLKO__CLKO		IOMUX_PAD(CLKO, CLKO, 0x414, 0x220, 0x10, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_CLKO__GPIO_2_21	IOMUX_PAD(CLKO, GPIO_2_21, 0x414, 0x220, 0x15, 0, 0, 0 | NO_PAD_CTRL)
+#define MX25_PAD_BOOT_MODE0__BOOT_MODE0	IOMUX_PAD(BOOT_MODE0, BOOT_MODE0, 0x000, 0x224, 0x00, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_BOOT_MODE0__GPIO_4_30	IOMUX_PAD(BOOT_MODE0, GPIO_4_30, 0x000, 0x224, 0x05, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_BOOT_MODE1__BOOT_MODE1	IOMUX_PAD(BOOT_MODE1, BOOT_MODE1, 0x000, 0x228, 0x00, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_BOOT_MODE1__GPIO_4_31	IOMUX_PAD(BOOT_MODE1, GPIO_4_31, 0x000, 0x228, 0x05, 0, 0, NO_PAD_CTRL)
 
-#define MX25_PAD_CTL_GRP_DVS_MISC		IOMUX_PAD(0x418, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_FEC		IOMUX_PAD(0x41c, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DVS_JTAG		IOMUX_PAD(0x420, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_NFC		IOMUX_PAD(0x424, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_CSI		IOMUX_PAD(0x428, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_WEIM		IOMUX_PAD(0x42c, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_DDR		IOMUX_PAD(0x430, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DVS_CRM		IOMUX_PAD(0x434, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_KPP		IOMUX_PAD(0x438, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_SDHC1		IOMUX_PAD(0x43c, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_LCD		IOMUX_PAD(0x440, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_UART		IOMUX_PAD(0x444, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DVS_NFC		IOMUX_PAD(0x448, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DVS_CSI		IOMUX_PAD(0x44c, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DSE_CSPI1		IOMUX_PAD(0x450, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DDRTYPE		IOMUX_PAD(0x454, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DVS_SDHC1		IOMUX_PAD(0x458, 0x000, 0, 0, 0, NO_PAD_CTRL)
-#define MX25_PAD_CTL_GRP_DVS_LCD		IOMUX_PAD(0x45c, 0x000, 0, 0, 0, NO_PAD_CTRL)
-
-#if 0
-enum {
-	GPIO_A,
-	GPIO_B,
-	GPIO_C,
-	GPIO_D,
-	GPIO_E,
-	GPIO_F,
-	GPIO_1_6,
-	GPIO_1_7,
-	GPIO_1_8,
-	GPIO_1_9,
-	GPIO_1_10,
-	GPIO_1_11,
-	GPIO_1_12,
-	GPIO_1_13,
-	GPIO_1_14,
-	GPIO_1_15,
-	GPIO_1_16,
-	GPIO_1_17,
-	GPIO_1_18,
-	GPIO_1_19,
-	GPIO_1_20,
-	GPIO_1_21,
-	GPIO_1_22,
-	GPIO_1_23,
-	GPIO_1_24,
-	GPIO_1_25,
-	GPIO_1_26,
-	GPIO_1_27,
-	GPIO_1_28,
-	GPIO_1_29,
-	GPIO_1_30,
-	GPIO_1_31,
-	GPIO_2_0,
-	GPIO_2_1,
-	GPIO_2_2,
-	GPIO_2_3,
-	GPIO_2_4,
-	GPIO_2_5,
-	GPIO_2_6,
-	GPIO_2_7,
-	GPIO_2_8,
-	GPIO_2_9,
-	GPIO_2_10,
-	GPIO_2_11,
-	GPIO_2_12,
-	GPIO_2_13,
-	GPIO_2_14,
-	GPIO_2_15,
-	GPIO_2_16,
-	GPIO_2_17,
-	GPIO_2_18,
-	GPIO_2_19,
-	GPIO_2_20,
-	GPIO_2_21,
-	GPIO_2_22,
-	GPIO_2_23,
-	GPIO_2_24,
-	GPIO_2_25,
-	GPIO_2_26,
-	GPIO_2_27,
-	GPIO_2_28,
-	GPIO_2_29,
-	GPIO_2_30,
-	GPIO_2_31,
-	GPIO_3_0,
-	GPIO_3_1,
-	GPIO_3_2,
-	GPIO_3_3,
-	GPIO_3_4,
-	GPIO_3_5,
-	GPIO_3_6,
-	GPIO_3_7,
-	GPIO_3_8,
-	GPIO_3_9,
-	GPIO_3_10,
-	GPIO_3_11,
-	GPIO_3_12,
-	GPIO_3_13,
-	GPIO_3_14,
-	GPIO_3_15,
-	GPIO_3_16,
-	GPIO_3_17,
-	GPIO_3_18,
-	GPIO_3_19,
-	GPIO_3_20,
-	GPIO_3_21,
-	GPIO_3_22,
-	GPIO_3_23,
-	GPIO_3_24,
-	GPIO_3_25,
-	GPIO_3_26,
-	GPIO_3_27,
-	GPIO_3_28,
-	GPIO_3_29,
-	GPIO_3_30,
-	GPIO_3_31,
-	GPIO_4_0,
-	GPIO_4_1,
-	GPIO_4_2,
-	GPIO_4_3,
-	GPIO_4_4,
-	GPIO_4_5,
-	GPIO_4_6,
-	GPIO_4_7,
-	GPIO_4_8,
-	GPIO_4_9,
-	GPIO_4_10,
-	GPIO_4_11,
-	GPIO_4_12,
-	GPIO_4_13,
-	GPIO_4_14,
-	GPIO_4_15,
-	GPIO_4_16,
-	GPIO_4_17,
-	GPIO_4_18,
-	GPIO_4_19,
-	GPIO_4_20,
-	GPIO_4_21,
-	GPIO_4_22,
-	GPIO_4_23,
-	GPIO_4_24,
-	GPIO_4_25,
-	GPIO_4_26,
-	GPIO_4_27,
-	GPIO_4_28,
-	GPIO_4_29,
-	GPIO_4_30,
-	GPIO_4_31,
-};
+#define MX25_PAD_CTL_GRP_DVS_MISC	IOMUX_PAD(0x418, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_FEC	IOMUX_PAD(0x41c, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DVS_JTAG	IOMUX_PAD(0x420, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_NFC	IOMUX_PAD(0x424, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_CSI	IOMUX_PAD(0x428, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_WEIM	IOMUX_PAD(0x42c, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_DDR	IOMUX_PAD(0x430, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DVS_CRM	IOMUX_PAD(0x434, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_KPP	IOMUX_PAD(0x438, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_SDHC1	IOMUX_PAD(0x43c, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_LCD	IOMUX_PAD(0x440, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_UART	IOMUX_PAD(0x444, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DVS_NFC	IOMUX_PAD(0x448, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DVS_CSI	IOMUX_PAD(0x44c, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DSE_CSPI1	IOMUX_PAD(0x450, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DDRTYPE	IOMUX_PAD(0x454, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DVS_SDHC1	IOMUX_PAD(0x458, 0x000, 0, 0, 0, NO_PAD_CTRL)
+#define MX25_PAD_CTL_GRP_DVS_LCD	IOMUX_PAD(0x45c, 0x000, 0, 0, 0, NO_PAD_CTRL)
 
 #define IOMUX_TO_GPIO(__pad_desc) ({		\
 	int __gpio = -1;			\
@@ -510,396 +380,395 @@ enum {
 						\
 	switch (__pd->mux_ctrl_ofs) {		\
 	case MX25_PAD_GPIO_A__GPIO_A:		\
-		__gpio = GPIO_A;		\
-		break;				\
+	__gpio = GPIO_A;			\
+	break;					\
 	case MX25_PAD_GPIO_B__GPIO_B:		\
-		__gpio = GPIO_B;		\
-		break;				\
+	__gpio = GPIO_B;			\
+	break;					\
 	case MX25_PAD_GPIO_C__GPIO_C:		\
-		__gpio = GPIO_C;		\
-		break;				\
+	__gpio = GPIO_C;			\
+	break;					\
 	case MX25_PAD_GPIO_D__GPIO_D:		\
-		__gpio = GPIO_D;		\
-		break;				\
+	__gpio = GPIO_D;			\
+	break;					\
 	case MX25_PAD_GPIO_E__GPIO_E:		\
-		__gpio = GPIO_E;		\
-		break;				\
+	__gpio = GPIO_E;			\
+	break;					\
 	case MX25_PAD_GPIO_F__GPIO_F:		\
-		__gpio = GPIO_F;		\
-		break;				\
+	__gpio = GPIO_F;			\
+	break;					\
 	case MX25_PAD_CSI_D7__GPIO_1_6:		\
-		__gpio = GPIO_1_6;		\
-		break;				\
+	__gpio = GPIO_1_6;			\
+	break;					\
 	case MX25_PAD_CSI_D8__GPIO_1_7:		\
-		__gpio = GPIO_1_7;		\
-		break;				\
+	__gpio = GPIO_1_7;			\
+	break;					\
 	case MX25_PAD_CSI_MCLK__GPIO_1_8:	\
-		__gpio = GPIO_1_8;		\
-		break;				\
+	__gpio = GPIO_1_8;			\
+	break;					\
 	case MX25_PAD_CSI_VSYNC__GPIO_1_9:	\
-		__gpio = GPIO_1_9;		\
-		break;				\
+	__gpio = GPIO_1_9;			\
+	break;					\
 	case MX25_PAD_CSI_HSYNC__GPIO_1_10:	\
-		__gpio = GPIO_1_10;		\
-		break;				\
+	__gpio = GPIO_1_10;			\
+	break;					\
 	case MX25_PAD_CSI_PIXCLK__GPIO_1_11:	\
-		__gpio = GPIO_1_11;		\
-		break;				\
+	__gpio = GPIO_1_11;			\
+	break;					\
 	case MX25_PAD_I2C1_CLK__GPIO_1_12:	\
-		__gpio = GPIO_1_12;		\
-		break;				\
+	__gpio = GPIO_1_12;			\
+	break;					\
 	case MX25_PAD_I2C1_DAT__GPIO_1_13:	\
-		__gpio = GPIO_1_13;		\
-		break;				\
+	__gpio = GPIO_1_13;			\
+	break;					\
 	case MX25_PAD_CSPI1_MOSI__GPIO_1_14:	\
-		__gpio = GPIO_1_14;		\
-		break;				\
+	__gpio = GPIO_1_14;			\
+	break;					\
 	case MX25_PAD_CSPI1_MISO__GPIO_1_15:	\
-		__gpio = GPIO_1_15;		\
-		break;				\
+	__gpio = GPIO_1_15;			\
+	break;					\
 	case MX25_PAD_CSPI1_SS0__GPIO_1_16:	\
-		__gpio = GPIO_1_16;		\
-		break;				\
+	__gpio = GPIO_1_16;			\
+	break;					\
 	case MX25_PAD_CSPI1_SS1__GPIO_1_17:	\
-		__gpio = GPIO_1_17;		\
-		break;				\
+	__gpio = GPIO_1_17;			\
+	break;					\
 	case MX25_PAD_CSPI1_SCLK__GPIO_1_18:	\
-		__gpio = GPIO_1_18;		\
-		break;				\
+	__gpio = GPIO_1_18;			\
+	break;					\
 	case MX25_PAD_LD5__GPIO_1_19:		\
-		__gpio = GPIO_1_19;		\
-		break;				\
+	__gpio = GPIO_1_19;			\
+	break;					\
 	case MX25_PAD_LD6__GPIO_1_20:		\
-		__gpio = GPIO_1_20;		\
-		break;				\
+	__gpio = GPIO_1_20;			\
+	break;					\
 	case MX25_PAD_LD7__GPIO_1_21:		\
-		__gpio = GPIO_1_21;		\
-		break;				\
+	__gpio = GPIO_1_21;			\
+	break;					\
 	case MX25_PAD_HSYNC__GPIO_1_22:		\
-		__gpio = GPIO_1_22;		\
-		break;				\
+	__gpio = GPIO_1_22;			\
+	break;					\
 	case MX25_PAD_VSYNC__GPIO_1_23:		\
-		__gpio = GPIO_1_23;		\
-		break;				\
+	__gpio = GPIO_1_23;			\
+	break;					\
 	case MX25_PAD_LSCLK__GPIO_1_24:		\
-		__gpio = GPIO_1_24;		\
-		break;				\
+	__gpio = GPIO_1_24;			\
+	break;					\
 	case MX25_PAD_OE_ACD__GPIO_1_25:	\
-		__gpio = GPIO_1_25;		\
-		break;				\
+	__gpio = GPIO_1_25;			\
+	break;					\
 	case MX25_PAD_PWM__GPIO_1_26:		\
-		__gpio = GPIO_1_26;		\
-		break;				\
+	__gpio = GPIO_1_26;			\
+	break;					\
 	case MX25_PAD_CSI_D2__GPIO_1_27:	\
-		__gpio = GPIO_1_27;		\
-		break;				\
+	__gpio = GPIO_1_27;			\
+	break;					\
 	case MX25_PAD_CSI_D3__GPIO_1_28:	\
-		__gpio = GPIO_1_28;		\
-		break;				\
+	__gpio = GPIO_1_28;			\
+	break;					\
 	case MX25_PAD_CSI_D4__GPIO_1_29:	\
-		__gpio = GPIO_1_29;		\
-		break;				\
+	__gpio = GPIO_1_29;			\
+	break;					\
 	case MX25_PAD_CSI_D5__GPIO_1_30:	\
-		__gpio = GPIO_1_30;		\
-		break;				\
+	__gpio = GPIO_1_30;			\
+	break;					\
 	case MX25_PAD_CSI_D6__GPIO_1_31:	\
-		__gpio = GPIO_1_31;		\
-		break;				\
+	__gpio = GPIO_1_31;			\
+	break;					\
 						\
 	case MX25_PAD_A14__GPIO_2_0:		\
-		__gpio = GPIO_2_0;		\
-		break;				\
+	__gpio = GPIO_2_0;			\
+	break;					\
 	case MX25_PAD_A15__GPIO_2_1:		\
-		__gpio = GPIO_2_1;		\
-		break;				\
+	__gpio = GPIO_2_1;			\
+	break;					\
 	case MX25_PAD_A16__GPIO_2_2:		\
-		__gpio = GPIO_2_2;		\
-		break;				\
+	__gpio = GPIO_2_2;			\
+	break;					\
 	case MX25_PAD_A17__GPIO_2_3:		\
-		__gpio = GPIO_2_3;		\
-		break;				\
+	__gpio = GPIO_2_3;			\
+	break;					\
 	case MX25_PAD_A18__GPIO_2_4:		\
-		__gpio = GPIO_2_4;		\
-		break;				\
+	__gpio = GPIO_2_4;			\
+	break;					\
 	case MX25_PAD_A19__GPIO_2_5:		\
-		__gpio = GPIO_2_5;		\
-		break;				\
+	__gpio = GPIO_2_5;			\
+	break;					\
 	case MX25_PAD_A20__GPIO_2_6:		\
-		__gpio = GPIO_2_6;		\
-		break;				\
+	__gpio = GPIO_2_6;			\
+	break;					\
 	case MX25_PAD_A21__GPIO_2_7:		\
-		__gpio = GPIO_2_7;		\
-		break;				\
+	__gpio = GPIO_2_7;			\
+	break;					\
 	case MX25_PAD_A22__GPIO_2_8:		\
-		__gpio = GPIO_2_8;		\
-		break;				\
+	__gpio = GPIO_2_8;			\
+	break;					\
 	case MX25_PAD_A23__GPIO_2_9:		\
-		__gpio = GPIO_2_9;		\
-		break;				\
+	__gpio = GPIO_2_9;			\
+	break;					\
 	case MX25_PAD_A24__GPIO_2_10:		\
-		__gpio = GPIO_2_10;		\
-		break;				\
+	__gpio = GPIO_2_10;			\
+	break;					\
 	case MX25_PAD_A25__GPIO_2_11:		\
-		__gpio = GPIO_2_11;		\
-		break;				\
+	__gpio = GPIO_2_11;			\
+	break;					\
 	case MX25_PAD_EB0__GPIO_2_12:		\
-		__gpio = GPIO_2_12;		\
-		break;				\
+	__gpio = GPIO_2_12;			\
+	break;					\
 	case MX25_PAD_EB1__GPIO_2_13:		\
-		__gpio = GPIO_2_13;		\
-		break;				\
+	__gpio = GPIO_2_13;			\
+	break;					\
 	case MX25_PAD_OE__GPIO_2_14:		\
-		__gpio = GPIO_2_14;		\
-		break;				\
+	__gpio = GPIO_2_14;			\
+	break;					\
 	case MX25_PAD_LD0__GPIO_2_15:		\
-		__gpio = GPIO_2_15;		\
-		break;				\
+	__gpio = GPIO_2_15;			\
+	break;					\
 	case MX25_PAD_LD1__GPIO_2_16:		\
-		__gpio = GPIO_2_16;		\
-		break;				\
+	__gpio = GPIO_2_16;			\
+	break;					\
 	case MX25_PAD_LD2__GPIO_2_17:		\
-		__gpio = GPIO_2_17;		\
-		break;				\
+	__gpio = GPIO_2_17;			\
+	break;					\
 	case MX25_PAD_LD3__GPIO_2_18:		\
-		__gpio = GPIO_2_18;		\
-		break;				\
+	__gpio = GPIO_2_18;			\
+	break;					\
 	case MX25_PAD_LD4__GPIO_2_19:		\
-		__gpio = GPIO_2_19;		\
-		break;				\
+	__gpio = GPIO_2_19;			\
+	break;					\
 	case MX25_PAD_DE_B__GPIO_2_20:		\
-		__gpio = GPIO_2_20;		\
-		break;				\
+	__gpio = GPIO_2_20;			\
+	break;					\
 	case MX25_PAD_CLKO__GPIO_2_21:		\
-		__gpio = GPIO_2_21;		\
-		break;				\
+	__gpio = GPIO_2_21;			\
+	break;					\
 	case MX25_PAD_CSPI1_RDY__GPIO_2_22:	\
-		__gpio = GPIO_2_22;		\
-		break;				\
+	__gpio = GPIO_2_22;			\
+	break;					\
 	case MX25_PAD_SD1_CMD__GPIO_2_23:	\
-		__gpio = GPIO_2_23;		\
-		break;				\
+	__gpio = GPIO_2_23;			\
+	break;					\
 	case MX25_PAD_SD1_CLK__GPIO_2_24:	\
-		__gpio = GPIO_2_24;		\
-		break;				\
+	__gpio = GPIO_2_24;			\
+	break;					\
 	case MX25_PAD_SD1_DATA0__GPIO_2_25:	\
-		__gpio = GPIO_2_25;		\
-		break;				\
+	__gpio = GPIO_2_25;			\
+	break;					\
 	case MX25_PAD_SD1_DATA1__GPIO_2_26:	\
-		__gpio = GPIO_2_26;		\
-		break;				\
+	__gpio = GPIO_2_26;			\
+	break;					\
 	case MX25_PAD_SD1_DATA2__GPIO_2_27:	\
-		__gpio = GPIO_2_27;		\
-		break;				\
+	__gpio = GPIO_2_27;			\
+	break;					\
 	case MX25_PAD_SD1_DATA3__GPIO_2_28:	\
-		__gpio = GPIO_2_28;		\
-		break;				\
+	__gpio = GPIO_2_28;			\
+	break;					\
 	case MX25_PAD_KPP_ROW0__GPIO_2_29:	\
-		__gpio = GPIO_2_29;		\
-		break;				\
+	__gpio = GPIO_2_29;			\
+	break;					\
 	case MX25_PAD_KPP_ROW1__GPIO_2_30:	\
-		__gpio = GPIO_2_30;		\
-		break;				\
+	__gpio = GPIO_2_30;			\
+	break;					\
 	case MX25_PAD_KPP_ROW2__GPIO_2_31:	\
-		__gpio = GPIO_2_31;		\
-		break;				\
+	__gpio = GPIO_2_31;			\
+	break;					\
 						\
 	case MX25_PAD_KPP_ROW3__GPIO_3_0:	\
-		__gpio = GPIO_3_0;		\
-		break;				\
+	__gpio = GPIO_3_0;			\
+	break;					\
 	case MX25_PAD_KPP_COL0__GPIO_3_1:	\
-		__gpio = GPIO_3_1;		\
-		break;				\
+	__gpio = GPIO_3_1;			\
+	break;					\
 	case MX25_PAD_KPP_COL1__GPIO_3_2:	\
-		__gpio = GPIO_3_2;		\
-		break;				\
+	__gpio = GPIO_3_2;			\
+	break;					\
 	case MX25_PAD_KPP_COL2__GPIO_3_3:	\
-		__gpio = GPIO_3_3;		\
-		break;				\
+	__gpio = GPIO_3_3;			\
+	break;					\
 	case MX25_PAD_KPP_COL3__GPIO_3_4:	\
-		__gpio = GPIO_3_4;		\
-		break;				\
+	__gpio = GPIO_3_4;			\
+	break;					\
 	case MX25_PAD_FEC_MDC__GPIO_3_5:	\
-		__gpio = GPIO_3_5;		\
-		break;				\
+	__gpio = GPIO_3_5;			\
+	break;					\
 	case MX25_PAD_FEC_MDIO__GPIO_3_6:	\
-		__gpio = GPIO_3_6;		\
-		break;				\
+	__gpio = GPIO_3_6;			\
+	break;					\
 	case MX25_PAD_FEC_TDATA0__GPIO_3_7:	\
-		__gpio = GPIO_3_7;		\
-		break;				\
+	__gpio = GPIO_3_7;			\
+	break;					\
 	case MX25_PAD_FEC_TDATA1__GPIO_3_8:	\
-		__gpio = GPIO_3_8;		\
-		break;				\
+	__gpio = GPIO_3_8;			\
+	break;					\
 	case MX25_PAD_FEC_TX_EN__GPIO_3_9:	\
-		__gpio = GPIO_3_9;		\
-		break;				\
+	__gpio = GPIO_3_9;			\
+	break;					\
 	case MX25_PAD_FEC_RDATA0__GPIO_3_10:	\
-		__gpio = GPIO_3_10;		\
-		break;				\
+	__gpio = GPIO_3_10;			\
+	break;					\
 	case MX25_PAD_FEC_RDATA1__GPIO_3_11:	\
-		__gpio = GPIO_3_11;		\
-		break;				\
+	__gpio = GPIO_3_11;			\
+	break;					\
 	case MX25_PAD_FEC_RX_DV__GPIO_3_12:	\
-		__gpio = GPIO_3_12;		\
-		break;				\
+	__gpio = GPIO_3_12;			\
+	break;					\
 	case MX25_PAD_FEC_TX_CLK__GPIO_3_13:	\
-		__gpio = GPIO_3_13;		\
-		break;				\
+	__gpio = GPIO_3_13;			\
+	break;					\
 	case MX25_PAD_RTCK__GPIO_3_14:		\
-		__gpio = GPIO_3_14;		\
-		break;				\
+	__gpio = GPIO_3_14;			\
+	break;					\
 	case MX25_PAD_EXT_ARMCLK__GPIO_3_15:	\
-		__gpio = GPIO_3_15;		\
-		break;				\
+	__gpio = GPIO_3_15;			\
+	break;					\
 	case MX25_PAD_UPLL_BYPCLK__GPIO_3_16:	\
-		__gpio = GPIO_3_16;		\
-		break;				\
+	__gpio = GPIO_3_16;			\
+	break;					\
 	case MX25_PAD_VSTBY_REQ__GPIO_3_17:	\
-		__gpio = GPIO_3_17;		\
-		break;				\
+	__gpio = GPIO_3_17;			\
+	break;					\
 	case MX25_PAD_VSTBY_ACK__GPIO_3_18:	\
-		__gpio = GPIO_3_18;		\
-		break;				\
+	__gpio = GPIO_3_18;			\
+	break;					\
 	case MX25_PAD_POWER_FAIL__GPIO_3_19:	\
-		__gpio = GPIO_3_19;		\
-		break;				\
+	__gpio = GPIO_3_19;			\
+	break;					\
 	case MX25_PAD_CS4__GPIO_3_20:		\
-		__gpio = GPIO_3_20;		\
-		break;				\
+	__gpio = GPIO_3_20;			\
+	break;					\
 	case MX25_PAD_CS5__GPIO_3_21:		\
-		__gpio = GPIO_3_21;		\
-		break;				\
+	__gpio = GPIO_3_21;			\
+	break;					\
 	case MX25_PAD_NF_CE0__GPIO_3_22:	\
-		__gpio = GPIO_3_22;		\
-		break;				\
+	__gpio = GPIO_3_22;			\
+	break;					\
 	case MX25_PAD_ECB__GPIO_3_23:		\
-		__gpio = GPIO_3_23;		\
-		break;				\
+	__gpio = GPIO_3_23;			\
+	break;					\
 	case MX25_PAD_LBA__GPIO_3_24:		\
-		__gpio = GPIO_3_24;		\
-		break;				\
+	__gpio = GPIO_3_24;			\
+	break;					\
 	case MX25_PAD_RW__GPIO_3_25:		\
-		__gpio = GPIO_3_25;		\
-		break;				\
+	__gpio = GPIO_3_25;			\
+	break;					\
 	case MX25_PAD_NFWE_B__GPIO_3_26:	\
-		__gpio = GPIO_3_26;		\
-		break;				\
+	__gpio = GPIO_3_26;			\
+	break;					\
 	case MX25_PAD_NFRE_B__GPIO_3_27:	\
-		__gpio = GPIO_3_27;		\
-		break;				\
+	__gpio = GPIO_3_27;			\
+	break;					\
 	case MX25_PAD_NFALE__GPIO_3_28:		\
-		__gpio = GPIO_3_28;		\
-		break;				\
+	__gpio = GPIO_3_28;			\
+	break;					\
 	case MX25_PAD_NFCLE__GPIO_3_29:		\
-		__gpio = GPIO_3_29;		\
-		break;				\
+	__gpio = GPIO_3_29;			\
+	break;					\
 	case MX25_PAD_NFWP_B__GPIO_3_30:	\
-		__gpio = GPIO_3_30;		\
-		break;				\
+	__gpio = GPIO_3_30;			\
+	break;					\
 	case MX25_PAD_NFRB__GPIO_3_31:		\
-		__gpio = GPIO_3_31;		\
-		break;				\
+	__gpio = GPIO_3_31;			\
+	break;					\
 						\
 	case MX25_PAD_A10__GPIO_4_0:		\
-		__gpio = GPIO_4_0;		\
-		break;				\
+	__gpio = GPIO_4_0;			\
+	break;					\
 	case MX25_PAD_A13__GPIO_4_1:		\
-		__gpio = GPIO_4_1;		\
-		break;				\
+	__gpio = GPIO_4_1;			\
+	break;					\
 	case MX25_PAD_CS0__GPIO_4_2:		\
-		__gpio = GPIO_4_2;		\
-		break;				\
+	__gpio = GPIO_4_2;			\
+	break;					\
 	case MX25_PAD_CS1__GPIO_4_3:		\
-		__gpio = GPIO_4_3;		\
-		break;				\
+	__gpio = GPIO_4_3;			\
+	break;					\
 	case MX25_PAD_BCLK__GPIO_4_4:		\
-		__gpio = GPIO_4_4;		\
-		break;				\
+	__gpio = GPIO_4_4;			\
+	break;					\
 	case MX25_PAD_D15__GPIO_4_5:		\
-		__gpio = GPIO_4_5;		\
-		break;				\
+	__gpio = GPIO_4_5;			\
+	break;					\
 	case MX25_PAD_D14__GPIO_4_6:		\
-		__gpio = GPIO_4_6;		\
-		break;				\
+	__gpio = GPIO_4_6;			\
+	break;					\
 	case MX25_PAD_D13__GPIO_4_7:		\
-		__gpio = GPIO_4_7;		\
-		break;				\
+	__gpio = GPIO_4_7;			\
+	break;					\
 	case MX25_PAD_D12__GPIO_4_8:		\
-		__gpio = GPIO_4_8;		\
-		break;				\
+	__gpio = GPIO_4_8;			\
+	break;					\
 	case MX25_PAD_D11__GPIO_4_9:		\
-		__gpio = GPIO_4_9;		\
-		break;				\
+	__gpio = GPIO_4_9;			\
+	break;					\
 	case MX25_PAD_D10__GPIO_4_10:		\
-		__gpio = GPIO_4_10;		\
-		break;				\
+	__gpio = GPIO_4_10;			\
+	break;					\
 	case MX25_PAD_D9__GPIO_4_11:		\
-		__gpio = GPIO_4_11;		\
-		break;				\
+	__gpio = GPIO_4_11;			\
+	break;					\
 	case MX25_PAD_D8__GPIO_4_12:		\
-		__gpio = GPIO_4_12;		\
-		break;				\
+	__gpio = GPIO_4_12;			\
+	break;					\
 	case MX25_PAD_D7__GPIO_4_13:		\
-		__gpio = GPIO_4_13;		\
-		break;				\
+	__gpio = GPIO_4_13;			\
+	break;					\
 	case MX25_PAD_D6__GPIO_4_14:		\
-		__gpio = GPIO_4_14;		\
-		break;				\
+	__gpio = GPIO_4_14;			\
+	break;					\
 	case MX25_PAD_D5__GPIO_4_15:		\
-		__gpio = GPIO_4_15;		\
-		break;				\
+	__gpio = GPIO_4_15;			\
+	break;					\
 	case MX25_PAD_D4__GPIO_4_16:		\
-		__gpio = GPIO_4_16;		\
-		break;				\
+	__gpio = GPIO_4_16;			\
+	break;					\
 	case MX25_PAD_D3__GPIO_4_17:		\
-		__gpio = GPIO_4_17;		\
-		break;				\
+	__gpio = GPIO_4_17;			\
+	break;					\
 	case MX25_PAD_D2__GPIO_4_18:		\
-		__gpio = GPIO_4_18;		\
-		break;				\
+	__gpio = GPIO_4_18;			\
+	break;					\
 	case MX25_PAD_D1__GPIO_4_19:		\
-		__gpio = GPIO_4_19;		\
-		break;				\
+	__gpio = GPIO_4_19;			\
+	break;					\
 	case MX25_PAD_D0__GPIO_4_20:		\
-		__gpio = GPIO_4_20;		\
-		break;				\
+	__gpio = GPIO_4_20;			\
+	break;					\
 	case MX25_PAD_CSI_D9__GPIO_4_21:	\
-		__gpio = GPIO_4_21;		\
-		break;				\
+	__gpio = GPIO_4_21;			\
+	break;					\
 	case MX25_PAD_UART1_RXD__GPIO_4_22:	\
-		__gpio = GPIO_4_22;		\
-		break;				\
+	__gpio = GPIO_4_22;			\
+	break;					\
 	case MX25_PAD_UART1_TXD__GPIO_4_23:	\
-		__gpio = GPIO_4_23;		\
-		break;				\
+	__gpio = GPIO_4_23;			\
+	break;					\
 	case MX25_PAD_UART1_RTS__GPIO_4_24:	\
-		__gpio = GPIO_4_24;		\
-		break;				\
+	__gpio = GPIO_4_24;			\
+	break;					\
 	case MX25_PAD_UART1_CTS__GPIO_4_25:	\
-		__gpio = GPIO_4_25;		\
-		break;				\
+	__gpio = GPIO_4_25;			\
+	break;					\
 	case MX25_PAD_UART2_RXD__GPIO_4_26:	\
-		__gpio = GPIO_4_26;		\
-		break;				\
+	__gpio = GPIO_4_26;			\
+	break;					\
 	case MX25_PAD_UART2_TXD__GPIO_4_27:	\
-		__gpio = GPIO_4_27;		\
-		break;				\
+	__gpio = GPIO_4_27;			\
+	break;					\
 	case MX25_PAD_UART2_RTS__GPIO_4_28:	\
-		__gpio = GPIO_4_28;		\
-		break;				\
+	__gpio = GPIO_4_28;			\
+	break;					\
 	case MX25_PAD_UART2_CTS__GPIO_4_29:	\
-		__gpio = GPIO_4_29;		\
-		break;				\
+	__gpio = GPIO_4_29;			\
+	break;					\
 	case MX25_PAD_BOOT_MODE0__GPIO_4_30:	\
-		__gpio = GPIO_4_30;		\
-		break;				\
+	__gpio = GPIO_4_30;			\
+	break;					\
 	case MX25_PAD_BOOT_MODE1__GPIO_4_31:	\
-		__gpio = GPIO_4_31;		\
-		break;				\
+	__gpio = GPIO_4_31;			\
+	break;					\
 	}					\
 	__gpio;					\
 })
-#endif
 
 #endif // __ASSEMBLY__
 #endif // __IOMUX_MX25_H__
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/iomux-v3.h linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/iomux-v3.h
--- linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/iomux-v3.h	2009-06-02 18:02:08.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/iomux-v3.h	2009-06-25 15:27:32.000000000 +0200
@@ -52,18 +52,37 @@ struct pad_desc {
 	unsigned pad_ctrl:17;
 	unsigned select_input_ofs:12; /* IOMUXC_SELECT_INPUT offset */
 	unsigned select_input:3;
+#ifdef IOMUX_DEBUG
+	char *name;
+#endif
 };
 
-#define IOMUX_PAD(_pad, _func, _pad_ctrl_ofs, _mux_ctrl_ofs, _mux_mode, _select_input_ofs, \
-		_select_input, _pad_ctrl)				\
-		{							\
-			.mux_ctrl_ofs     = _mux_ctrl_ofs,		\
-			.mux_mode         = _mux_mode,			\
-			.pad_ctrl_ofs     = _pad_ctrl_ofs,		\
-			.pad_ctrl         = _pad_ctrl,			\
-			.select_input_ofs = _select_input_ofs,		\
-			.select_input     = _select_input,		\
+#ifdef IOMUX_DEBUG
+#define MXC_PAD_NAME(pd)	(pd)->name
+#define IOMUX_PAD(_pad, _func, _pad_ctrl_ofs, _mux_ctrl_ofs, _mux_mode, _select_input_ofs,	\
+		_select_input, _pad_ctrl)							\
+		{										\
+			.mux_ctrl_ofs     = _mux_ctrl_ofs,					\
+			.mux_mode         = _mux_mode,						\
+			.pad_ctrl_ofs     = _pad_ctrl_ofs,					\
+			.pad_ctrl         = _pad_ctrl,						\
+			.select_input_ofs = _select_input_ofs,					\
+			.select_input     = _select_input,					\
+			.name		  = #_pad"__"#_func,					\
 		}
+#else
+#define MXC_PAD_NAME(pd)	""
+#define IOMUX_PAD(_pad, _func, _pad_ctrl_ofs, _mux_ctrl_ofs, _mux_mode, _select_input_ofs,	\
+		_select_input, _pad_ctrl)							\
+		{										\
+			.mux_ctrl_ofs     = _mux_ctrl_ofs,					\
+			.mux_mode         = _mux_mode,						\
+			.pad_ctrl_ofs     = _pad_ctrl_ofs,					\
+			.pad_ctrl         = _pad_ctrl,						\
+			.select_input_ofs = _select_input_ofs,					\
+			.select_input     = _select_input,					\
+		}
+#endif
 
 /*
  * Use to set PAD control
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/mx25.h linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/mx25.h
--- linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/mx25.h	2009-06-02 18:02:13.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/mx25.h	2009-07-01 11:21:51.000000000 +0200
@@ -79,7 +79,7 @@
 #define I2C_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00080000)
 #define I2C3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00084000)
 #define CAN1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00088000)
-#define CAN3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0008C000)
+#define CAN2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0008C000)
 #define UART1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00090000)
 #define UART2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00094000)
 #define I2C2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00098000)
@@ -199,7 +199,8 @@
 #define RTIC_BASE_ADDR			(AIPS2_BASE_ADDR + 0x000EC000)
 #define IIM_BASE_ADDR			(AIPS2_BASE_ADDR + 0x000F0000)
 #define USBOTG_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F4000)
-#define OTG_BASE_ADDR			USBOTG_BASE_ADDR
+#define OTG_BASE_ADDR			(USBOTG_BASE_ADDR + 0x000)
+#define USBH2_BASE_ADDR			(USBOTG_BASE_ADDR + 0x400)
 #define CSI_BASE_ADDR			(AIPS2_BASE_ADDR + 0x000F8000)
 #define DRYICE_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000FC000)
 
@@ -406,7 +407,7 @@
 #define MXC_INT_UART2			32
 #define MXC_INT_NANDFC			33
 #define MXC_INT_SDMA			34
-#define MXC_INT_USB_HTG			35
+#define MXC_INT_USB_H2			35
 #define MXC_INT_PWM2			36
 #define MXC_INT_USB_OTG			37
 #define MXC_INT_SLCDC			38
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/mxc_can.h linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/mxc_can.h
--- linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/mxc_can.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/mxc_can.h	2009-07-01 11:31:19.000000000 +0200
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2009  Lothar Wassmann <LW@KARO-electronics.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the:
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ */
+
+#include <linux/platform_device.h>
+
+struct flexcan_platform_data {
+	char *core_reg;
+	char *io_reg;
+	int (*xcvr_enable)(struct platform_device *pdev, int en);
+	int (*active)(struct platform_device *pdev);
+	void (*inactive)(struct platform_device *pdev);
+};
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/mxc_ehci.h linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/mxc_ehci.h
--- linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/mxc_ehci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/mxc_ehci.h	2009-07-01 11:31:34.000000000 +0200
@@ -0,0 +1,9 @@
+#ifndef __INCLUDE_ASM_ARCH_MXC_EHCI_H
+#define __INCLUDE_ASM_ARCH_MXC_EHCI_H
+
+struct mxc_usbh_platform_data {
+	int (*init)(struct platform_device *pdev);
+	int (*exit)(struct platform_device *pdev);
+};
+#endif /* __INCLUDE_ASM_ARCH_MXC_EHCI_H */
+
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/timex.h linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/timex.h
--- linux-2.6.30-rc4-karo/arch/arm/plat-mxc/include/mach/timex.h	2009-06-02 18:02:12.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/include/mach/timex.h	2009-07-06 15:41:30.000000000 +0200
@@ -26,7 +26,7 @@
 #ifndef CONFIG_MACH_MX25
 #define CLOCK_TICK_RATE		13300000
 #else
-#define CLOCK_TICK_RATE		12000000
+#define CLOCK_TICK_RATE		66500000
 #endif
 #elif defined CONFIG_ARCH_MX3
 #define CLOCK_TICK_RATE		16625000
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/plat-mxc/system.c linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/system.c
--- linux-2.6.30-rc4-karo/arch/arm/plat-mxc/system.c	2009-06-08 11:16:01.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/system.c	2009-06-29 10:49:32.000000000 +0200
@@ -39,16 +39,11 @@
 #define WDOG_WCR_ENABLE		(1 << 2)
 #endif
 
-static struct clk *mxc_wdt_clk;
-
 /*
  * Reset the system. It is called by machine_restart().
  */
 void arch_reset(char mode, const char *cmd)
 {
-	if (mxc_wdt_clk)
-		clk_enable(mxc_wdt_clk);
-
 	/* Assert SRS signal */
 	__raw_writew(WDOG_WCR_ENABLE, WDOG_WCR_REG);
 
@@ -66,17 +61,19 @@ void arch_reset(char mode, const char *c
 
 static int mxc_wdt_init(void)
 {
+	struct clk *wdt_clk;
+
 	if (cpu_is_mx1())
 		return 0;
 
-	mxc_wdt_clk = clk_get_sys("imx-wdt.0", NULL);
-	if (IS_ERR(mxc_wdt_clk)) {
-		int ret = PTR_ERR(mxc_wdt_clk);
-
-		printk(KERN_ERR "%s: Failed to get imx-wdt.0 clk: %d\n", __FUNCTION__, ret);
-		mxc_wdt_clk = NULL;
-		return ret;
+	wdt_clk = clk_get_sys("imx-wdt.0", NULL);
+	if (IS_ERR(wdt_clk)) {
+		printk(KERN_ERR "%s: Failed to get imx-wdt.0 clk: %ld\n",
+		       __FUNCTION__, PTR_ERR(wdt_clk));
+		return PTR_ERR(wdt_clk);
 	}
+	clk_enable(wdt_clk);
+	clk_put(wdt_clk);
 	return 0;
 }
 arch_initcall(mxc_wdt_init);
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/arch/arm/plat-mxc/time.c linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/time.c
--- linux-2.6.30-rc4-karo/arch/arm/plat-mxc/time.c	2009-06-02 18:02:02.000000000 +0200
+++ linux-2.6.30-rc4-karo2/arch/arm/plat-mxc/time.c	2009-07-06 15:41:29.000000000 +0200
@@ -287,7 +287,6 @@ void __init mxc_timer_init(struct clk *t
 	int irq;
 
 	clk_enable(timer_clk);
-printk(KERN_DEBUG "%s: \n", __FUNCTION__);
 
 	if (cpu_is_mx1()) {
 #ifdef CONFIG_ARCH_MX1
@@ -307,7 +306,6 @@ printk(KERN_DEBUG "%s: \n", __FUNCTION__
 	} else
 		BUG();
 
-printk(KERN_DEBUG "%s: timer_base=%p IRQ=%d\n", __FUNCTION__, timer_base, irq);
 	/*
 	 * Initialise to a known state (all timers off, and timing reset)
 	 */
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/input/touchscreen/mxc_tsadcc.c linux-2.6.30-rc4-karo2/drivers/input/touchscreen/mxc_tsadcc.c
--- linux-2.6.30-rc4-karo/drivers/input/touchscreen/mxc_tsadcc.c	2009-07-06 17:32:59.000000000 +0200
+++ linux-2.6.30-rc4-karo2/drivers/input/touchscreen/mxc_tsadcc.c	2009-07-01 11:27:20.000000000 +0200
@@ -529,7 +529,7 @@ static irqreturn_t mxc_tsadcc_interrupt(
 			reg |= CQMR_EOQ_IRQ_MSK;
 			mxc_tsadcc_write(ts_dev, GCQMR, reg);
 		}
-	}		
+	}
 	return IRQ_HANDLED;
 }
 
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/net/can/Kconfig linux-2.6.30-rc4-karo2/drivers/net/can/Kconfig
--- linux-2.6.30-rc4-karo/drivers/net/can/Kconfig	2008-05-29 10:48:57.000000000 +0200
+++ linux-2.6.30-rc4-karo2/drivers/net/can/Kconfig	2009-07-01 11:28:55.000000000 +0200
@@ -22,4 +22,21 @@ config CAN_DEBUG_DEVICES
 	  a problem with CAN support and want to see more of what is going
 	  on.
 
+config CAN_FLEXCAN
+        tristate "Freescale FlexCAN"
+        depends on CAN && (MACH_MX25 || ARCH_MX35)
+        default m
+        ---help---
+          This select the support of Freescale CAN(FlexCAN).
+          This driver can also be built as a module.
+          If unsure, say N.
+
+config CAN_FLEXCAN_CAN1
+	bool "Enable CAN1 interface on i.MX25/i.MX35"
+	depends on CAN_FLEXCAN && (MACH_MX25 && !ARCH_MXC_EHCI_USBOTG)
+
+config CAN_FLEXCAN_CAN2
+	bool "Enable CAN2 interface on i.MX25/i.MX35"
+	depends on CAN_FLEXCAN
+
 endmenu
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/net/can/Makefile linux-2.6.30-rc4-karo2/drivers/net/can/Makefile
--- linux-2.6.30-rc4-karo/drivers/net/can/Makefile	2008-05-29 10:48:57.000000000 +0200
+++ linux-2.6.30-rc4-karo2/drivers/net/can/Makefile	2009-07-01 11:29:31.000000000 +0200
@@ -1,5 +1,9 @@
 #
 #  Makefile for the Linux Controller Area Network drivers.
 #
+ifneq ($(CONFIG_CAN_DEBUG_DEVICES),)
+	EXTRA_CFLAGS += -DDEBUG
+endif
 
 obj-$(CONFIG_CAN_VCAN)		+= vcan.o
+obj-$(CONFIG_CAN_FLEXCAN)	+= flexcan.o
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/net/can/flexcan.c linux-2.6.30-rc4-karo2/drivers/net/can/flexcan.c
--- linux-2.6.30-rc4-karo/drivers/net/can/flexcan.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30-rc4-karo2/drivers/net/can/flexcan.c	2009-07-06 15:46:51.000000000 +0200
@@ -0,0 +1,1784 @@
+/*
+ * drivers/net/can/flexcan.c
+ *
+ * Copyright (C) 2009  Lothar Wassmann <LW@KARO-electronics.de>
+ *
+ * based on: drivers/net/can/flexcan/
+ *   Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the:
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ */
+
+/*
+ * Driver for Freescale CAN Controller FlexCAN.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <mach/mxc_can.h>
+
+#include "flexcan.h"
+
+#ifdef DEBUG
+static int debug = 0;
+#define dbg_lvl(n)	((n) < debug)
+module_param(debug, int, S_IRUGO | S_IWUSR);
+
+#define DBG(lvl, fmt...)	do { if (dbg_lvl(lvl)) printk(KERN_DEBUG fmt); } while (0)
+#else
+static int debug;
+#define dbg_lvl(n)	0
+module_param(debug, int, 0);
+
+#define DBG(lvl, fmt...)	do { } while (0)
+#endif
+
+#define ndev_dbg(d, l, fmt...)		do { if (dbg_lvl(l)) dev_dbg(&(d)->dev, fmt); } while (0)
+#define pdev_dbg(p, l, fmt...)		do { if (dbg_lvl(l)) dev_dbg(&(p)->dev, fmt); } while (0)
+#define flexcan_dbg(f, l, fmt...)	do { if (dbg_lvl(l)) dev_dbg(&(f)->dev->dev, fmt); } while (0)
+
+#define ndev_err(d, fmt...)	dev_err(&(d)->dev, fmt)
+#define pdev_err(p, fmt...)	dev_err(&(p)->dev, fmt)
+
+enum {
+	FLEXCAN_ATTR_STATE = 0,
+	FLEXCAN_ATTR_BITRATE,
+	FLEXCAN_ATTR_BR_PRESDIV,
+	FLEXCAN_ATTR_BR_RJW,
+	FLEXCAN_ATTR_BR_PROPSEG,
+	FLEXCAN_ATTR_BR_PSEG1,
+	FLEXCAN_ATTR_BR_PSEG2,
+	FLEXCAN_ATTR_BR_CLKSRC,
+	FLEXCAN_ATTR_MAXMB,
+	FLEXCAN_ATTR_XMIT_MAXMB,
+	FLEXCAN_ATTR_FIFO,
+	FLEXCAN_ATTR_WAKEUP,
+	FLEXCAN_ATTR_SRX_DIS,
+	FLEXCAN_ATTR_WAK_SRC,
+	FLEXCAN_ATTR_BCC,
+	FLEXCAN_ATTR_LOCAL_PRIORITY,
+	FLEXCAN_ATTR_ABORT,
+	FLEXCAN_ATTR_LOOPBACK,
+	FLEXCAN_ATTR_SMP,
+	FLEXCAN_ATTR_BOFF_REC,
+	FLEXCAN_ATTR_TSYN,
+	FLEXCAN_ATTR_LISTEN,
+	FLEXCAN_ATTR_EXTEND_MSG,
+	FLEXCAN_ATTR_STANDARD_MSG,
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+	FLEXCAN_ATTR_DUMP_REG,
+	FLEXCAN_ATTR_DUMP_XMIT_MB,
+	FLEXCAN_ATTR_DUMP_RX_MB,
+#endif
+	FLEXCAN_ATTR_MAX
+};
+
+#ifdef DEBUG
+#define flexcan_reg_read(f,r)	_flexcan_reg_read(f, r, #r, __FUNCTION__)
+static inline unsigned long _flexcan_reg_read(struct flexcan_device *flexcan, int reg,
+					      const char *name, const char *fn)
+{
+	unsigned long val;
+	val = __raw_readl(flexcan->io_base + reg);
+	DBG(2, "%s: Read %08lx from %s[%p]\n", fn, val, name,
+	    flexcan->io_base + reg);
+	return val;
+}
+
+#define flexcan_reg_write(f,r,v)	_flexcan_reg_write(f, r, v, #r, __FUNCTION__)
+static inline void _flexcan_reg_write(struct flexcan_device *flexcan, int reg, unsigned long val,
+				      const char *name, const char *fn)
+{
+	DBG(2, "%s: Writing %08lx to %s[%p]\n", fn, val, name, flexcan->io_base + reg);
+	__raw_writel(val, flexcan->io_base + reg);
+}
+#else
+static inline unsigned long flexcan_reg_read(struct flexcan_device *flexcan, int reg)
+{
+	return __raw_readl(flexcan->io_base + reg);
+}
+
+static inline void flexcan_reg_write(struct flexcan_device *flexcan, int reg, unsigned long val)
+{
+	__raw_writel(val, flexcan->io_base + reg);
+}
+#endif
+
+static ssize_t flexcan_show_attr(struct device *dev,
+				 struct device_attribute *attr, char *buf);
+static ssize_t flexcan_set_attr(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count);
+
+static struct device_attribute flexcan_dev_attr[FLEXCAN_ATTR_MAX] = {
+	[FLEXCAN_ATTR_STATE] = __ATTR(state, 0444, flexcan_show_attr, NULL),
+	[FLEXCAN_ATTR_BITRATE] =
+	    __ATTR(bitrate, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_PRESDIV] =
+	    __ATTR(br_presdiv, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_RJW] =
+	    __ATTR(br_rjw, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_PROPSEG] =
+	    __ATTR(br_propseg, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_PSEG1] =
+	    __ATTR(br_pseg1, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_PSEG2] =
+	    __ATTR(br_pseg2, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_CLKSRC] =
+	    __ATTR(br_clksrc, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_MAXMB] =
+	    __ATTR(maxmb, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_XMIT_MAXMB] =
+	    __ATTR(xmit_maxmb, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_FIFO] =
+	    __ATTR(fifo, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_WAKEUP] =
+	    __ATTR(wakeup, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_SRX_DIS] =
+	    __ATTR(srx_dis, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_WAK_SRC] =
+	    __ATTR(wak_src, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BCC] =
+	    __ATTR(bcc, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_LOCAL_PRIORITY] =
+	    __ATTR(local_priority, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_ABORT] =
+	    __ATTR(abort, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_LOOPBACK] =
+	    __ATTR(loopback, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_SMP] =
+	    __ATTR(smp, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BOFF_REC] =
+	    __ATTR(boff_rec, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_TSYN] =
+	    __ATTR(tsyn, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_LISTEN] =
+	    __ATTR(listen, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_EXTEND_MSG] =
+	    __ATTR(ext_msg, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_STANDARD_MSG] =
+	    __ATTR(std_msg, 0644, flexcan_show_attr, flexcan_set_attr),
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+	[FLEXCAN_ATTR_DUMP_REG] =
+	    __ATTR(dump_reg, 0444, flexcan_show_attr, NULL),
+	[FLEXCAN_ATTR_DUMP_XMIT_MB] =
+	    __ATTR(dump_xmit_mb, 0444, flexcan_show_attr, NULL),
+	[FLEXCAN_ATTR_DUMP_RX_MB] =
+	    __ATTR(dump_rx_mb, 0444, flexcan_show_attr, NULL),
+#endif
+};
+
+static void flexcan_set_bitrate(struct flexcan_device *flexcan, int bitrate)
+{
+	/* TODO:: implement in future
+	 * based on the bitrate to get the timing of
+	 * presdiv, pseg1, pseg2, propseg
+	 */
+}
+
+static void flexcan_update_bitrate(struct flexcan_device *flexcan)
+{
+	int rate, div;
+
+	if (flexcan->br_clksrc)
+		rate = clk_get_rate(flexcan->clk);
+	else {
+		struct clk *clk;
+		clk = clk_get_sys(NULL, "ckih");
+		if (IS_ERR(clk))
+			return;
+		rate = clk_get_rate(clk);
+		clk_put(clk);
+	}
+	if (!rate)
+		return;
+
+	flexcan_dbg(flexcan, 0, "%s: master clock rate %u from %s\n",
+		    __FUNCTION__, rate, flexcan->br_clksrc ? "osc" : "pll");
+
+	div = flexcan->br_presdiv + 1;
+	div *= flexcan->br_propseg + flexcan->br_pseg1 + flexcan->br_pseg2 + 4;
+	flexcan->bitrate = (rate + div - 1) / div;
+
+	flexcan_dbg(flexcan, 0, "%s: flexcan bitrate %u time quantum %uns\n",
+		    __FUNCTION__, flexcan->bitrate,
+		    1000000000 / (flexcan->bitrate *
+				  (flexcan->br_propseg + flexcan->br_pseg1 +
+				   flexcan->br_pseg2 + 4)));
+}
+
+static inline void flexcan_read_hw_mb(struct flexcan_device *flexcan, struct can_hw_mb *mb,
+				      int buf_no)
+{
+	__raw_readsl(mb, flexcan->hwmb + buf_no * sizeof(*mb), sizeof(*mb));
+}
+
+static inline void flexcan_write_hw_mb(struct flexcan_device *flexcan, struct can_hw_mb *mb,
+				       int buf_no)
+{
+	__raw_writesl(flexcan->hwmb + buf_no * sizeof(*mb), mb, sizeof(*mb));
+}
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+static int flexcan_dump_reg(struct flexcan_device *flexcan, char *buf)
+{
+	int ret = 0;
+	unsigned int reg;
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	ret += sprintf(buf + ret, "MCR::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_CTRL);
+	ret += sprintf(buf + ret, "CTRL::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_RXGMASK);
+	ret += sprintf(buf + ret, "RXGMASK::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_RX14MASK);
+	ret += sprintf(buf + ret, "RX14MASK::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_RX15MASK);
+	ret += sprintf(buf + ret, "RX15MASK::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_ECR);
+	ret += sprintf(buf + ret, "ECR::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_ESR);
+	ret += sprintf(buf + ret, "ESR::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_IMASK2);
+	ret += sprintf(buf + ret, "IMASK2::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_IMASK1);
+	ret += sprintf(buf + ret, "IMASK1::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_IFLAG2);
+	ret += sprintf(buf + ret, "IFLAG2::0x%08x\n", reg);
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_IFLAG1);
+	ret += sprintf(buf + ret, "IFLAG1::0x%08x\n", reg);
+	return ret;
+}
+
+static int flexcan_dump_xmit_mb(struct flexcan_device *flexcan, char *buf)
+{
+	int ret = 0, i;
+
+	clk_enable(flexcan->clk);
+	for (i = flexcan->xmit_maxmb + 1; i <= flexcan->maxmb; i++) {
+		int j;
+
+		ret += sprintf(buf + ret,
+			       "mb[%d]::CS:0x%08x ID:0x%08x DATA",
+			       i, flexcan->hwmb[i].mb_cs.data,
+			       flexcan->hwmb[i].mb_id);
+		for (j = 0; j < sizeof(flexcan->hwmb[i].mb_data); j++) {
+			ret += sprintf(buf + ret, ":%02x",
+				       flexcan->hwmb[i].mb_data[j]);
+		}
+		ret += sprintf(buf + ret, "\n");
+	}
+	clk_disable(flexcan->clk);
+	return ret;
+}
+
+static int flexcan_dump_rx_mb(struct flexcan_device *flexcan, char *buf)
+{
+	int ret = 0, i;
+
+	clk_enable(flexcan->clk);
+	for (i = 0; i <= flexcan->xmit_maxmb; i++) {
+		int j;
+
+		ret += sprintf(buf + ret,
+			       "mb[%d]::CS:0x%08x ID:0x%08x DATA",
+			       i, flexcan->hwmb[i].mb_cs.data,
+			       flexcan->hwmb[i].mb_id);
+		for (j = 0; j < sizeof(flexcan->hwmb[i].mb_data); j++) {
+			ret += sprintf(buf + ret, ":%02x",
+				       flexcan->hwmb[i].mb_data[j]);
+		}
+		ret += sprintf(buf + ret, "\n");
+	}
+	clk_disable(flexcan->clk);
+	return ret;
+}
+#endif
+
+static ssize_t flexcan_show_state(struct net_device *net, char *buf)
+{
+	int ret, esr;
+	struct flexcan_device *flexcan = netdev_priv(net);
+
+	ret = sprintf(buf, "%s::", netif_running(net) ? "Start" : "Stop");
+	if (netif_carrier_ok(net)) {
+		esr = flexcan_reg_read(flexcan, CAN_HW_REG_ESR);
+		switch ((esr & __ESR_FLT_CONF_MASK) >> __ESR_FLT_CONF_OFF) {
+		case 0:
+			ret += sprintf(buf + ret, "normal\n");
+			break;
+		case 1:
+			ret += sprintf(buf + ret, "error passive\n");
+			break;
+		default:
+			ret += sprintf(buf + ret, "bus off\n");
+		}
+	} else
+		ret += sprintf(buf + ret, "bus off\n");
+	return ret;
+}
+
+static ssize_t flexcan_show_attr(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int attr_id;
+	struct net_device *net = dev_get_drvdata(dev);
+	struct flexcan_device *flexcan = netdev_priv(net);
+
+	attr_id = attr - flexcan_dev_attr;
+	switch (attr_id) {
+	case FLEXCAN_ATTR_STATE:
+		return flexcan_show_state(net, buf);
+	case FLEXCAN_ATTR_BITRATE:
+		return sprintf(buf, "%d\n", flexcan->bitrate);
+	case FLEXCAN_ATTR_BR_PRESDIV:
+		return sprintf(buf, "%d\n", flexcan->br_presdiv + 1);
+	case FLEXCAN_ATTR_BR_RJW:
+		return sprintf(buf, "%d\n", flexcan->br_rjw);
+	case FLEXCAN_ATTR_BR_PROPSEG:
+		return sprintf(buf, "%d\n", flexcan->br_propseg + 1);
+	case FLEXCAN_ATTR_BR_PSEG1:
+		return sprintf(buf, "%d\n", flexcan->br_pseg1 + 1);
+	case FLEXCAN_ATTR_BR_PSEG2:
+		return sprintf(buf, "%d\n", flexcan->br_pseg2 + 1);
+	case FLEXCAN_ATTR_BR_CLKSRC:
+		return sprintf(buf, "%s\n", flexcan->br_clksrc ? "bus" : "osc");
+	case FLEXCAN_ATTR_MAXMB:
+		return sprintf(buf, "%d\n", flexcan->maxmb + 1);
+	case FLEXCAN_ATTR_XMIT_MAXMB:
+		return sprintf(buf, "%d\n", flexcan->xmit_maxmb + 1);
+	case FLEXCAN_ATTR_FIFO:
+		return sprintf(buf, "%d\n", flexcan->fifo);
+	case FLEXCAN_ATTR_WAKEUP:
+		return sprintf(buf, "%d\n", flexcan->wakeup);
+	case FLEXCAN_ATTR_SRX_DIS:
+		return sprintf(buf, "%d\n", flexcan->srx_dis);
+	case FLEXCAN_ATTR_WAK_SRC:
+		return sprintf(buf, "%d\n", flexcan->wak_src);
+	case FLEXCAN_ATTR_BCC:
+		return sprintf(buf, "%d\n", flexcan->bcc);
+	case FLEXCAN_ATTR_LOCAL_PRIORITY:
+		return sprintf(buf, "%d\n", flexcan->lprio);
+	case FLEXCAN_ATTR_ABORT:
+		return sprintf(buf, "%d\n", flexcan->abort);
+	case FLEXCAN_ATTR_LOOPBACK:
+		return sprintf(buf, "%d\n", flexcan->loopback);
+	case FLEXCAN_ATTR_SMP:
+		return sprintf(buf, "%d\n", flexcan->smp);
+	case FLEXCAN_ATTR_BOFF_REC:
+		return sprintf(buf, "%d\n", flexcan->boff_rec);
+	case FLEXCAN_ATTR_TSYN:
+		return sprintf(buf, "%d\n", flexcan->tsyn);
+	case FLEXCAN_ATTR_LISTEN:
+		return sprintf(buf, "%d\n", flexcan->listen);
+	case FLEXCAN_ATTR_EXTEND_MSG:
+		return sprintf(buf, "%d\n", flexcan->ext_msg);
+	case FLEXCAN_ATTR_STANDARD_MSG:
+		return sprintf(buf, "%d\n", flexcan->std_msg);
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+	case FLEXCAN_ATTR_DUMP_REG:
+		return flexcan_dump_reg(flexcan, buf);
+	case FLEXCAN_ATTR_DUMP_XMIT_MB:
+		return flexcan_dump_xmit_mb(flexcan, buf);
+	case FLEXCAN_ATTR_DUMP_RX_MB:
+		return flexcan_dump_rx_mb(flexcan, buf);
+#endif
+	default:
+		return sprintf(buf, "%s:%p->%p\n", __func__, flexcan_dev_attr,
+			       attr);
+	}
+}
+
+static ssize_t flexcan_set_attr(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int attr_id, tmp;
+	struct net_device *net = dev_get_drvdata(dev);
+	struct flexcan_device *flexcan = netdev_priv(net);
+
+	attr_id = attr - flexcan_dev_attr;
+
+	mutex_lock(&flexcan->mutex);
+
+	if (netif_running(net))
+		goto set_finish;
+
+	if (attr_id == FLEXCAN_ATTR_BR_CLKSRC) {
+		if (!strcasecmp(buf, "bus"))
+			flexcan->br_clksrc = 1;
+		else if (!strcasecmp(buf, "osc"))
+			flexcan->br_clksrc = 0;
+		goto set_finish;
+	}
+
+	tmp = simple_strtoul(buf, NULL, 0);
+	switch (attr_id) {
+	case FLEXCAN_ATTR_BITRATE:
+		flexcan_set_bitrate(flexcan, tmp);
+		break;
+	case FLEXCAN_ATTR_BR_PRESDIV:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_PRESDIV)) {
+			flexcan->br_presdiv = tmp - 1;
+			flexcan_update_bitrate(flexcan);
+		}
+		break;
+	case FLEXCAN_ATTR_BR_RJW:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_RJW))
+			flexcan->br_rjw = tmp - 1;
+		break;
+	case FLEXCAN_ATTR_BR_PROPSEG:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_PROPSEG)) {
+			flexcan->br_propseg = tmp - 1;
+			flexcan_update_bitrate(flexcan);
+		}
+		break;
+	case FLEXCAN_ATTR_BR_PSEG1:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_PSEG1)) {
+			flexcan->br_pseg1 = tmp - 1;
+			flexcan_update_bitrate(flexcan);
+		}
+		break;
+	case FLEXCAN_ATTR_BR_PSEG2:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_PSEG2)) {
+			flexcan->br_pseg2 = tmp - 1;
+			flexcan_update_bitrate(flexcan);
+		}
+		break;
+	case FLEXCAN_ATTR_MAXMB:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_MB)) {
+			if (flexcan->maxmb != (tmp - 1)) {
+				flexcan->maxmb = tmp - 1;
+				if (flexcan->xmit_maxmb < flexcan->maxmb)
+					flexcan->xmit_maxmb = flexcan->maxmb;
+			}
+		}
+		break;
+	case FLEXCAN_ATTR_XMIT_MAXMB:
+		if ((tmp > 0) && (tmp <= (flexcan->maxmb + 1))) {
+			if (flexcan->xmit_maxmb != (tmp - 1))
+				flexcan->xmit_maxmb = tmp - 1;
+		}
+		break;
+	case FLEXCAN_ATTR_FIFO:
+		flexcan->fifo = !!tmp;
+		break;
+	case FLEXCAN_ATTR_WAKEUP:
+		flexcan->wakeup = !!tmp;
+		break;
+	case FLEXCAN_ATTR_SRX_DIS:
+		flexcan->srx_dis = !!tmp;
+		break;
+	case FLEXCAN_ATTR_WAK_SRC:
+		flexcan->wak_src = !!tmp;
+		break;
+	case FLEXCAN_ATTR_BCC:
+		flexcan->bcc = !!tmp;
+		break;
+	case FLEXCAN_ATTR_LOCAL_PRIORITY:
+		flexcan->lprio = !!tmp;
+		break;
+	case FLEXCAN_ATTR_ABORT:
+		flexcan->abort = !!tmp;
+		break;
+	case FLEXCAN_ATTR_LOOPBACK:
+		flexcan->loopback = !!tmp;
+		break;
+	case FLEXCAN_ATTR_SMP:
+		flexcan->smp = !!tmp;
+		break;
+	case FLEXCAN_ATTR_BOFF_REC:
+		flexcan->boff_rec = !!tmp;
+		break;
+	case FLEXCAN_ATTR_TSYN:
+		flexcan->tsyn = !!tmp;
+		break;
+	case FLEXCAN_ATTR_LISTEN:
+		flexcan->listen = !!tmp;
+		break;
+	case FLEXCAN_ATTR_EXTEND_MSG:
+		flexcan->ext_msg = !!tmp;
+		break;
+	case FLEXCAN_ATTR_STANDARD_MSG:
+		flexcan->std_msg = !!tmp;
+		break;
+	}
+ set_finish:
+	mutex_unlock(&flexcan->mutex);
+	return count;
+}
+
+static void flexcan_device_default(struct flexcan_device *dev)
+{
+	dev->br_clksrc = 1;
+	dev->br_rjw = 2;
+	dev->br_presdiv = 6;
+	dev->br_propseg = 4;
+	dev->br_pseg1 = 4;
+	dev->br_pseg2 = 7;
+
+	dev->bcc = 1;
+	dev->srx_dis = 1;
+	dev->smp = 1;
+	dev->abort = 1;
+
+	dev->maxmb = FLEXCAN_MAX_MB - 1;
+	dev->xmit_maxmb = (FLEXCAN_MAX_MB >> 1) - 1;
+	dev->xmit_mb = dev->maxmb - dev->xmit_maxmb;
+
+	dev->ext_msg = 1;
+	dev->std_msg = 1;
+}
+
+static int flexcan_device_attach(struct flexcan_device *flexcan)
+{
+	int ret;
+	struct resource *res;
+	struct platform_device *pdev = flexcan->dev;
+	struct flexcan_platform_data *plat_data = pdev->dev.platform_data;
+	int irq;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return -ENODEV;
+
+	if (!request_mem_region(res->start, resource_size(res), "flexcan")) {
+		return -EBUSY;
+	}
+
+	flexcan->irq = irq;
+	flexcan->io_base = ioremap_nocache(res->start, resource_size(res));
+	if (!flexcan->io_base) {
+		ret = -ENOMEM;
+		goto release;
+	}
+	pdev_dbg(pdev, 0, "controller registers %08lx remapped to %p\n",
+		 (unsigned long)res->start, flexcan->io_base);
+
+	flexcan->hwmb = flexcan->io_base + CAN_MB_BASE;
+	flexcan->rx_mask = flexcan->io_base + CAN_RXMASK_BASE;
+
+	flexcan->clk = clk_get(&pdev->dev, "can_clk");
+	if (IS_ERR(flexcan->clk)) {
+		ret = PTR_ERR(flexcan->clk);
+		dev_err(&pdev->dev, "Failed to get clock: %d\n", ret);
+		goto unmap;
+	}
+
+	if (plat_data) {
+		if (plat_data->active) {
+			ret = plat_data->active(pdev);
+			if (ret)
+				goto put_clk;
+		}
+		if (plat_data->core_reg) {
+			flexcan->core_reg = regulator_get(&pdev->dev,
+							  plat_data->core_reg);
+			if (IS_ERR(flexcan->core_reg)) {
+				ret = PTR_ERR(flexcan->core_reg);
+				goto deactivate;
+			}
+		}
+
+		if (plat_data->io_reg) {
+			flexcan->io_reg = regulator_get(&pdev->dev,
+							plat_data->io_reg);
+			if (IS_ERR(flexcan->core_reg)) {
+				ret = PTR_ERR(flexcan->io_reg);
+				goto put_reg;
+			}
+		}
+	}
+	return 0;
+
+ put_reg:
+	regulator_put(flexcan->core_reg);
+ deactivate:
+	if (plat_data->inactive)
+		plat_data->inactive(pdev);
+ put_clk:
+	clk_put(flexcan->clk);
+ unmap:
+	iounmap(flexcan->io_base);
+ release:
+	release_mem_region(res->start, resource_size(res));
+	return ret;
+}
+
+static void flexcan_device_detach(struct flexcan_device *flexcan)
+{
+	struct platform_device *pdev = flexcan->dev;
+	struct flexcan_platform_data *plat_data = pdev->dev.platform_data;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	BUG_ON(!res);
+
+	clk_put(flexcan->clk);
+
+	if (flexcan->io_reg) {
+		regulator_put(flexcan->io_reg);
+	}
+
+	if (flexcan->core_reg) {
+		regulator_put(flexcan->core_reg);
+	}
+
+	if (plat_data && plat_data->inactive)
+		plat_data->inactive(pdev);
+
+	iounmap(flexcan->io_base);
+	release_mem_region(res->start, resource_size(res));
+}
+
+static void flexcan_mbm_isr(struct work_struct *work);
+static void flexcan_err_handler(struct work_struct *work);
+
+static struct net_device *flexcan_device_alloc(struct platform_device *pdev,
+					       void (*setup)(struct net_device *dev))
+{
+	struct flexcan_device *flexcan;
+	struct net_device *net;
+	int i, num;
+	int ret;
+
+	net = alloc_netdev(sizeof(*flexcan), "can%d", setup);
+	if (net == NULL) {
+		pdev_err(pdev, "Failed to allocate netdevice\n");
+		return ERR_PTR(-ENOMEM);
+	}
+	flexcan = netdev_priv(net);
+
+	init_timer(&flexcan->timer);
+	mutex_init(&flexcan->mutex);
+	INIT_WORK(&flexcan->mb_work, flexcan_mbm_isr);
+	INIT_WORK(&flexcan->err_work, flexcan_err_handler);
+
+	flexcan->dev = pdev;
+	ret = flexcan_device_attach(flexcan);
+	if (ret) {
+		free_netdev(net);
+		return ERR_PTR(ret);
+	}
+	flexcan_device_default(flexcan);
+	flexcan_update_bitrate(flexcan);
+
+	num = ARRAY_SIZE(flexcan_dev_attr);
+
+	for (i = 0; i < num; i++) {
+		ret = device_create_file(&pdev->dev, flexcan_dev_attr + i);
+		if (ret) {
+			pdev_err(pdev, "Failed to create attribute file %s: %d\n",
+				(flexcan_dev_attr + i)->attr.name, ret);
+			for (i--; i >= 0; i--)
+				device_remove_file(&pdev->dev, flexcan_dev_attr + i);
+			flexcan_device_detach(flexcan);
+			free_netdev(net);
+			return ERR_PTR(ret);
+		}
+	}
+	platform_set_drvdata(pdev, net);
+	return net;
+}
+
+static void flexcan_device_free(struct net_device *dev)
+{
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct platform_device *pdev = flexcan->dev;
+	int i;
+
+	ndev_dbg(dev, 0, "%s: Deleting timer\n", __FUNCTION__);
+	del_timer_sync(&flexcan->timer);
+
+	ndev_dbg(dev, 0, "%s: Removing sysfs files\n", __FUNCTION__);
+	for (i = 0; i < ARRAY_SIZE(flexcan_dev_attr); i++)
+		device_remove_file(&pdev->dev, flexcan_dev_attr + i);
+
+	ndev_dbg(dev, 0, "%s: Detaching can device\n", __FUNCTION__);
+	flexcan_device_detach(flexcan);
+	ndev_dbg(dev, 0, "%s: Freeing net_device\n", __FUNCTION__);
+	free_netdev(dev);
+}
+
+#define flexcan_swab32(x)				\
+	(((x) << 24) | ((x) >> 24) |			\
+		(((x) & (__u32)0x0000ff00UL) << 8) |	\
+		(((x) & (__u32)0x00ff0000UL) >> 8))
+
+static inline void flexcan_mb_write(struct can_frame *frame, struct can_hw_mb __iomem *hwmb,
+				    int code)
+{
+	int i;
+	unsigned long __iomem *s = (unsigned long *)&frame->data[0];
+	unsigned long __iomem *d = (unsigned long *)&hwmb->mb_data[0];
+	struct can_hw_mb mb;
+	unsigned int can_id;
+	int n_words = (frame->can_dlc + 3) / sizeof(unsigned int);
+
+	mb.mb_cs.data = 0;
+	mb.mb_cs.cs.code = code;
+	mb.mb_cs.cs.length = frame->can_dlc;
+
+	mb.mb_cs.cs.rtr = !!(frame->can_id & CAN_RTR_FLAG);
+
+	if (frame->can_id & CAN_EFF_FLAG) {
+		mb.mb_cs.cs.ide = 1;
+		mb.mb_cs.cs.srr = 1;
+		can_id = frame->can_id & CAN_EFF_MASK;
+	} else {
+		mb.mb_cs.cs.ide = 0;
+		can_id = (frame->can_id & CAN_SFF_MASK) << 18;
+	}
+
+	DBG(0, "%s: writing can_id %08x to mb_id %p\n", __FUNCTION__, can_id, &hwmb->mb_id);
+	__raw_writel(can_id, &hwmb->mb_id);
+	for (i = 0; i < n_words; i++, s++, d++) {
+		DBG(0, "%s: writing data %08lx to mb_data %p\n", __FUNCTION__,
+		    flexcan_swab32(*s), d);
+		__raw_writel(flexcan_swab32(*s), d);
+	}
+	DBG(0, "%s: Writing CS %08x to mb_cs %p\n", __FUNCTION__, mb.mb_cs.data, &hwmb->mb_cs);
+	__raw_writel(mb.mb_cs.data, &hwmb->mb_cs.data);
+}
+
+static inline void flexcan_mb_read(struct can_frame *frame, struct can_hw_mb __iomem *hwmb)
+{
+	int i;
+	unsigned long __iomem *s = (unsigned long *)&hwmb->mb_data[0];
+	unsigned long __iomem *d = (unsigned long *)&frame->data[0];
+	struct can_hw_mb mb;
+	unsigned int can_id;
+	int n_words;
+
+	mb.mb_cs.data = __raw_readl(&hwmb->mb_cs);
+	BUG_ON(mb.mb_cs.cs.code & CAN_MB_RX_BUSY);
+
+	can_id = __raw_readl(&hwmb->mb_id);
+
+	if (mb.mb_cs.cs.ide)
+		frame->can_id = (can_id & CAN_EFF_MASK) | CAN_EFF_FLAG;
+	else
+		frame->can_id = (can_id >> 18) & CAN_SFF_MASK;
+	if (mb.mb_cs.cs.rtr)
+		frame->can_id |= CAN_RTR_FLAG;
+
+	frame->can_dlc = mb.mb_cs.cs.length;
+	if (frame->can_dlc == 0 || frame->can_dlc > 8)
+		return;
+
+	n_words = (frame->can_dlc + 3) / sizeof(unsigned int);
+	for (i = 0; i < n_words; i++, s++, d++)
+		*d = flexcan_swab32(__raw_readl(s));
+}
+
+static inline void flexcan_memcpy(void *dst, void *src, int len)
+{
+	int i;
+	unsigned int __iomem *d = dst, *s = src;
+
+	DBG(2, "%s: Copying %u byte from %p to %p\n", __FUNCTION__, len, s, d);
+	WARN_ON(len & 3);
+	len = (len + 3) >> 2;
+	for (i = 0; i < len; i++, s++, d++)
+		__raw_writel(flexcan_swab32(*s), d);
+	if (dbg_lvl(1)) {
+		print_hex_dump(KERN_DEBUG, "swdat: ", DUMP_PREFIX_OFFSET, 16, 4,
+			       src, len << 2, 0);
+		print_hex_dump(KERN_DEBUG, "hwdat: ", DUMP_PREFIX_OFFSET, 16, 4,
+			       dst, len << 2, 0);
+	}
+}
+
+static inline struct can_frame *flexcan_skb_put(struct sk_buff *skb, unsigned int len)
+{
+	return (struct can_frame *)skb_put(skb, len);
+}
+
+static inline struct can_frame *flexcan_skb_data(struct sk_buff *skb)
+{
+	BUG_ON(skb == NULL);
+	return (struct can_frame *)skb->data;
+}
+
+static struct net_device_stats *flexcan_get_stats(struct net_device *dev)
+{
+	ndev_dbg(dev, 3, "%s@%d: \n", __FUNCTION__, __LINE__);
+	if (!netif_running(dev))
+		return &dev->stats;
+	ndev_dbg(dev, 3, "%s@%d: \n", __FUNCTION__, __LINE__);
+	return &dev->stats;
+}
+
+static void flexcan_mb_bottom(struct net_device *dev, int index)
+{
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct net_device_stats *stats = flexcan_get_stats(dev);
+	struct can_hw_mb __iomem *hwmb;
+	struct can_frame *frame;
+	struct sk_buff *skb;
+	struct can_hw_mb mb;
+
+	ndev_dbg(dev, 1, "%s: index: %d\n", __FUNCTION__, index);
+
+	hwmb = flexcan->hwmb + index;
+	mb.mb_cs.data = __raw_readl(&hwmb->mb_cs.data);
+	if (flexcan->fifo ||
+	    index >= flexcan->maxmb - flexcan->xmit_maxmb) {
+		/* handle transmit MBs */
+
+		if (mb.mb_cs.cs.code == CAN_MB_TX_ABORT) {
+			mb.mb_cs.cs.code = CAN_MB_TX_INACTIVE;
+			__raw_writel(mb.mb_cs.data, &hwmb->mb_cs.data);
+		}
+		if (mb.mb_cs.cs.code & CAN_MB_TX_INACTIVE) {
+			if (flexcan->xmit_buffers++ == 0) {
+				ndev_dbg(dev, 1, "%s: Starting netif queue\n", __FUNCTION__);
+				netif_start_queue(dev);
+			}
+			BUG_ON(flexcan->xmit_buffers > flexcan->maxmb - flexcan->xmit_maxmb);
+			return;
+		}
+		/* if fifo is enabled all RX MBs should be handled in the fifo_isr */
+		BUG();
+	}
+	if (dbg_lvl(1))
+		print_hex_dump(KERN_DEBUG, "rx_mb: ", DUMP_PREFIX_OFFSET, 16, 4,
+			       hwmb, sizeof(*hwmb), 0);
+	/* handle RX MB in case fifo is not used */
+	BUG_ON(flexcan->fifo);
+	if (mb.mb_cs.cs.code & CAN_MB_RX_BUSY) {
+		ndev_dbg(dev, -1, "%s: MB[%02x] is busy: %x\n", __FUNCTION__,
+			 index, mb.mb_cs.cs.code);
+		/* unlock buffer */
+		(void)flexcan_reg_read(flexcan, CAN_HW_REG_TIMER);
+		return;
+	}
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (skb) {
+		frame = flexcan_skb_put(skb, sizeof(*frame));
+		flexcan_mb_read(frame, hwmb);
+		/* unlock buffer */
+		(void)flexcan_reg_read(flexcan, CAN_HW_REG_TIMER);
+
+		dev->last_rx = jiffies;
+		stats->rx_packets++;
+		stats->rx_bytes += frame->can_dlc;
+
+		skb->dev = dev;
+		skb->protocol = __constant_htons(ETH_P_CAN);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_receive_skb(skb);
+	} else {
+		flexcan_dbg(flexcan, 0, "%s: Could not allocate SKB; dropping packet\n",
+			    __FUNCTION__);
+
+		stats->rx_dropped++;
+	}
+}
+
+static void flexcan_fifo_isr(struct net_device *dev, unsigned int iflag1)
+{
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct net_device_stats *stats = flexcan_get_stats(dev);
+	struct sk_buff *skb;
+	struct can_hw_mb __iomem *hwmb = flexcan->hwmb;
+	struct can_frame *frame;
+
+	ndev_dbg(dev, 2, "%s: \n", __FUNCTION__);
+	if (dbg_lvl(1))
+		print_hex_dump(KERN_DEBUG, "rx_mb: ", DUMP_PREFIX_OFFSET, 16, 4,
+			       hwmb, sizeof(*hwmb), 0);
+	if (iflag1 & __FIFO_RDY_INT) {
+		skb = dev_alloc_skb(sizeof(struct can_frame));
+		if (skb) {
+			frame = flexcan_skb_put(skb, sizeof(*frame));
+			flexcan_mb_read(frame, hwmb);
+			/* unlock mb */
+			(void) flexcan_reg_read(flexcan, CAN_HW_REG_TIMER);
+
+			dev->last_rx = jiffies;
+
+			stats->rx_packets++;
+			stats->rx_bytes += frame->can_dlc;
+
+			skb->dev = dev;
+			skb->protocol = __constant_htons(ETH_P_CAN);
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+			netif_receive_skb(skb);
+		} else {
+			(void)__raw_readl(&hwmb->mb_cs.data);
+			/* unlock mb */
+			(void) flexcan_reg_read(flexcan, CAN_HW_REG_TIMER);
+		}
+	}
+
+	if (iflag1 & (__FIFO_OV_INT | __FIFO_WARN_INT)) {
+		skb = dev_alloc_skb(sizeof(struct can_frame));
+		if (skb) {
+			frame = flexcan_skb_put(skb, sizeof(*frame));
+			frame->can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
+			frame->can_dlc = CAN_ERR_DLC;
+			if (iflag1 & __FIFO_WARN_INT)
+				frame->data[1] |=
+				    CAN_ERR_CRTL_TX_WARNING |
+				    CAN_ERR_CRTL_RX_WARNING;
+			if (iflag1 & __FIFO_OV_INT)
+				frame->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
+			if (dbg_lvl(1))
+				print_hex_dump(KERN_DEBUG, "err_mb: ", DUMP_PREFIX_OFFSET, 16, 4,
+					       frame, sizeof(*frame), 0);
+
+			skb->dev = dev;
+			skb->protocol = __constant_htons(ETH_P_CAN);
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+			netif_receive_skb(skb);
+		}
+	}
+}
+
+/*
+ * called by CAN ISR to handle mb events.
+ */
+static void flexcan_mbm_isr(struct work_struct *work)
+{
+	struct flexcan_device *flexcan = container_of(work, struct flexcan_device, mb_work);
+	struct net_device *dev = platform_get_drvdata(flexcan->dev);
+	int i, iflag1, iflag2, maxmb;
+
+	i = 0;
+
+	ndev_dbg(dev, 2, "%s: \n", __FUNCTION__);
+
+	iflag1 = flexcan_reg_read(flexcan, CAN_HW_REG_IFLAG1) &
+		flexcan_reg_read(flexcan, CAN_HW_REG_IMASK1);
+	if (flexcan->maxmb > 31) {
+		maxmb = flexcan->maxmb + 1 - 32;
+		iflag2 = flexcan_reg_read(flexcan, CAN_HW_REG_IFLAG2) &
+		    flexcan_reg_read(flexcan, CAN_HW_REG_IMASK2);
+		iflag2 &= (1 << maxmb) - 1;
+		maxmb = 32;
+	} else {
+		maxmb = flexcan->maxmb + 1;
+		iflag1 &= (1 << maxmb) - 1;
+		iflag2 = 0;
+	}
+
+	ndev_dbg(dev, 2, "%s: loop=%d iflag1=%08x\n", __FUNCTION__, i, iflag1);
+
+	flexcan_reg_write(flexcan, CAN_HW_REG_IFLAG1, iflag1);
+	flexcan_reg_write(flexcan, CAN_HW_REG_IFLAG2, iflag2);
+
+	if (flexcan->fifo) {
+		flexcan_fifo_isr(dev, iflag1);
+		iflag1 &= ~0xFF;
+	}
+	for (i = 0; iflag1 && (i < maxmb); i++) {
+		if (iflag1 & (1 << i)) {
+			iflag1 &= ~(1 << i);
+			flexcan_mb_bottom(dev, i);
+		}
+	}
+
+	for (i = maxmb; iflag2 && (i <= flexcan->maxmb); i++) {
+		if (iflag2 & (1 << (i - 32))) {
+			iflag2 &= ~(1 << (i - 32));
+			flexcan_mb_bottom(dev, i);
+		}
+	}
+	enable_irq(flexcan->irq);
+}
+
+static int flexcan_mbm_xmit(struct flexcan_device *flexcan, struct can_frame *frame)
+{
+	int i = flexcan->xmit_mb;
+	struct can_hw_mb __iomem *hwmb = flexcan->hwmb;
+	static int last;
+
+	if (flexcan->xmit_buffers != last) {
+		flexcan_dbg(flexcan, 1, "%s: %d free buffers\n", __FUNCTION__,
+			    flexcan->xmit_buffers);
+		last = flexcan->xmit_buffers;
+	}
+	do {
+		struct can_hw_mb mb;
+
+		mb.mb_cs.data = __raw_readl(&hwmb[i].mb_cs);
+
+		if (mb.mb_cs.cs.code == CAN_MB_TX_INACTIVE)
+			break;
+		if (++i > flexcan->maxmb) {
+			if (flexcan->fifo)
+				i = FLEXCAN_MAX_FIFO_MB;
+			else
+				i = flexcan->xmit_maxmb + 1;
+		}
+		if (i == flexcan->xmit_mb) {
+			flexcan_dbg(flexcan, 0, "%s: no free xmit buffer\n", __FUNCTION__);
+			return 0;
+		}
+	} while (1);
+
+	flexcan->xmit_mb = i + 1;
+	if (flexcan->xmit_mb > flexcan->maxmb) {
+		if (flexcan->fifo)
+			flexcan->xmit_mb = FLEXCAN_MAX_FIFO_MB;
+		else
+			flexcan->xmit_mb = flexcan->xmit_maxmb + 1;
+	}
+
+	flexcan_dbg(flexcan, 1, "%s: Enabling transmission of buffer %d\n", __FUNCTION__, i);
+	flexcan_mb_write(frame, &hwmb[i], CAN_MB_TX_ONCE);
+
+	if (dbg_lvl(1))
+		print_hex_dump(KERN_DEBUG, "tx_mb: ", DUMP_PREFIX_OFFSET, 16, 4,
+			       &hwmb[i], sizeof(*hwmb), 0);
+	return 1;
+}
+
+static void flexcan_mbm_init(struct flexcan_device *flexcan)
+{
+	struct can_hw_mb __iomem *hwmb;
+	int rx_mb, i;
+
+	flexcan_dbg(flexcan, 0, "%s@%d: \n", __FUNCTION__, __LINE__);
+
+	/* Set global mask to receive all messages */
+	flexcan_reg_write(flexcan, CAN_HW_REG_RXGMASK, 0);
+	flexcan_reg_write(flexcan, CAN_HW_REG_RX14MASK, 0);
+	flexcan_reg_write(flexcan, CAN_HW_REG_RX15MASK, 0);
+
+	for (i = 0; i < FLEXCAN_MAX_MB; i++) {
+		int j;
+		void __iomem *mb = &flexcan->hwmb[i];
+		void __iomem *rxm = &flexcan->rx_mask[i];
+
+		__raw_writel(0, rxm);
+		for (j = 0; j < sizeof(*flexcan->hwmb); j += 4) {
+			__raw_writel(0, mb + j);
+		}
+	}
+
+	if (flexcan->fifo)
+		rx_mb = FLEXCAN_MAX_FIFO_MB;
+	else
+		rx_mb = flexcan->maxmb - flexcan->xmit_maxmb;
+
+	hwmb = flexcan->hwmb;
+	if (flexcan->fifo) {
+		unsigned long *id_table = flexcan->io_base + CAN_FIFO_BASE;
+		for (i = 0; i < rx_mb; i++)
+			__raw_writel(0, &id_table[i]);
+	} else {
+		for (i = 0; i < rx_mb; i++) {
+			struct can_hw_mb mb;
+
+			mb.mb_cs.data = 0;
+			mb.mb_cs.cs.code = CAN_MB_RX_EMPTY;
+			if (flexcan->ext_msg && flexcan->std_msg)
+				mb.mb_cs.cs.ide = i & 1;
+			else if (flexcan->ext_msg)
+				mb.mb_cs.cs.ide = 1;
+
+			__raw_writel(mb.mb_cs.data, &hwmb[i]);
+		}
+	}
+
+	for (; i <= flexcan->maxmb; i++) {
+		struct can_hw_mb mb;
+
+		mb.mb_cs.data = 0;
+		mb.mb_cs.cs.code = CAN_MB_TX_INACTIVE;
+		__raw_writel(mb.mb_cs.data, &hwmb[i]);
+	}
+
+	flexcan->xmit_mb = rx_mb;
+	flexcan->xmit_buffers = flexcan->maxmb - flexcan->xmit_maxmb;
+}
+
+static void flexcan_hw_start(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+
+	flexcan_dbg(flexcan, 0, "%s: \n", __FUNCTION__);
+
+	if ((flexcan->maxmb + 1) > 32) {
+		flexcan_reg_write(flexcan, CAN_HW_REG_IMASK1, ~0);
+		reg = (1 << (flexcan->maxmb - 31)) - 1;
+		flexcan_reg_write(flexcan, CAN_HW_REG_IMASK2, reg);
+	} else {
+		reg = (1 << (flexcan->maxmb + 1)) - 1;
+		flexcan_reg_write(flexcan, CAN_HW_REG_IMASK1, reg);
+		flexcan_reg_write(flexcan, CAN_HW_REG_IMASK2, 0);
+	}
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	flexcan_reg_write(flexcan, CAN_HW_REG_MCR, reg & ~__MCR_HALT);
+}
+
+static void flexcan_hw_stop(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+
+	flexcan_dbg(flexcan, 0, "%s: \n", __FUNCTION__);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	flexcan_reg_write(flexcan, CAN_HW_REG_MCR, reg | __MCR_HALT);
+}
+
+static int flexcan_hw_reset(struct flexcan_device *flexcan)
+{
+	struct platform_device *pdev __attribute__((unused)) = flexcan->dev;
+	unsigned int reg;
+	int timeout = 100000;
+
+	flexcan_dbg(flexcan, 0, "%s: \n", __FUNCTION__);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	flexcan_reg_write(flexcan, CAN_HW_REG_MCR, reg | __MCR_MDIS);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_CTRL);
+	if (flexcan->br_clksrc)
+		reg |= __CTRL_CLK_SRC;
+	else
+		reg &= ~__CTRL_CLK_SRC;
+	flexcan_reg_write(flexcan, CAN_HW_REG_CTRL, reg);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR) & ~__MCR_MDIS;
+	flexcan_reg_write(flexcan, CAN_HW_REG_MCR, reg);
+	reg |= __MCR_SOFT_RST;
+	flexcan_reg_write(flexcan, CAN_HW_REG_MCR, reg);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	while (reg & __MCR_SOFT_RST) {
+		if (--timeout <= 0) {
+			dev_err(&pdev->dev, "Flexcan software Reset Timeout\n");
+			return -ETIME;
+		}
+		udelay(10);
+		reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	}
+	return 0;
+}
+
+static void flexcan_mcr_setup(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+
+	flexcan_dbg(flexcan, 0, "%s: \n", __FUNCTION__);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	reg &= ~(__MCR_MAX_MB_MASK | __MCR_WAK_MSK | __MCR_MAX_IDAM_MASK);
+
+	if (flexcan->fifo)
+		reg |= __MCR_FEN;
+	else
+		reg &= ~__MCR_FEN;
+
+	if (flexcan->wakeup)
+		reg |= __MCR_SLF_WAK | __MCR_WAK_MSK;
+	else
+		reg &= ~(__MCR_SLF_WAK | __MCR_WAK_MSK);
+
+	if (flexcan->wak_src)
+		reg |= __MCR_WAK_SRC;
+	else
+		reg &= ~__MCR_WAK_SRC;
+
+	if (flexcan->srx_dis)
+		reg |= __MCR_SRX_DIS;
+	else
+		reg &= ~__MCR_SRX_DIS;
+
+	if (flexcan->bcc)
+		reg |= __MCR_BCC;
+	else
+		reg &= ~__MCR_BCC;
+
+	if (flexcan->lprio)
+		reg |= __MCR_LPRIO_EN;
+	else
+		reg &= ~__MCR_LPRIO_EN;
+
+	if (flexcan->abort)
+		reg |= __MCR_AEN;
+	else
+		reg &= ~__MCR_AEN;
+
+	reg |= (flexcan->maxmb << __MCR_MAX_MB_OFFSET);
+	reg |= __MCR_DOZE | __MCR_MAX_IDAM_C;
+	flexcan_reg_write(flexcan, CAN_HW_REG_MCR, reg);
+}
+
+static void flexcan_ctrl_setup(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+
+	flexcan_dbg(flexcan, 0, "%s: \n", __FUNCTION__);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_CTRL);
+	reg &= ~(__CTRL_PRESDIV_MASK | __CTRL_RJW_MASK | __CTRL_PSEG1_MASK |
+		 __CTRL_PSEG2_MASK | __CTRL_PROPSEG_MASK);
+
+	if (flexcan->loopback)
+		reg |= __CTRL_LPB;
+	else
+		reg &= ~__CTRL_LPB;
+
+	if (flexcan->smp)
+		reg |= __CTRL_SMP;
+	else
+		reg &= ~__CTRL_SMP;
+
+	if (flexcan->boff_rec)
+		reg |= __CTRL_BOFF_REC;
+	else
+		reg &= ~__CTRL_BOFF_REC;
+
+	if (flexcan->tsyn)
+		reg |= __CTRL_TSYN;
+	else
+		reg &= ~__CTRL_TSYN;
+
+	if (flexcan->listen)
+		reg |= __CTRL_LOM;
+	else
+		reg &= ~__CTRL_LOM;
+
+	reg |= (flexcan->br_presdiv << __CTRL_PRESDIV_OFFSET) |
+	    (flexcan->br_rjw << __CTRL_RJW_OFFSET) |
+	    (flexcan->br_pseg1 << __CTRL_PSEG1_OFFSET) |
+	    (flexcan->br_pseg2 << __CTRL_PSEG2_OFFSET) |
+	    (flexcan->br_propseg << __CTRL_PROPSEG_OFFSET);
+
+	reg &= ~__CTRL_LBUF;
+
+	reg |= __CTRL_TWRN_MSK | __CTRL_RWRN_MSK | __CTRL_BOFF_MSK |
+	    __CTRL_ERR_MSK;
+
+	flexcan_reg_write(flexcan, CAN_HW_REG_CTRL, reg);
+}
+
+static int flexcan_hw_restart(struct net_device *dev)
+{
+	unsigned int reg;
+	struct flexcan_device *flexcan = netdev_priv(dev);
+
+	ndev_dbg(dev, 0, "%s: \n", __FUNCTION__);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	if (reg & __MCR_SOFT_RST)
+		return 1;
+
+	flexcan_mcr_setup(flexcan);
+
+	flexcan_reg_write(flexcan, CAN_HW_REG_IMASK2, 0);
+	flexcan_reg_write(flexcan, CAN_HW_REG_IMASK1, 0);
+
+	flexcan_reg_write(flexcan, CAN_HW_REG_IFLAG2, 0xFFFFFFFF);
+	flexcan_reg_write(flexcan, CAN_HW_REG_IFLAG1, 0xFFFFFFFF);
+
+	flexcan_reg_write(flexcan, CAN_HW_REG_ECR, 0);
+
+	flexcan_mbm_init(flexcan);
+	netif_carrier_on(dev);
+	flexcan_hw_start(flexcan);
+
+	if (netif_queue_stopped(dev)) {
+		ndev_dbg(dev, 1, "%s@%d: Starting netif queue\n",
+			 __FUNCTION__, __LINE__);
+		netif_start_queue(dev);
+	}
+	return 0;
+}
+
+static void flexcan_hw_watch(unsigned long data)
+{
+	unsigned int reg, ecr;
+	struct net_device *dev = (struct net_device *)data;
+	struct flexcan_device *flexcan = netdev_priv(dev);
+
+	ndev_dbg(dev, 1, "%s: \n", __FUNCTION__);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	if (reg & __MCR_MDIS) {
+		if (flexcan_hw_restart(dev))
+			mod_timer(&flexcan->timer, HZ / 20);
+		return;
+	}
+	ecr = flexcan_reg_read(flexcan, CAN_HW_REG_ECR);
+	if (flexcan->boff_rec) {
+		if (((reg & __ESR_FLT_CONF_MASK) >> __ESR_FLT_CONF_OFF) > 1) {
+			reg |= __MCR_SOFT_RST;
+			ndev_dbg(dev, 1, "%s: Initiating soft reset\n", __FUNCTION__);
+			flexcan_reg_write(flexcan, CAN_HW_REG_MCR, reg);
+			mod_timer(&flexcan->timer, HZ / 20);
+			return;
+		}
+		netif_carrier_on(dev);
+	}
+	ndev_dbg(dev, 1, "%s: Done\n", __FUNCTION__);
+}
+
+static void flexcan_hw_busoff(struct net_device *dev)
+{
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	unsigned int reg;
+
+	netif_carrier_off(dev);
+
+	flexcan->timer.function = flexcan_hw_watch;
+	flexcan->timer.data = (unsigned long)dev;
+
+	if (flexcan->boff_rec) {
+		mod_timer(&flexcan->timer, HZ / 10);
+		return;
+	}
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_MCR);
+	flexcan_reg_write(flexcan, CAN_HW_REG_MCR, reg | __MCR_SOFT_RST);
+	mod_timer(&flexcan->timer, HZ / 20);
+}
+
+static int flexcan_hw_open(struct flexcan_device *flexcan)
+{
+	int ret;
+
+	if ((ret = flexcan_hw_reset(flexcan)) != 0)
+		return ret;
+
+	flexcan_mcr_setup(flexcan);
+	flexcan_ctrl_setup(flexcan);
+
+	flexcan_reg_write(flexcan, CAN_HW_REG_IMASK2, 0);
+	flexcan_reg_write(flexcan, CAN_HW_REG_IMASK1, 0);
+
+	flexcan_reg_write(flexcan, CAN_HW_REG_IFLAG2, 0xFFFFFFFF);
+	flexcan_reg_write(flexcan, CAN_HW_REG_IFLAG1, 0xFFFFFFFF);
+
+	flexcan_reg_write(flexcan, CAN_HW_REG_ECR, 0);
+	return 0;
+}
+
+static void flexcan_err_handler(struct work_struct *work)
+{
+	struct flexcan_device *flexcan = container_of(work, struct flexcan_device, err_work);
+	struct net_device *dev = platform_get_drvdata(flexcan->dev);
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	unsigned int esr, ecr;
+
+	ndev_dbg(dev, 1, "%s@%d: \n", __FUNCTION__, __LINE__);
+
+	esr = flexcan_reg_read(flexcan, CAN_HW_REG_ESR);
+	flexcan_reg_write(flexcan, CAN_HW_REG_ESR, esr & __ESR_INTERRUPTS);
+	enable_irq(flexcan->irq);
+
+	if (esr & __ESR_WAK_INT) {
+		ndev_dbg(dev, 0, "%s@%d: \n", __FUNCTION__, __LINE__);
+		return;
+	}
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb) {
+		ndev_err(dev, "%s: Failed to allocate skb\n", __func__);
+		return;
+	}
+	frame = flexcan_skb_put(skb, sizeof(*frame));
+	frame->can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
+	frame->can_dlc = CAN_ERR_DLC;
+
+	if (esr & __ESR_TWRN_INT) {
+		ndev_err(dev, "%s: TX_WARNING\n", __FUNCTION__);
+		frame->data[1] |= CAN_ERR_CRTL_TX_WARNING;
+	}
+	if (esr & __ESR_RWRN_INT) {
+		ndev_err(dev, "%s: RX_WARNING\n", __FUNCTION__);
+		frame->data[1] |= CAN_ERR_CRTL_RX_WARNING;
+	}
+	if (esr & __ESR_BOFF_INT) {
+		ndev_err(dev, "%s: BUS_OFF\n", __FUNCTION__);
+		frame->can_id |= CAN_ERR_BUSOFF;
+	}
+	if (esr & __ESR_ERR_INT) {
+		ndev_dbg(dev, 1, "%s@%d: \n", __FUNCTION__, __LINE__);
+		if (esr & __ESR_BIT1_ERR) {
+			ndev_err(dev, "%s: BIT1_ERR\n", __FUNCTION__);
+			frame->data[2] |= CAN_ERR_PROT_BIT1;
+		}
+
+		if (esr & __ESR_BIT0_ERR) {
+			ndev_err(dev, "%s: BIT0_ERR\n", __FUNCTION__);
+			frame->data[2] |= CAN_ERR_PROT_BIT0;
+		}
+
+		if (esr & __ESR_ACK_ERR) {
+			ndev_err(dev, "%s: ACK_ERR\n", __FUNCTION__);
+			frame->can_id |= CAN_ERR_ACK;
+		}
+
+		/*TODO:// if (esr & __ESR_CRC_ERR) */
+
+		if (esr & __ESR_FRM_ERR) {
+			ndev_err(dev, "%s: FRM_ERR\n", __FUNCTION__);
+			frame->data[2] |= CAN_ERR_PROT_FORM;
+		}
+
+		if (esr & __ESR_STF_ERR) {
+			ndev_err(dev, "%s: STF_ERR\n", __FUNCTION__);
+			frame->data[2] |= CAN_ERR_PROT_STUFF;
+		}
+
+		ecr = flexcan_reg_read(flexcan, CAN_HW_REG_ECR);
+		switch ((esr & __ESR_FLT_CONF_MASK) >> __ESR_FLT_CONF_OFF) {
+		case 0:
+			ndev_dbg(dev, 0, "%s@%d: \n", __FUNCTION__, __LINE__);
+			if (__ECR_TX_ERR_COUNTER(ecr) >= __ECR_ACTIVE_THRESHOLD)
+				frame->data[1] |= CAN_ERR_CRTL_TX_WARNING;
+			if (__ECR_RX_ERR_COUNTER(ecr) >= __ECR_ACTIVE_THRESHOLD)
+				frame->data[1] |= CAN_ERR_CRTL_RX_WARNING;
+			break;
+		case 1:
+			ndev_dbg(dev, 0, "%s@%d: \n", __FUNCTION__, __LINE__);
+			if (__ECR_TX_ERR_COUNTER(ecr) >=
+			    __ECR_PASSIVE_THRESHOLD)
+				frame->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+
+			if (__ECR_RX_ERR_COUNTER(ecr) >=
+			    __ECR_PASSIVE_THRESHOLD)
+				frame->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+			break;
+		default:
+			ndev_dbg(dev, 0, "%s@%d: \n", __FUNCTION__, __LINE__);
+			frame->can_id |= CAN_ERR_BUSOFF;
+		}
+	}
+
+	if (frame->can_id & CAN_ERR_BUSOFF) {
+		ndev_dbg(dev, 0, "%s: switchung bus off\n", __FUNCTION__);
+		flexcan_hw_busoff(dev);
+	}
+	skb->dev = dev;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	netif_receive_skb(skb);
+}
+
+static irqreturn_t flexcan_irq_handler(int irq, void *data)
+{
+	struct net_device *dev = data;
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	unsigned int reg;
+
+	ndev_dbg(dev, 1, "%s: \n", __FUNCTION__);
+	disable_irq_nosync(irq);
+
+	reg = flexcan_reg_read(flexcan, CAN_HW_REG_ESR);
+	if (reg & __ESR_INTERRUPTS) {
+		ndev_dbg(dev, 1, "%s: Scheduling err handler\n", __FUNCTION__);
+		schedule_work(&flexcan->err_work);
+		return IRQ_HANDLED;
+	}
+
+	ndev_dbg(dev, 1, "%s: Scheduling mbm handler\n", __FUNCTION__);
+	schedule_work(&flexcan->mb_work);
+	return IRQ_HANDLED;
+}
+
+static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_frame *frame = flexcan_skb_data(skb);
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct net_device_stats *stats = flexcan_get_stats(dev);
+
+	ndev_dbg(dev, 1, "%s: \n", __FUNCTION__);
+
+	if (frame->can_dlc > 8)
+		return -EINVAL;
+
+	if (flexcan_mbm_xmit(flexcan, frame)) {
+		dev_kfree_skb(skb);
+		stats->tx_bytes += frame->can_dlc;
+		stats->tx_packets++;
+		dev->trans_start = jiffies;
+		if (--flexcan->xmit_buffers == 0) {
+			ndev_dbg(dev, 1, "%s: Stopping netif queue\n", __FUNCTION__);
+			netif_stop_queue(dev);
+		}
+		BUG_ON(flexcan->xmit_buffers < 0);
+		return NETDEV_TX_OK;
+	}
+	ndev_dbg(dev, 1, "%s: could not transmit message\n", __FUNCTION__);
+	return NETDEV_TX_BUSY;
+}
+
+static int flexcan_open(struct net_device *dev)
+{
+	int ret;
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct platform_device *pdev = flexcan->dev;
+	struct flexcan_platform_data *plat_data = pdev->dev.platform_data;
+
+	ndev_dbg(dev, 0, "%s: \n", __FUNCTION__);
+
+	ret = clk_enable(flexcan->clk);
+	if (ret)
+		goto clk_err;
+
+	if (flexcan->core_reg) {
+		ret = regulator_enable(flexcan->core_reg);
+		if (ret)
+			goto core_reg_err;
+	}
+
+	if (flexcan->io_reg) {
+		ret = regulator_enable(flexcan->io_reg);
+		if (ret)
+			goto io_reg_err;
+	}
+
+	if (plat_data && plat_data->xcvr_enable) {
+		ret = plat_data->xcvr_enable(pdev, 1);
+		if (ret)
+			goto enable_err;
+	}
+
+	ret = request_irq(flexcan->irq, flexcan_irq_handler, IRQF_SAMPLE_RANDOM,
+			  dev->name, dev);
+	if (ret)
+		goto irq_err;
+
+	ret = flexcan_hw_open(flexcan);
+	if (ret)
+		goto open_err;
+
+	flexcan_mbm_init(flexcan);
+	netif_carrier_on(dev);
+	flexcan_hw_start(flexcan);
+	return 0;
+
+ open_err:
+	free_irq(flexcan->irq, dev);
+ irq_err:
+	if (plat_data && plat_data->xcvr_enable)
+		plat_data->xcvr_enable(pdev, 0);
+ enable_err:
+	if (flexcan->io_reg)
+		regulator_disable(flexcan->io_reg);
+ io_reg_err:
+	if (flexcan->core_reg)
+		regulator_disable(flexcan->core_reg);
+ core_reg_err:
+	if (flexcan->clk)
+		clk_disable(flexcan->clk);
+ clk_err:
+	return ret;
+}
+
+static int flexcan_stop(struct net_device *dev)
+{
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct platform_device *pdev = flexcan->dev;
+	struct flexcan_platform_data *plat_data = pdev->dev.platform_data;
+
+	flexcan_hw_stop(flexcan);
+
+	free_irq(flexcan->irq, dev);
+
+	if (plat_data && plat_data->xcvr_enable)
+		plat_data->xcvr_enable(pdev, 0);
+
+	if (flexcan->io_reg)
+		regulator_disable(flexcan->io_reg);
+	if (flexcan->core_reg)
+		regulator_disable(flexcan->core_reg);
+	clk_disable(flexcan->clk);
+	return 0;
+}
+
+static const struct net_device_ops flexcan_netdev_ops = {
+	.ndo_open	= flexcan_open,
+	.ndo_stop	= flexcan_stop,
+	.ndo_start_xmit = flexcan_start_xmit,
+	.ndo_get_stats	= flexcan_get_stats,
+};
+
+static void flexcan_setup(struct net_device *dev)
+{
+	dev->type = ARPHRD_CAN;
+	dev->mtu = sizeof(struct can_frame);
+	dev->hard_header_len = 0;
+	dev->addr_len = 0;
+	dev->tx_queue_len = FLEXCAN_MAX_MB;
+	dev->flags = IFF_NOARP;
+	dev->features = NETIF_F_NO_CSUM;
+
+	dev->netdev_ops = &flexcan_netdev_ops;
+	dev->destructor = flexcan_device_free;
+}
+
+static int flexcan_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct net_device *net;
+
+	net = flexcan_device_alloc(pdev, flexcan_setup);
+	if (IS_ERR(net))
+		return PTR_ERR(net);
+
+	ret = register_netdev(net);
+	if (ret) {
+		flexcan_device_free(net);
+	}
+	return ret;
+}
+
+static int flexcan_remove(struct platform_device *pdev)
+{
+	struct net_device *net = platform_get_drvdata(pdev);
+
+	unregister_netdev(net);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int flexcan_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *net = platform_get_drvdata(pdev);
+	struct flexcan_device *flexcan = netdev_priv(net);
+	struct flexcan_platform_data *plat_data;
+
+	if (!(net->flags & IFF_UP))
+		return 0;
+
+	if (flexcan->wakeup)
+		set_irq_wake(flexcan->irq, 1);
+	else {
+		int ret;
+
+		plat_data = pdev->dev.platform_data;
+
+		if (plat_data && plat_data->xcvr_enable) {
+			ret = plat_data->xcvr_enable(pdev, 0);
+			if (ret)
+				return ret;
+		}
+		if (flexcan->io_reg) {
+			ret = regulator_disable(flexcan->io_reg);
+			if (ret)
+				return ret;
+		}
+		if (flexcan->core_reg) {
+			ret = regulator_disable(flexcan->core_reg);
+			if (ret)
+				return ret;
+		}
+		clk_disable(flexcan->clk);
+		if (plat_data && plat_data->inactive) {
+			plat_data->inactive(pdev);
+		}
+	}
+	return 0;
+}
+
+static int flexcan_resume(struct platform_device *pdev)
+{
+	int ret;
+	struct net_device *net = platform_get_drvdata(pdev);
+	struct flexcan_device *flexcan = netdev_priv(net);
+	struct flexcan_platform_data *plat_data;
+
+	if (!(net->flags & IFF_UP))
+		return 0;
+
+	if (flexcan->wakeup)
+		set_irq_wake(flexcan->irq, 0);
+	else {
+		plat_data = pdev->dev.platform_data;
+		if (plat_data && plat_data->active) {
+			ret = plat_data->active(pdev);
+			if (ret)
+				printk(KERN_ERR "%s: Failed activate hardware: %d\n",
+				       __func__, ret);
+		}
+		ret = clk_enable(flexcan->clk);
+		if (ret)
+			printk(KERN_ERR "%s: Failed to enable clock: %d\n",
+			       __func__, ret);
+
+		if (flexcan->core_reg) {
+			ret = regulator_enable(flexcan->core_reg);
+			if (ret)
+				printk(KERN_ERR "%s: Failed to enable core voltage: %d\n",
+				       __func__, ret);
+		}
+		if (flexcan->io_reg) {
+			ret = regulator_enable(flexcan->io_reg);
+			if (ret)
+				printk(KERN_ERR "%s: Failed to enable io voltage: %d\n",
+				       __func__, ret);
+		}
+
+		if (plat_data && plat_data->xcvr_enable) {
+			ret = plat_data->xcvr_enable(pdev, 1);
+			if (ret)
+				printk(KERN_ERR "%s: Failed to enable transceiver: %d\n",
+				       __func__, ret);
+		}
+	}
+	return 0;
+}
+#else
+#define flexcan_suspend		NULL
+#define flexcan_resume		NULL
+#endif
+
+static struct platform_driver flexcan_driver = {
+	.driver = {
+		.name = "mxc-flexcan",
+	},
+	.probe = flexcan_probe,
+	.remove = flexcan_remove,
+	.suspend = flexcan_suspend,
+	.resume = flexcan_resume,
+};
+
+static __init int flexcan_init(void)
+{
+	pr_info("Freescale FlexCAN Driver \n");
+	return platform_driver_register(&flexcan_driver);
+}
+
+static __exit void flexcan_exit(void)
+{
+	return platform_driver_unregister(&flexcan_driver);
+}
+
+module_init(flexcan_init);
+module_exit(flexcan_exit);
+
+MODULE_LICENSE("GPL");
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/net/can/flexcan.h linux-2.6.30-rc4-karo2/drivers/net/can/flexcan.h
--- linux-2.6.30-rc4-karo/drivers/net/can/flexcan.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30-rc4-karo2/drivers/net/can/flexcan.h	2009-07-06 15:46:51.000000000 +0200
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file flexcan.h
+ *
+ * @brief FlexCan definitions.
+ *
+ * @ingroup can
+ */
+
+#ifndef __CAN_FLEXCAN_H__
+#define __CAN_FLEXCAN_H__
+
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <linux/can.h>
+#include <linux/can/core.h>
+#include <linux/can/error.h>
+
+struct can_mb_cs {
+	unsigned int time_stamp:16;
+	unsigned int length:4;
+	unsigned int rtr:1;
+	unsigned int ide:1;
+	unsigned int srr:1;
+	unsigned int nouse1:1;
+	unsigned int code:4;
+	unsigned int nouse2:4;
+};
+
+#define CAN_MB_RX_INACTIVE	0x0
+#define CAN_MB_RX_EMPTY		0x4
+#define CAN_MB_RX_FULL		0x2
+#define CAN_MB_RX_OVERRUN	0x6
+#define CAN_MB_RX_BUSY		0x1
+
+#define CAN_MB_TX_INACTIVE	0x8
+#define CAN_MB_TX_ABORT		0x9
+#define CAN_MB_TX_ONCE		0xC
+#define CAN_MB_TX_REMOTE	0xA
+
+struct can_hw_mb {
+	union {
+		struct can_mb_cs cs;
+		unsigned int data;
+	} mb_cs;
+	unsigned int mb_id;
+	unsigned char mb_data[8];
+};
+
+#define CAN_HW_REG_MCR		0x00
+#define CAN_HW_REG_CTRL		0x04
+#define CAN_HW_REG_TIMER	0x08
+#define CAN_HW_REG_RXGMASK	0x10
+#define CAN_HW_REG_RX14MASK	0x14
+#define CAN_HW_REG_RX15MASK	0x18
+#define CAN_HW_REG_ECR		0x1C
+#define CAN_HW_REG_ESR		0x20
+#define CAN_HW_REG_IMASK2	0x24
+#define CAN_HW_REG_IMASK1	0x28
+#define CAN_HW_REG_IFLAG2	0x2C
+#define CAN_HW_REG_IFLAG1	0x30
+
+#define CAN_MB_BASE	0x0080
+#define CAN_RXMASK_BASE	0x0880
+#define CAN_FIFO_BASE	0xE0
+
+#define __MCR_MDIS		(1 << 31)
+#define __MCR_FRZ		(1 << 30)
+#define __MCR_FEN		(1 << 29)
+#define __MCR_HALT		(1 << 28)
+#define __MCR_NOTRDY		(1 << 27)
+#define __MCR_WAK_MSK		(1 << 26)
+#define __MCR_SOFT_RST		(1 << 25)
+#define __MCR_FRZ_ACK		(1 << 24)
+#define __MCR_SLF_WAK		(1 << 22)
+#define __MCR_WRN_EN		(1 << 21)
+#define __MCR_LPM_ACK		(1 << 20)
+#define __MCR_WAK_SRC		(1 << 19)
+#define __MCR_DOZE		(1 << 18)
+#define __MCR_SRX_DIS		(1 << 17)
+#define __MCR_BCC		(1 << 16)
+#define __MCR_LPRIO_EN		(1 << 13)
+#define __MCR_AEN		(1 << 12)
+#define __MCR_MAX_IDAM_OFFSET 	8
+#define __MCR_MAX_IDAM_MASK 	(0x3 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_IDAM_A	(0x0 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_IDAM_B	(0x1 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_IDAM_C	(0x2 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_IDAM_D	(0x3 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_MB_OFFSET 	0
+#define __MCR_MAX_MB_MASK 	(0x3F)
+
+#define __CTRL_PRESDIV_OFFSET	24
+#define __CTRL_PRESDIV_MASK	(0xFF << __CTRL_PRESDIV_OFFSET)
+#define __CTRL_RJW_OFFSET	22
+#define __CTRL_RJW_MASK		(0x3 << __CTRL_RJW_OFFSET)
+#define __CTRL_PSEG1_OFFSET	19
+#define __CTRL_PSEG1_MASK	(0x7 << __CTRL_PSEG1_OFFSET)
+#define __CTRL_PSEG2_OFFSET	16
+#define __CTRL_PSEG2_MASK	(0x7 << __CTRL_PSEG2_OFFSET)
+#define __CTRL_BOFF_MSK		(0x1 << 15)
+#define __CTRL_ERR_MSK		(0x1 << 14)
+#define __CTRL_CLK_SRC		(0x1 << 13)
+#define __CTRL_LPB		(0x1 << 12)
+#define __CTRL_TWRN_MSK		(0x1 << 11)
+#define __CTRL_RWRN_MSK		(0x1 << 10)
+#define __CTRL_SMP		(0x1 << 7)
+#define __CTRL_BOFF_REC		(0x1 << 6)
+#define __CTRL_TSYN		(0x1 << 5)
+#define __CTRL_LBUF		(0x1 << 4)
+#define __CTRL_LOM		(0x1 << 3)
+#define __CTRL_PROPSEG_OFFSET	0
+#define __CTRL_PROPSEG_MASK	(0x7)
+
+#define __ECR_TX_ERR_COUNTER(x) ((x) & 0xFF)
+#define __ECR_RX_ERR_COUNTER(x) (((x) >> 8) & 0xFF)
+#define __ECR_PASSIVE_THRESHOLD	128
+#define __ECR_ACTIVE_THRESHOLD	96
+
+#define __ESR_TWRN_INT		(0x1 << 17)
+#define __ESR_RWRN_INT		(0x1 << 16)
+#define __ESR_BIT1_ERR		(0x1 << 15)
+#define __ESR_BIT0_ERR		(0x1 << 14)
+#define __ESR_ACK_ERR		(0x1 << 13)
+#define __ESR_CRC_ERR		(0x1 << 12)
+#define __ESR_FRM_ERR		(0x1 << 11)
+#define __ESR_STF_ERR		(0x1 << 10)
+#define __ESR_TX_WRN		(0x1 << 9)
+#define __ESR_RX_WRN		(0x1 << 8)
+#define __ESR_IDLE		(0x1 << 7)
+#define __ESR_TXRX		(0x1 << 6)
+#define __ESR_FLT_CONF_OFF	4
+#define __ESR_FLT_CONF_MASK	(0x3 << __ESR_FLT_CONF_OFF)
+#define __ESR_BOFF_INT		(0x1 << 2)
+#define __ESR_ERR_INT		(0x1 << 1)
+#define __ESR_WAK_INT		(0x1)
+
+#define __ESR_INTERRUPTS	(__ESR_WAK_INT | __ESR_ERR_INT | \
+				__ESR_BOFF_INT | __ESR_TWRN_INT | \
+				__ESR_RWRN_INT)
+
+#define __FIFO_OV_INT		(1 << 7)
+#define __FIFO_WARN_INT		(1 << 6)
+#define __FIFO_RDY_INT		(1 << 5)
+
+#define FLEXCAN_MAX_FIFO_MB	8
+#define FLEXCAN_MAX_MB		64
+#define FLEXCAN_MAX_PRESDIV	256
+#define FLEXCAN_MAX_RJW		4
+#define FLEXCAN_MAX_PSEG1	8
+#define FLEXCAN_MAX_PSEG2	8
+#define FLEXCAN_MAX_PROPSEG	8
+#define FLEXCAN_MAX_BITRATE	1000000
+
+struct flexcan_device {
+	struct mutex mutex;
+	struct work_struct err_work;
+	struct work_struct mb_work;
+	void __iomem *io_base;
+	struct can_hw_mb __iomem *hwmb;
+	unsigned int __iomem *rx_mask;
+	int xmit_buffers;
+	unsigned int xmit_mb;
+	unsigned int bitrate;
+	/* word 1 */
+	unsigned int br_presdiv:8;
+	unsigned int br_rjw:2;
+	unsigned int br_propseg:3;
+	unsigned int br_pseg1:3;
+	unsigned int br_pseg2:3;
+	unsigned int maxmb:6;
+	unsigned int xmit_maxmb:6;
+	unsigned int rsrvd:1;
+
+	/* word 2 */
+	unsigned int fifo:1;
+	unsigned int wakeup:1;
+	unsigned int srx_dis:1;
+	unsigned int wak_src:1;
+	unsigned int bcc:1;
+	unsigned int lprio:1;
+	unsigned int abort:1;
+	unsigned int br_clksrc:1;
+	unsigned int loopback:1;
+	unsigned int smp:1;
+	unsigned int boff_rec:1;
+	unsigned int tsyn:1;
+	unsigned int listen:1;
+
+	unsigned int ext_msg:1;
+	unsigned int std_msg:1;
+
+	struct timer_list timer;
+	struct platform_device *dev;
+	struct regulator *core_reg;
+	struct regulator *io_reg;
+	struct clk *clk;
+	int irq;
+};
+#endif /* __CAN_FLEXCAN_H__ */
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/net/fec.c linux-2.6.30-rc4-karo2/drivers/net/fec.c
--- linux-2.6.30-rc4-karo/drivers/net/fec.c	2009-07-06 17:06:29.000000000 +0200
+++ linux-2.6.30-rc4-karo2/drivers/net/fec.c	2009-07-06 15:46:48.000000000 +0200
@@ -493,45 +493,6 @@ static inline void fec_enet_txbuf_put(st
 				   len, DMA_TO_DEVICE);
 }
 
-static void dump_packet(const char *prefix, const unsigned char *data, int len)
-{
-	if (dbg_lvl(3)) {
-		print_hex_dump_bytes(prefix, DUMP_PREFIX_OFFSET, data, len);
-	}
-}
-
-static void dump_tx_buffers(struct fec_enet_private *fep)
-{
-	cbd_t *bdp = fep->tx_bd_base;
-	int i;
-
-	printk(KERN_DEBUG "tx buffers: %u buffers\n", TX_RING_SIZE);
-	for (i = 0; i < TX_RING_SIZE; i++, bdp++) {
-		printk(KERN_DEBUG "  %p: %04x %04x %08x\n",
-		       bdp,
-		       bdp->cbd_sc,
-		       bdp->cbd_datlen,
-		       bdp->cbd_bufaddr);
-		print_hex_dump_bytes("tx buffers:", DUMP_PREFIX_ADDRESS, bdp, sizeof(cbd_t));
-	}
-}
-
-static void dump_rx_buffers(struct fec_enet_private *fep)
-{
-	cbd_t *bdp = fep->rx_bd_base;
-	int i;
-
-	printk(KERN_DEBUG "rx buffers: %lu buffers\n", RX_RING_SIZE);
-	for (i = 0; i < RX_RING_SIZE; i++, bdp++) {
-		printk(KERN_DEBUG "  %p: %04x %04x %08x\n",
-		       bdp,
-		       bdp->cbd_sc,
-		       bdp->cbd_datlen,
-		       bdp->cbd_bufaddr);
-		print_hex_dump_bytes("rx buffers:", DUMP_PREFIX_ADDRESS, bdp, sizeof(cbd_t));
-	}
-}
-
 static int
 fec_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
@@ -543,12 +504,11 @@ fec_enet_start_xmit(struct sk_buff *skb,
 	if (!fep->linkstatus) {
 		DBG(0, "%s: Cannot send packet; link is down\n", __FUNCTION__);
 		/* Link is down or autonegotiation is in progress. */
-		return 1;
+		return NETDEV_TX_BUSY;
 	}
 
 	spin_lock_irqsave(&fep->lock, flags);
 
-	//WARN_ON(fec_reg_read(fep, FEC_TDAR) & TDAR_BUSY);
 	fec_enet_cbd_get(fep);
 
 	/* Fill in a Tx ring entry */
@@ -563,7 +523,7 @@ fec_enet_start_xmit(struct sk_buff *skb,
 		printk("%s: tx queue full!.\n", dev->name);
 		fec_enet_cbd_put(fep);
 		spin_unlock_irqrestore(&fep->lock, flags);
-		return 1;
+		return NETDEV_TX_BUSY;
 	}
 #endif
 	/* Clear all of the status flags.
@@ -574,7 +534,6 @@ fec_enet_start_xmit(struct sk_buff *skb,
 	*/
 	bdp->cbd_datlen = skb->len;
 
-	dump_packet("sending packet:", skb->data, skb->len);
 	/*
 	 *	On some FEC implementations data must be aligned on
 	 *	4-byte boundaries. Use bounce buffers to copy data
@@ -621,18 +580,13 @@ fec_enet_start_xmit(struct sk_buff *skb,
 
 	fep->cur_tx = bdp;
 	fec_enet_cbd_put(fep);
-#if 0
-	if (dbg_lvl(3)) {
-		dump_tx_buffers(fep);
-		dump_rx_buffers(fep);
-	}
-#endif
+
 	/* Trigger transmission start */
 	fec_reg_write(fep, FEC_TDAR, DONT_CARE);
 
 	spin_unlock_irqrestore(&fep->lock, flags);
 
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 static void
@@ -758,7 +712,6 @@ fec_enet_tx(struct net_device *dev)
 
 	spin_lock(&fep->lock);
 
-	//WARN_ON(fec_reg_read(fep, FEC_TDAR) & TDAR_BUSY);
 	fec_enet_cbd_get(fep);
 	bdp = fep->dirty_tx;
 
@@ -795,8 +748,6 @@ fec_enet_tx(struct net_device *dev)
 		if (status & BD_ENET_TX_DEF)
 			fep->stats.collisions++;
 
-		dump_packet("sent packet:", fep->tx_skbuff[fep->skb_dirty]->data,
-			    fep->tx_skbuff[fep->skb_dirty]->len);
 		/* Free the sk buffer associated with this last transmit.
 		 */
 		fec_free_skb(fep, bdp, &fep->tx_skbuff[fep->skb_dirty]);
@@ -895,32 +846,14 @@ while (!((status = bdp->cbd_sc) & BD_ENE
 		fep->stats.rx_errors++;
 		fep->stats.rx_frame_errors++;
 		DBG(0, "%s: Collision detected; dropping packet\n", __FUNCTION__);
-		if (bdp->cbd_datlen > PKT_MAXBUF_SIZE) {
-			printk(KERN_ERR "invalid packet size %u; max %u\n", bdp->cbd_datlen,
-			       PKT_MAXBUF_SIZE);
-		} else {
-			fec_enet_rxbuf_get(fep, bdp, bdp->cbd_datlen);
-			dump_packet("received packet:",
-				    fep->rx_skbuff[rx_index]->data, bdp->cbd_datlen);
-			fec_enet_rxbuf_put(fep, bdp, bdp->cbd_datlen);
-		}
 		goto rx_processing_done;
 	}
-#if 1
+
 	if (!fep->opened) {
 		DBG(0, "%s: Driver not opened; ignoring packet\n", __FUNCTION__);
-		if (bdp->cbd_datlen > PKT_MAXBUF_SIZE) {
-			printk(KERN_ERR "invalid packet size %u; max %u\n", bdp->cbd_datlen,
-			       PKT_MAXBUF_SIZE);
-		} else {
-			fec_enet_rxbuf_get(fep, bdp, bdp->cbd_datlen);
-			dump_packet("received packet:",
-				    fep->rx_skbuff[rx_index]->data, bdp->cbd_datlen);
-			fec_enet_rxbuf_put(fep, bdp, bdp->cbd_datlen);
-		}
 		goto rx_processing_done;
 	}
-#endif
+
 	/* Process the incoming frame.
 	 */
 	fep->stats.rx_packets++;
@@ -971,12 +904,6 @@ while (!((status = bdp->cbd_sc) & BD_ENE
 		netif_rx(skb);
 	}
   rx_processing_done:
-#if 0
-	if (dbg_lvl(3)) {
-		dump_rx_buffers(fep);
-		dump_tx_buffers(fep);
-	}
-#endif
 	/* Clear the status flags for this buffer.
 	*/
 	status &= ~BD_ENET_RX_STATS;
@@ -2948,8 +2875,6 @@ static int __devexit fec_enet_remove(str
 	struct fec_enet_private *fep = netdev_priv(dev);
 
 	unregister_netdev(dev);
-	free_netdev(dev);
-
 #ifdef CONFIG_PHYLIB
 	if (fep->mii != NULL) {
 		kfree(fep->mii->irq);
@@ -2974,6 +2899,7 @@ static int __devexit fec_enet_remove(str
 	if (fep->res_mem2 != NULL) {
 		release_resource(fep->res_mem2);
 	}
+	free_netdev(dev);
 	return 0;
 }
 
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/usb/Kconfig linux-2.6.30-rc4-karo2/drivers/usb/Kconfig
--- linux-2.6.30-rc4-karo/drivers/usb/Kconfig	2009-06-02 17:13:42.000000000 +0200
+++ linux-2.6.30-rc4-karo2/drivers/usb/Kconfig	2009-06-29 10:49:52.000000000 +0200
@@ -57,6 +57,7 @@ config USB_ARCH_HAS_EHCI
 	default y if PPC_83xx
 	default y if SOC_AU1200
 	default y if ARCH_IXP4XX
+	default y if ARCH_MXC
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/usb/host/Kconfig linux-2.6.30-rc4-karo2/drivers/usb/host/Kconfig
--- linux-2.6.30-rc4-karo/drivers/usb/host/Kconfig	2009-06-02 17:14:19.000000000 +0200
+++ linux-2.6.30-rc4-karo2/drivers/usb/host/Kconfig	2009-07-06 15:47:38.000000000 +0200
@@ -106,6 +106,37 @@ config USB_OXU210HP_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called oxu210hp-hcd.
 
+config USB_EHCI_MXC
+	bool "Support for Freescale on-chip EHCI USB controller"
+	depends on USB_EHCI_HCD && ARCH_MXC
+	select USB_EHCI_ROOT_HUB_TT
+	---help---
+	  Variation of ARC USB block used in some Freescale chips.
+
+config ARCH_MXC_EHCI_USBH1
+	bool "Enable USB on USBH1 port"
+	depends on USB_EHCI_MXC && ARCH_MXC_HAS_USBH1
+
+config ARCH_MXC_EHCI_USBH2
+	bool "Enable USB on USBH2 port"
+	depends on USB_EHCI_MXC && ARCH_MXC_HAS_USBH2
+
+config ARCH_MXC_EHCI_USBOTG
+	bool "Enable USB on USBOTG port"
+	depends on USB_EHCI_MXC && ARCH_MXC_HAS_USBOTG
+
+config ARCH_MXC_HAS_USBH1
+	bool
+	depends on USB_EHCI_MXC
+
+config ARCH_MXC_HAS_USBH2
+	bool
+	depends on USB_EHCI_MXC
+
+config ARCH_MXC_HAS_USBOTG
+	bool
+	depends on USB_EHCI_MXC
+
 config USB_ISP116X_HCD
 	tristate "ISP116X HCD support"
 	depends on USB
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/usb/host/ehci-hcd.c linux-2.6.30-rc4-karo2/drivers/usb/host/ehci-hcd.c
--- linux-2.6.30-rc4-karo/drivers/usb/host/ehci-hcd.c	2009-06-02 17:14:21.000000000 +0200
+++ linux-2.6.30-rc4-karo2/drivers/usb/host/ehci-hcd.c	2009-07-01 11:30:25.000000000 +0200
@@ -1047,6 +1047,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_MXC
+#include "ehci-mxc.c"
+#define PLATFORM_DRIVER		ehci_mxc_driver
+#endif
+
 #ifdef CONFIG_SOC_AU1200
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/usb/host/ehci-mxc.c linux-2.6.30-rc4-karo2/drivers/usb/host/ehci-mxc.c
--- linux-2.6.30-rc4-karo/drivers/usb/host/ehci-mxc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30-rc4-karo2/drivers/usb/host/ehci-mxc.c	2009-07-01 11:31:58.000000000 +0200
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 2008 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <mach/mxc_ehci.h>
+
+/* called during probe() after chip reset completes */
+static int ehci_mxc_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	/* EHCI registers start at offset 0x100 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+	    HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	hcd->has_tt = 1;
+
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+	ehci_port_power(ehci, 0);
+	return 0;
+}
+
+static const struct hc_driver ehci_mxc_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Freescale On-Chip EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_mxc_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+};
+
+static int ehci_mxc_drv_probe(struct platform_device *pdev)
+{
+	struct mxc_usbh_platform_data *pdata = pdev->dev.platform_data;
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int irq, ret, temp;
+	struct clk *usbclk, *ahbclk;
+
+	dev_info(&pdev->dev, "initializing i.MX USB Controller\n");
+
+	/* Need platform data for setup */
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+
+	hcd = usb_create_hcd(&ehci_mxc_hc_driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_err(&pdev->dev, "error mapping memory\n");
+		ret = -EFAULT;
+		goto err2;
+	}
+
+#if 0
+	ahbclk = clk_get(NULL, "usb_ahb_clk");
+	if (IS_ERR(ahbclk)) {
+		ret = PTR_ERR(ahbclk);
+		printk(KERN_ERR "Failed to get usb_ahb_clk: %d\n", ret);
+		goto err3;
+	}
+	clk_enable(ahbclk);
+#endif
+	usbclk = clk_get(&pdev->dev, "usb");
+	if (IS_ERR(usbclk)) {
+		ret = PTR_ERR(usbclk);
+		printk(KERN_ERR "Failed to get usb_clk: %d\n", ret);
+		goto err4;
+	}
+	clk_enable(usbclk);
+
+	if (pdata->init) {
+		ret = pdata->init(pdev);
+		if (ret) {
+			dev_err(&pdev->dev, "platform init failed\n");
+			goto err5;
+		}
+	}
+
+	/* Set to Host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | 0x3, hcd->regs + 0x1a8);
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (ret)
+		goto err6;
+
+	platform_set_drvdata(pdev, hcd);
+	clk_put(usbclk);
+
+	return 0;
+err6:
+	if (pdata->exit)
+		pdata->exit(pdev);
+err5:
+	clk_disable(usbclk);
+	clk_put(usbclk);
+err4:
+#if 0
+	clk_disable(ahbclk);
+	clk_put(ahbclk);
+#endif
+err3:
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+static int ehci_mxc_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct mxc_usbh_platform_data *pdata = pdev->dev.platform_data;
+	struct clk *usbclk;
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	platform_set_drvdata(pdev, NULL);
+
+	if (pdata->exit)
+		pdata->exit(pdev);
+
+	usbclk = clk_get(&pdev->dev, "usb");
+	if (!IS_ERR(usbclk)) {
+		clk_disable(usbclk);
+		clk_put(usbclk);
+	}
+#if 0
+	ahbclk = clk_get(NULL, "usb_ahb_clk");
+	if (!IS_ERR(ahbclk)) {
+		clk_disable(ahbclk);
+		clk_put(ahbclk);
+	}
+#endif
+	return 0;
+}
+
+MODULE_ALIAS("platform:mxc-ehci");
+
+static struct platform_driver ehci_mxc_driver = {
+	.probe = ehci_mxc_drv_probe,
+	.remove = ehci_mxc_drv_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.driver = {
+		   .name = "mxc-ehci",
+	},
+};
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/drivers/video/imxfb.c linux-2.6.30-rc4-karo2/drivers/video/imxfb.c
--- linux-2.6.30-rc4-karo/drivers/video/imxfb.c	2009-06-02 18:58:52.000000000 +0200
+++ linux-2.6.30-rc4-karo2/drivers/video/imxfb.c	2009-07-06 15:47:45.000000000 +0200
@@ -56,9 +56,9 @@
 #define VPW_VPW(x)	((x) & 0x3ff)
 
 #define LCDC_CPOS	0x0C
-#define CPOS_CC1	(1<<31)
-#define CPOS_CC0	(1<<30)
-#define CPOS_OP		(1<<28)
+#define CPOS_CC1	(1 << 31)
+#define CPOS_CC0	(1 << 30)
+#define CPOS_OP		(1 << 28)
 #define CPOS_CXP(x)	(((x) & 3ff) << 16)
 
 #ifdef CONFIG_ARCH_MX1
@@ -68,7 +68,7 @@
 #endif
 
 #define LCDC_LCWHB	0x10
-#define LCWHB_BK_EN	(1<<31)
+#define LCWHB_BK_EN	(1 << 31)
 #define LCWHB_CW(w)	(((w) & 0x1f) << 24)
 #define LCWHB_CH(h)	(((h) & 0x1f) << 16)
 #define LCWHB_BD(x)	((x) & 0xff)
@@ -112,22 +112,22 @@
 #define LCDC_RMCR	0x34
 
 #ifdef CONFIG_ARCH_MX1
-#define RMCR_LCDC_EN	(1<<1)
+#define RMCR_LCDC_EN	(1 << 1)
 #else
 #define RMCR_LCDC_EN	0
 #endif
 
-#define RMCR_SELF_REF	(1<<0)
+#define RMCR_SELF_REF	(1 << 0)
 
 #define LCDC_LCDICR	0x38
-#define LCDICR_INT_SYN	(1<<2)
-#define LCDICR_INT_CON	(1)
+#define LCDICR_INT_SYN	(1 << 2)
+#define LCDICR_INT_CON	1
 
 #define LCDC_LCDISR	0x40
-#define LCDISR_UDR_ERR	(1<<3)
-#define LCDISR_ERR_RES	(1<<2)
-#define LCDISR_EOF	(1<<1)
-#define LCDISR_BOF	(1<<0)
+#define LCDISR_UDR_ERR	(1 << 3)
+#define LCDISR_ERR_RES	(1 << 2)
+#define LCDISR_EOF	(1 << 1)
+#define LCDISR_BOF	(1 << 0)
 
 /*
  * These are the bitfields for each
@@ -232,11 +232,11 @@ static int imxfb_setpalettereg(u_int reg
 	struct imxfb_info *fbi = info->par;
 	u_int val, ret = 1;
 
-#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+#define CNVT_TOHW(val,width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
 	if (regno < fbi->palette_size) {
-		val = (CNVT_TOHW(red, 4) << 8) |
-		      (CNVT_TOHW(green,4) << 4) |
-		      CNVT_TOHW(blue,  4);
+		val = (CNVT_TOHW(red, 6) << 12) |
+			(CNVT_TOHW(green, 6) << 6) |
+			CNVT_TOHW(blue,  6);
 
 		writel(val, fbi->regs + 0x800 + (regno << 2));
 		ret = 0;
@@ -265,7 +265,7 @@ static int imxfb_setcolreg(u_int regno, 
 
 	/*
 	 * If greyscale is true, then we convert the RGB value
-	 * to greyscale no mater what visual we are using.
+	 * to greyscale no matter what visual we are using.
 	 */
 	if (info->var.grayscale)
 		red = green = blue = (19595 * red + 38470 * green +
@@ -527,7 +527,7 @@ static int imxfb_activate_var(struct fb_
 	if (--pcr > 0x3F) {
 		pcr = 0x3F;
 		printk(KERN_WARNING "Must limit pixel clock to %uHz\n",
-				lcd_clk / pcr);
+				lcd_clk / pcr + 1);
 	}
 
 	/* add sync polarities */
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/include/linux/usb/xcvr.h linux-2.6.30-rc4-karo2/include/linux/usb/xcvr.h
--- linux-2.6.30-rc4-karo/include/linux/usb/xcvr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30-rc4-karo2/include/linux/usb/xcvr.h	2009-07-01 11:32:10.000000000 +0200
@@ -0,0 +1,71 @@
+#ifndef __LINUX_USB_XCVR_H
+#define __LINUX_USB_XCVR_H
+
+struct usb_xcvr;
+
+struct usb_xcvr_access_ops {
+	int (*read)(struct usb_xcvr *xcvr, u32 reg);
+	int (*write)(struct usb_xcvr *xcvr, u32 val, u32 reg);
+};
+
+struct usb_xcvr_driver {
+	int  (*init)(struct usb_xcvr *xcvr);
+	void (*shutdown)(struct usb_xcvr *xcvr);
+	int  (*set_vbus)(struct usb_xcvr *xcvr, bool en);
+};
+
+struct usb_xcvr {
+	struct usb_xcvr_access_ops 	*access;
+	struct usb_xcvr_driver		*driver;
+	void __iomem			*access_priv;
+
+	/* only set this if you don't want the lowlevel driver to
+	 * handle this */
+	int (*set_vbus)(struct usb_xcvr *xcvr, bool en);
+};
+
+static inline int usb_xcvr_init(struct usb_xcvr *xcvr)
+{
+	if (xcvr->driver && xcvr->driver->init)
+		return xcvr->driver->init(xcvr);
+
+	return -EINVAL;
+}
+
+static inline void usb_xcvr_shutdown(struct usb_xcvr *xcvr)
+{
+	if (xcvr->driver && xcvr->driver->shutdown)
+		xcvr->driver->shutdown(xcvr);
+}
+
+static inline int usb_xcvr_set_vbus(struct usb_xcvr *xcvr, bool en)
+{
+	if (xcvr->set_vbus)
+		return xcvr->set_vbus(xcvr, en);
+
+	if (xcvr->driver && xcvr->driver->set_vbus)
+		return xcvr->driver->set_vbus(xcvr, en);
+
+	return -EINVAL;
+}
+
+/* lowlowel access helpers */
+
+static inline int usb_xcvr_read(struct usb_xcvr *xcvr, u32 reg)
+{
+	if (xcvr->access->read)
+		return xcvr->access->read(xcvr, reg);
+
+	return -EINVAL;
+}
+
+static inline int usb_xcvr_write(struct usb_xcvr *xcvr, u32 val, u32 reg)
+{
+	if (xcvr->access->write)
+		return xcvr->access->write(xcvr, val, reg);
+
+	return -EINVAL;
+}
+
+#endif /* __LINUX_USB_XCVR_H */
+
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/net/can/bcm.c linux-2.6.30-rc4-karo2/net/can/bcm.c
--- linux-2.6.30-rc4-karo/net/can/bcm.c	2009-06-02 17:37:41.000000000 +0200
+++ linux-2.6.30-rc4-karo2/net/can/bcm.c	2009-07-01 11:30:52.000000000 +0200
@@ -75,6 +75,7 @@ static __initdata const char banner[] = 
 MODULE_DESCRIPTION("PF_CAN broadcast manager protocol");
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_ALIAS("can-proto-2");
 
 /* easy access to can_frame payload */
 static inline u64 GET_U64(const struct can_frame *cp)
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/net/can/raw.c linux-2.6.30-rc4-karo2/net/can/raw.c
--- linux-2.6.30-rc4-karo/net/can/raw.c	2009-06-02 17:37:42.000000000 +0200
+++ linux-2.6.30-rc4-karo2/net/can/raw.c	2009-07-01 11:30:58.000000000 +0200
@@ -62,6 +62,7 @@ static __initdata const char banner[] =
 MODULE_DESCRIPTION("PF_CAN raw protocol");
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Urs Thuermann <urs.thuermann@volkswagen.de>");
+MODULE_ALIAS("can-proto-1");
 
 #define MASK_ALL 0
 
diff -purN -X linux-2.6.30-rc4-karo/Documentation/dontdiff linux-2.6.30-rc4-karo/net/socket.c linux-2.6.30-rc4-karo2/net/socket.c
--- linux-2.6.30-rc4-karo/net/socket.c	2009-06-02 17:37:00.000000000 +0200
+++ linux-2.6.30-rc4-karo2/net/socket.c	2009-07-01 11:30:42.000000000 +0200
@@ -527,6 +527,8 @@ void sock_release(struct socket *sock)
 	if (sock->ops) {
 		struct module *owner = sock->ops->owner;
 
+		if (sock->sk)
+			sock_orphan(sock->sk);
 		sock->ops->release(sock);
 		sock->ops = NULL;
 		module_put(owner);
