Index: linux-2.6.30-karo/arch/arm/mach-mx2/clock_imx25.c
===================================================================
--- linux-2.6.30-karo.orig/arch/arm/mach-mx2/clock_imx25.c	2009-06-22 16:51:38.000000000 +0200
+++ linux-2.6.30-karo/arch/arm/mach-mx2/clock_imx25.c	2009-06-23 12:07:34.000000000 +0200
@@ -171,7 +171,7 @@
 #define MXC_CCM_CGCR2_SPBA_OFFSET		(42 - 32)
 #define MXC_CCM_CGCR2_SSI1_OFFSET		(43 - 32)
 #define MXC_CCM_CGCR2_SSI2_OFFSET		(44 - 32)
-#define MXC_CCM_CGCR2_TCHSCRN_OFFSET		(45 - 32)
+#define MXC_CCM_CGCR2_TSC_OFFSET		(45 - 32)
 #define MXC_CCM_CGCR2_UART1_OFFSET		(46 - 32)
 #define MXC_CCM_CGCR2_UART2_OFFSET		(47 - 32)
 #define MXC_CCM_CGCR2_UART3_OFFSET		(48 - 32)
@@ -615,7 +615,7 @@
 
 /* Bottom-level clocks */
 
-struct clk usbotg_clk = {
+static struct clk usbotg_clk = {
 	.id = 0,
 	.parent = &ahb_clk,
 	.enable = _clk_enable,
@@ -624,16 +624,27 @@
 	.disable = _clk_disable,
 };
 
-struct clk rtic_clk = {
-	.id = 0,
-	.parent = &ahb_clk,
-	.enable = _clk_enable,
-	.enable_reg = MXC_CCM_CGCR0,
-	.enable_shift = MXC_CCM_CGCR0_HCLK_RTIC_OFFSET,
-	.disable = _clk_disable,
+static struct clk rtic_clk[] = {
+	{
+		.id = 0,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = MXC_CCM_CGCR2,
+		.enable_shift = MXC_CCM_CGCR2_RTIC_OFFSET,
+		.disable = _clk_disable,
+		.secondary = &rtic_clk[1],
+	},
+	{
+		.id = 0,
+		.parent = &ahb_clk,
+		.enable = _clk_enable,
+		.enable_reg = MXC_CCM_CGCR0,
+		.enable_shift = MXC_CCM_CGCR0_HCLK_RTIC_OFFSET,
+		.disable = _clk_disable,
+	},
 };
 
-struct clk emi_clk = {
+static struct clk emi_clk = {
 	.id = 0,
 	.parent = &ahb_clk,
 	.enable = _clk_enable,
@@ -642,7 +653,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk brom_clk = {
+static struct clk brom_clk = {
 	.id = 0,
 	.parent = &ahb_clk,
 	.enable = _clk_enable,
@@ -813,12 +824,12 @@
 	},
 };
 
-struct clk nfc_clk = {
+static struct clk nfc_clk = {
 	.id = 0,
 	.parent = &per_clk[8],
 };
 
-struct clk audmux_clk = {
+static struct clk audmux_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -827,7 +838,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk ata_clk[] = {
+static struct clk ata_clk[] = {
 	{
 		.id = 0,
 		.parent = &ipg_clk,
@@ -847,7 +858,7 @@
 	},
 };
 
-struct clk can_clk[] = {
+static struct clk can_clk[] = {
 	{
 		.id = 0,
 		.parent = &ipg_clk,
@@ -866,7 +877,7 @@
 	},
 };
 
-struct clk csi_clk[] = {
+static struct clk csi_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[0],
@@ -891,7 +902,7 @@
 	},
 };
 
-struct clk cspi_clk[] = {
+static struct clk cspi_clk[] = {
 	{
 		.id = 0,
 		.parent = &ipg_clk,
@@ -918,7 +929,7 @@
 	},
 };
 
-struct clk dryice_clk = {
+static struct clk dryice_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -927,7 +938,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk ect_clk = {
+static struct clk ect_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -936,7 +947,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk epit1_clk[] = {
+static struct clk epit1_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[1],
@@ -952,7 +963,7 @@
 	},
 };
 
-struct clk epit2_clk[] = {
+static struct clk epit2_clk[] = {
 	{
 		.id = 1,
 		.parent = &per_clk[1],
@@ -968,7 +979,7 @@
 	},
 };
 
-struct clk esai_clk[] = {
+static struct clk esai_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[2],
@@ -993,7 +1004,7 @@
 	},
 };
 
-struct clk esdhc1_clk[] = {
+static struct clk esdhc1_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[3],
@@ -1018,7 +1029,7 @@
 	},
 };
 
-struct clk esdhc2_clk[] = {
+static struct clk esdhc2_clk[] = {
 	{
 		.id = 1,
 		.parent = &per_clk[4],
@@ -1043,7 +1054,7 @@
 	},
 };
 
-struct clk fec_clk[] = {
+static struct clk fec_clk[] = {
 	{
 		.id = 0,
 		.parent = &ipg_clk,
@@ -1063,7 +1074,7 @@
 	},
 };
 
-struct clk gpio_clk[] = {
+static struct clk gpio_clk[] = {
 	{
 		.id = 0,
 		.parent = &ipg_clk,
@@ -1154,7 +1165,7 @@
 	},
 };
 
-struct clk i2c_clk[] = {
+static struct clk i2c_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[6],
@@ -1169,7 +1180,7 @@
 	},
 };
 
-struct clk iim_clk = {
+static struct clk iim_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -1178,7 +1189,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk iomuxc_clk = {
+static struct clk iomuxc_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -1187,7 +1198,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk kpp_clk = {
+static struct clk kpp_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -1196,7 +1207,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk lcdc_clk[] = {
+static struct clk lcdc_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[7],
@@ -1221,7 +1232,7 @@
 	},
 };
 
-struct clk owire_clk[] = {
+static struct clk owire_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[9],
@@ -1237,7 +1248,7 @@
 	},
 };
 
-struct clk pwm1_clk[] = {
+static struct clk pwm1_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[10],
@@ -1253,7 +1264,7 @@
 	},
 };
 
-struct clk pwm2_clk[] = {
+static struct clk pwm2_clk[] = {
 	{
 		.id = 1,
 		.parent = &per_clk[10],
@@ -1269,7 +1280,7 @@
 	},
 };
 
-struct clk pwm3_clk[] = {
+static struct clk pwm3_clk[] = {
 	{
 		.id = 2,
 		.parent = &per_clk[10],
@@ -1285,7 +1296,7 @@
 	},
 };
 
-struct clk pwm4_clk[] = {
+static struct clk pwm4_clk[] = {
 	{
 		.id = 3,
 		.parent = &per_clk[10],
@@ -1301,7 +1312,7 @@
 	},
 };
 
-struct clk rngb_clk = {
+static struct clk rngb_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -1310,7 +1321,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk scc_clk = {
+static struct clk scc_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -1319,7 +1330,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk sdma_clk[] = {
+static struct clk sdma_clk[] = {
 	{
 		.id = 0,
 		.parent = &ipg_clk,
@@ -1339,7 +1350,7 @@
 	},
 };
 
-struct clk sim1_clk[] = {
+static struct clk sim1_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[11],
@@ -1355,7 +1366,7 @@
 	},
 };
 
-struct clk sim2_clk[] = {
+static struct clk sim2_clk[] = {
 	{
 		.id = 1,
 		.parent = &per_clk[12],
@@ -1371,7 +1382,7 @@
 	},
 };
 
-struct clk slcdc_clk[] = {
+static struct clk slcdc_clk[] = {
 	{
 		.id = 0,
 		.parent = &ipg_clk,
@@ -1391,7 +1402,7 @@
 	},
 };
 
-struct clk spba_clk = {
+static struct clk spba_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -1400,7 +1411,7 @@
 	.disable = _clk_disable,
 };
 
-struct clk ssi1_clk[] = {
+static struct clk ssi1_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[13],
@@ -1416,7 +1427,7 @@
 	},
 };
 
-struct clk ssi2_clk[] = {
+static struct clk ssi2_clk[] = {
 	{
 		.id = 1,
 		.parent = &per_clk[14],
@@ -1432,16 +1443,16 @@
 	},
 };
 
-struct clk tchscrn_clk = {
+static struct clk tsc_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
 	.enable_reg = MXC_CCM_CGCR2,
-	.enable_shift = MXC_CCM_CGCR2_TCHSCRN_OFFSET,
+	.enable_shift = MXC_CCM_CGCR2_TSC_OFFSET,
 	.disable = _clk_disable,
 };
 
-struct clk uart1_clk[] = {
+static struct clk uart1_clk[] = {
 	{
 		.id = 0,
 		.parent = &per_clk[15],
@@ -1457,7 +1468,7 @@
 	},
 };
 
-struct clk uart2_clk[] = {
+static struct clk uart2_clk[] = {
 	{
 		.id = 1,
 		.parent = &per_clk[15],
@@ -1473,7 +1484,7 @@
 	},
 };
 
-struct clk uart3_clk[] = {
+static struct clk uart3_clk[] = {
 	{
 		.id = 2,
 		.parent = &per_clk[15],
@@ -1489,7 +1500,7 @@
 	},
 };
 
-struct clk uart4_clk[] = {
+static struct clk uart4_clk[] = {
 	{
 		.id = 3,
 		.parent = &per_clk[15],
@@ -1505,7 +1516,7 @@
 	},
 };
 
-struct clk uart5_clk[] = {
+static struct clk uart5_clk[] = {
 	{
 		.id = 4,
 		.parent = &per_clk[15],
@@ -1521,7 +1532,7 @@
 	},
 };
 
-struct clk wdog_clk = {
+static struct clk wdog_clk = {
 	.id = 0,
 	.parent = &ipg_clk,
 	.enable = _clk_enable,
@@ -1600,6 +1611,7 @@
 	.set_rate = _clk_usb_set_rate,
 	.round_rate = _clk_usb_round_rate,
 	.set_parent = _clk_usb_set_parent,
+	.secondary = &usbotg_clk,
 };
 
 /* CLKO */
@@ -1714,7 +1726,8 @@
 	_REGISTER_CLOCK("mxc_nand.0", NULL, nfc_clk)
 	_REGISTER_CLOCK(NULL, "audmux", audmux_clk)
 	_REGISTER_CLOCK(NULL, "ata", ata_clk[0])
-	_REGISTER_CLOCK(NULL, "can", can_clk[0])
+	_REGISTER_CLOCK("mxc-can.0", NULL, can_clk[0])
+	_REGISTER_CLOCK("mxc-can.1", NULL, can_clk[1])
 	_REGISTER_CLOCK(NULL, "csi", csi_clk[0])
 	_REGISTER_CLOCK(NULL, "cspi.0", cspi_clk[0])
 	_REGISTER_CLOCK(NULL, "cspi.1", cspi_clk[1])
@@ -1755,7 +1768,7 @@
 	_REGISTER_CLOCK(NULL, "spba", spba_clk)
 	_REGISTER_CLOCK(NULL, "ssi1", ssi1_clk[0])
 	_REGISTER_CLOCK(NULL, "ssi2", ssi2_clk[0])
-	_REGISTER_CLOCK(NULL, "tchscrn", tchscrn_clk)
+	_REGISTER_CLOCK("mxc-tsadcc.0", NULL, tsc_clk)
 	_REGISTER_CLOCK("imx-uart.0", NULL, uart1_clk[0])
 	_REGISTER_CLOCK("imx-uart.1", NULL, uart2_clk[0])
 	_REGISTER_CLOCK("imx-uart.2", NULL, uart3_clk[0])
Index: linux-2.6.30-karo/arch/arm/mach-mx2/karo-tx25.c
===================================================================
--- linux-2.6.30-karo.orig/arch/arm/mach-mx2/karo-tx25.c	2009-06-23 13:46:03.000000000 +0200
+++ linux-2.6.30-karo/arch/arm/mach-mx2/karo-tx25.c	2009-06-23 15:04:16.000000000 +0200
@@ -69,6 +69,7 @@
 //#include <mach/ulpi.h>
 //#include <mach/mxc_ehci.h>
 //#include <mach/board-tx25.h>
+#include <mach/mxc_tsadcc.h>
 
 #include "crm_regs.h"
 #include "devices.h"
@@ -829,6 +830,39 @@
 #endif
 #endif
 
+#if defined(CONFIG_TOUCHSCREEN_MXC_TSADCC) || defined(CONFIG_TOUCHSCREEN_MXC_TSADCC_MODULE)
+static struct resource mxc_tsadcc_resources[] = {
+	{
+		.start = TSC_BASE_ADDR,
+		.end = TSC_BASE_ADDR + 0x85f,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_TSC,
+		.end = MXC_INT_TSC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct mxc_tsadcc_pdata mxc_tsadcc_pdata = {
+	.pen_debounce_time = 32,
+	.intref = 1,
+	.adc_clk = 1666667,
+	.tsc_mode = MXC_TSC_4WIRE,
+	.hsyncen = 0,
+};
+
+static struct platform_device mxc_tsadcc_device = {
+	.id = 0,
+	.name = "mxc-tsadcc",
+	.num_resources = ARRAY_SIZE(mxc_tsadcc_resources),
+	.resource = mxc_tsadcc_resources,
+	.dev = {
+		.platform_data = &mxc_tsadcc_pdata,
+	},
+};
+#endif
+
 struct platform_dev_list {
 	struct platform_device *pdev;
 	int flag;
@@ -851,6 +885,9 @@
 #if defined(CONFIG_MXC_VPU) || defined(CONFIG_MXC_VPU_MODULE)
 	{ .pdev = &mxc_vpu_device, .flag = 1, },
 #endif
+#if defined(CONFIG_TOUCHSCREEN_MXC_TSADCC) || defined(CONFIG_TOUCHSCREEN_MXC_TSADCC_MODULE)
+	{ .pdev = &mxc_tsadcc_device, .flag = 1, },
+#endif
 };
 #define TX25_NUM_DEVICES		ARRAY_SIZE(tx25_devices)
 
Index: linux-2.6.30-karo/arch/arm/plat-mxc/include/mach/mxc_tsadcc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-karo/arch/arm/plat-mxc/include/mach/mxc_tsadcc.h	2009-06-23 13:46:20.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ *  Freescale i.MX25 Touch Screen Driver
+ *
+ *  Copyright (c) 2009 Lothar Wassmann <LW@KARO-electronics.de>
+ *
+ * Based on code from Freescale BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+typedef enum {
+	MXC_TSC_4WIRE,
+	MXC_TSC_5WIRE,
+} mxc_tsc_mode;
+
+struct mxc_tsadcc_pdata {
+	int pen_debounce_time;	/* 0: disable debounce;
+				 * 1..128: # of ADC clock cycles / 8 */
+	unsigned int intref:1,	/* 0|1: internal reference disabled|enabled */
+		     hsyncen:1;	/* synchronize measurements with LCD HSYNC */
+	unsigned int r_xplate;	/* resistance (in Ohms) of X plate
+				 * (required for pressure measurement */
+	int adc_clk;		/* ADC clock frequency in Hz (max. 1750000);
+				 * <= 0: use default (1666667) */
+	mxc_tsc_mode tsc_mode;	/* select 4 wire or 5 wire mode */
+};
Index: linux-2.6.30-karo/drivers/input/touchscreen/Kconfig
===================================================================
--- linux-2.6.30-karo.orig/drivers/input/touchscreen/Kconfig	2009-06-23 13:46:03.000000000 +0200
+++ linux-2.6.30-karo/drivers/input/touchscreen/Kconfig	2009-06-23 13:46:20.000000000 +0200
@@ -287,6 +287,18 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called atmel_tsadcc.
 
+config TOUCHSCREEN_MXC_TSADCC
+	tristate "i.MX25 Touchscreen Interface"
+	depends on MACH_MX25
+	help
+	  Say Y here if you have a 4-wire touchscreen connected to the
+          ADC Controller on your Freescale i.MX25 SoC.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called atmel_tsadcc.
+
 config TOUCHSCREEN_UCB1400
 	tristate "Philips UCB1400 touchscreen"
 	depends on AC97_BUS
Index: linux-2.6.30-karo/drivers/input/touchscreen/Makefile
===================================================================
--- linux-2.6.30-karo.orig/drivers/input/touchscreen/Makefile	2009-06-23 13:46:03.000000000 +0200
+++ linux-2.6.30-karo/drivers/input/touchscreen/Makefile	2009-06-23 13:46:20.000000000 +0200
@@ -16,19 +16,20 @@
 obj-$(CONFIG_TOUCHSCREEN_ELO)		+= elo.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
 obj-$(CONFIG_TOUCHSCREEN_INEXIO)	+= inexio.o
-obj-$(CONFIG_TOUCHSCREEN_MIGOR)		+= migor_ts.o
-obj-$(CONFIG_TOUCHSCREEN_MTOUCH)	+= mtouch.o
-obj-$(CONFIG_TOUCHSCREEN_MK712)		+= mk712.o
 obj-$(CONFIG_TOUCHSCREEN_HP600)		+= hp680_ts_input.o
 obj-$(CONFIG_TOUCHSCREEN_HP7XX)		+= jornada720_ts.o
 obj-$(CONFIG_TOUCHSCREEN_HTCPEN)	+= htcpen.o
-obj-$(CONFIG_TOUCHSCREEN_USB_COMPOSITE)	+= usbtouchscreen.o
+obj-$(CONFIG_TOUCHSCREEN_MIGOR)		+= migor_ts.o
+obj-$(CONFIG_TOUCHSCREEN_MTOUCH)	+= mtouch.o
+obj-$(CONFIG_TOUCHSCREEN_MK712)		+= mk712.o
+obj-$(CONFIG_TOUCHSCREEN_MXC_TSADCC)	+= mxc_tsadcc.o
 obj-$(CONFIG_TOUCHSCREEN_PENMOUNT)	+= penmount.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
 obj-$(CONFIG_TOUCHSCREEN_TSC2007)	+= tsc2007.o
 obj-$(CONFIG_TOUCHSCREEN_UCB1400)	+= ucb1400_ts.o
+obj-$(CONFIG_TOUCHSCREEN_USB_COMPOSITE)	+= usbtouchscreen.o
 obj-$(CONFIG_TOUCHSCREEN_WACOM_W8001)	+= wacom_w8001.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX)	+= wm97xx-ts.o
 obj-$(CONFIG_TOUCHSCREEN_DA9034)	+= da9034-ts.o
Index: linux-2.6.30-karo/drivers/input/touchscreen/mxc_tsadcc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-karo/drivers/input/touchscreen/mxc_tsadcc.c	2009-06-23 14:54:48.000000000 +0200
@@ -0,0 +1,897 @@
+/*
+ *  Freescale i.MX25 Touch Screen Driver
+ *
+ *  Copyright (c) 2009 Lothar Wassmann <LW@KARO-electronics.de>
+ *
+ * Based on atmel_tsadcc.c
+ *  Copyright (c) 2008 ATMEL et. al.
+ * and code from Freescale BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/input.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <mach/mxc_tsadcc.h>
+
+#include "mxc_tsadcc.h"
+
+#define TSC_NUM_SAMPLES		1
+#define ADC_NUM_SAMPLES		1
+
+#ifdef DEBUG
+static int debug = 4;
+#define dbg_lvl(n)	((n) < debug)
+module_param(debug, int, S_IRUGO | S_IWUSR);
+
+#define DBG(lvl, fmt...)	do { if (dbg_lvl(lvl)) printk(KERN_DEBUG fmt); } while (0)
+#else
+static int debug;
+#define dbg_lvl(n)	0
+module_param(debug, int, 0);
+
+#define DBG(lvl, fmt...)	do { } while (0)
+#endif
+
+#define DEFAULT_ADC_CLOCK	1666667
+#define DEFAULT_RX_VALUE	360
+
+//#define REPORT_PRESSURE
+
+struct mxc_tsadcc_fifo_data {
+	unsigned int id:4,
+		data:12;
+};
+
+/* The layout of this structure depends on the setup created by mxc_tsadcc_config() */
+struct mxc_tsadcc_tsc_data {
+	struct mxc_tsadcc_fifo_data pendown[TSC_NUM_SAMPLES];
+	struct mxc_tsadcc_fifo_data pos_x[TSC_NUM_SAMPLES];
+	struct mxc_tsadcc_fifo_data pos_y[TSC_NUM_SAMPLES];
+#ifdef REPORT_PRESSURE
+	struct mxc_tsadcc_fifo_data yn[TSC_NUM_SAMPLES];
+	struct mxc_tsadcc_fifo_data xp[TSC_NUM_SAMPLES];
+#endif
+	struct mxc_tsadcc_fifo_data pendown2[TSC_NUM_SAMPLES];
+};
+
+struct mxc_tsadcc_adc_data {
+	struct mxc_tsadcc_fifo_data data[ADC_NUM_SAMPLES];
+};
+
+struct mxc_tsadcc {
+	struct input_dev	*input;
+	char			phys[32];
+	void __iomem		*reg_base;
+	struct clk		*clk;
+	int			irq;
+	struct work_struct	work;
+	struct timer_list	timer;
+	wait_queue_head_t	wq;
+	unsigned int		pendown:1,
+				clk_enabled:1,
+				attrs:1,
+				valid_measure:1;
+	mxc_tsc_mode		tsc_mode;
+	struct mxc_tsadcc_tsc_data *tsc_data;
+	struct mxc_tsadcc_adc_data *adc_data;
+	unsigned int		r_xplate;
+
+	struct mutex		convert_mutex;
+	unsigned short		pressure;
+	unsigned short		prev_absx;
+	unsigned short		prev_absy;
+};
+
+#ifdef DEBUG
+#define mxc_tsadcc_read(s,reg)		_mxc_tsadcc_read(s,reg,#reg,__FUNCTION__)
+#define mxc_tsadcc_write(s,reg,val)	_mxc_tsadcc_write(s,reg,val,#reg,__FUNCTION__)
+
+static inline unsigned long _mxc_tsadcc_read(struct mxc_tsadcc *ts_dev, int reg,
+				   const char *name, const char *fn)
+{
+	unsigned long val = __raw_readl(ts_dev->reg_base + reg);
+	DBG(3, "%s: Read %08lx from %s\n", fn, val, name);
+	return val;
+}
+
+static inline void _mxc_tsadcc_write(struct mxc_tsadcc *ts_dev, int reg, unsigned long val,
+				     const char *name, const char *fn)
+{
+	__raw_writel(val, ts_dev->reg_base + reg);
+	DBG(3, "%s: Wrote %08lx to %s\n", fn, val, name);
+}
+#else
+static inline unsigned long mxc_tsadcc_read(struct mxc_tsadcc *ts_dev, int reg)
+{
+	return __raw_readl(ts_dev->reg_base + reg);
+}
+static inline void mxc_tsadcc_write(struct mxc_tsadcc *ts_dev, int reg, unsigned long val)
+{
+	__raw_writel(val, ts_dev->reg_base + reg);
+}
+#endif
+
+static void tsc_clk_enable(struct mxc_tsadcc *ts_dev)
+{
+	if (!ts_dev->clk_enabled) {
+		unsigned long reg;
+		clk_enable(ts_dev->clk);
+
+		reg = mxc_tsadcc_read(ts_dev, TGCR);
+		reg |= TGCR_IPG_CLK_EN;
+		mxc_tsadcc_write(ts_dev, TGCR, reg);
+		ts_dev->clk_enabled = 1;
+	}
+}
+
+static void tsc_clk_disable(struct mxc_tsadcc *ts_dev)
+{
+	if (ts_dev->clk_enabled) {
+		unsigned long reg;
+
+		reg = mxc_tsadcc_read(ts_dev, TGCR);
+		reg &= ~TGCR_IPG_CLK_EN;
+		mxc_tsadcc_write(ts_dev, TGCR, reg);
+
+		clk_disable(ts_dev->clk);
+		ts_dev->clk_enabled = 0;
+	}
+}
+
+static inline int mxc_tsadcc_pendown(struct mxc_tsadcc *ts_dev)
+{
+	return ts_dev->pendown;
+}
+
+static int mxc_tsadcc_read_adc(struct mxc_tsadcc *ts_dev, int chan)
+{
+	int ret = 1;
+	unsigned long reg;
+	unsigned int data_num = 0;
+	int i;
+	union {
+		unsigned int fifo[sizeof(struct mxc_tsadcc_tsc_data) / sizeof(int)];
+		struct mxc_tsadcc_tsc_data data;
+	} *fifo_data = (void *)ts_dev->adc_data;
+	struct mxc_tsadcc_adc_data *adc_data = ts_dev->adc_data;
+	int lastitemid = 0;
+	struct input_dev *input_dev = ts_dev->input;
+	long timeout = msecs_to_jiffies(1 * ADC_NUM_SAMPLES);
+
+	mutex_lock(&ts_dev->convert_mutex);
+	reg = (0xf << CQCR_FIFOWATERMARK_SHIFT) |
+		(lastitemid << CQCR_LAST_ITEM_ID_SHIFT) | CQCR_QSM_FQS;
+	mxc_tsadcc_write(ts_dev, GCQCR, reg);
+
+	reg = ((ADC_NUM_SAMPLES - 1) << CC_NOS_SHIFT) |
+		(16 << CC_SETTLING_TIME_SHIFT) |
+		CC_YPLLSW_OFF | CC_XNURSW_OFF | CC_XPULSW |
+		CC_SELREFP_INT | chan | CC_SEL_REFN_AGND;
+	mxc_tsadcc_write(ts_dev, GCC0, reg);
+
+	memset(adc_data, 0, sizeof(*adc_data));
+
+	reg = mxc_tsadcc_read(ts_dev, GCQCR);
+	reg |= CQCR_FQS;
+	mxc_tsadcc_write(ts_dev, GCQCR, reg);
+
+	/* enable end of conversion interrupt */
+	reg = mxc_tsadcc_read(ts_dev, GCQMR);
+	reg &= ~CQMR_EOQ_IRQ_MSK;
+	mxc_tsadcc_write(ts_dev, GCQMR, reg);
+
+	timeout = wait_event_timeout(ts_dev->wq,
+				     mxc_tsadcc_read(ts_dev, GCQSR) &
+				     CQSR_EOQ, timeout);
+	if (timeout == 0 &&
+	    !(mxc_tsadcc_read(ts_dev, GCQSR) & CQSR_EOQ)) {
+		dev_err(&input_dev->dev,
+			"Timeout waiting for data on channel %d\n",
+			chan);
+		ret = -ETIME;
+		goto exit;
+	}
+
+	reg = mxc_tsadcc_read(ts_dev, GCQCR);
+	reg &= ~CQCR_FQS;
+	mxc_tsadcc_write(ts_dev, GCQCR, reg);
+	reg = mxc_tsadcc_read(ts_dev, GCQSR);
+
+	/* clear interrupt status bit */
+	reg = CQSR_EOQ;
+	mxc_tsadcc_write(ts_dev, GCQSR, reg);
+
+	while (!(mxc_tsadcc_read(ts_dev, GCQSR) & CQSR_EMPT)) {
+		BUG_ON(data_num >= ARRAY_SIZE(fifo_data->fifo));
+		reg = mxc_tsadcc_read(ts_dev, GCQFIFO);
+		fifo_data->fifo[data_num] = reg;
+		data_num++;
+	}
+	DBG(0, "%s: Read %u words from fifo\n", __FUNCTION__, data_num);
+	for (i = 0; i < data_num; i++) {
+		DBG(0, "%s: data[%d]=%03x ID %d\n", __FUNCTION__, i,
+		    adc_data->data[i].data, adc_data->data[i].id);
+	}
+ exit:
+	mutex_unlock(&ts_dev->convert_mutex);
+
+	return ret;
+}
+
+struct mxc_tsadcc_attr {
+	struct device_attribute attr;
+	unsigned int reg;
+};
+
+#define to_mxc_tsadcc_attr(a)		container_of(a, struct mxc_tsadcc_attr, attr)
+
+#define MXC_TSADCC_DEV_ATTR(_name, _mode, _reg, _read, _write)	\
+	struct mxc_tsadcc_attr mxc_tsadcc_attr_##_name = {	\
+		.attr = __ATTR(_name,_mode,_read,_write),	\
+		.reg = _reg,					\
+	}
+
+static ssize_t mxc_tsadcc_attr_get(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = -EIO;
+	struct mxc_tsadcc *ts_dev = dev_get_drvdata(dev);
+	struct mxc_tsadcc_attr *mxc_tsadcc_attr = to_mxc_tsadcc_attr(attr);
+
+	if (mxc_tsadcc_read_adc(ts_dev, mxc_tsadcc_attr->reg)) {
+		ret = sprintf(buf, "0x%04x\n", ts_dev->adc_data->data[0].data);
+	}
+	return ret;
+}
+
+#if 0
+static ssize_t mxc_tsadcc_attr_set(struct device *dev, struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	ssize_t ret;
+	struct mxc_tsadcc *ts_dev = dev_get_drvdata(dev);
+	struct mxc_tsadcc_attr *mxc_tsadcc_attr = to_mxc_tsadcc_attr(attr);
+	unsigned long val = simple_strtoul(buf, NULL, 0);
+
+	mxc_tsadcc_write(ts_dev, mxc_tsadcc_attr->reg, val);
+	return count;
+}
+#endif
+
+MXC_TSADCC_DEV_ATTR(inaux0, S_IRUGO, CC_SELIN_INAUX0, mxc_tsadcc_attr_get, NULL);
+MXC_TSADCC_DEV_ATTR(inaux1, S_IRUGO, CC_SELIN_INAUX1, mxc_tsadcc_attr_get, NULL);
+MXC_TSADCC_DEV_ATTR(inaux2, S_IRUGO, CC_SELIN_INAUX2, mxc_tsadcc_attr_get, NULL);
+
+static struct attribute *mxc_tsadcc_attrs[] = {
+	&mxc_tsadcc_attr_inaux0.attr.attr,
+	&mxc_tsadcc_attr_inaux1.attr.attr,
+	&mxc_tsadcc_attr_inaux2.attr.attr,
+	NULL
+};
+
+static const struct attribute_group mxc_tsadcc_attr_group = {
+	.attrs = mxc_tsadcc_attrs,
+};
+
+static int mxc_tsadcc_read_ts(struct mxc_tsadcc *ts_dev, int force)
+{
+	int ret;
+	unsigned long reg;
+	unsigned int data_num = 0;
+	union {
+		unsigned int fifo[sizeof(struct mxc_tsadcc_tsc_data) / sizeof(int)];
+		struct mxc_tsadcc_tsc_data data;
+	} *fifo_data = (void *)ts_dev->tsc_data;
+	struct mxc_tsadcc_tsc_data *tsc_data = ts_dev->tsc_data;
+	struct input_dev *input_dev = ts_dev->input;
+	long timeout = msecs_to_jiffies(1 * TSC_NUM_SAMPLES);
+
+	mutex_lock(&ts_dev->convert_mutex);
+	memset(tsc_data, 0, sizeof(*tsc_data));
+	if (force) {
+		reg = (0x1 << CC_YPLLSW_SHIFT) | (0x1 << CC_XNURSW_SHIFT) |
+		      CC_XPULSW;
+		mxc_tsadcc_write(ts_dev, TICR, reg);
+
+		/* FQS */
+		reg = mxc_tsadcc_read(ts_dev, TCQCR);
+		reg &= ~CQCR_QSM_MASK;
+		reg |= CQCR_QSM_FQS;
+		mxc_tsadcc_write(ts_dev, TCQCR, reg);
+		reg = mxc_tsadcc_read(ts_dev, TCQCR);
+		reg |= CQCR_FQS;
+		mxc_tsadcc_write(ts_dev, TCQCR, reg);
+
+		timeout = wait_event_timeout(ts_dev->wq,
+					     mxc_tsadcc_read(ts_dev, TCQSR) &
+					     CQSR_EOQ, timeout);
+		if (timeout == 0 &&
+		    !(mxc_tsadcc_read(ts_dev, TCQSR) & CQSR_EOQ)) {
+			dev_err(&input_dev->dev,
+				"Timeout waiting for TSC data\n");
+			ret = -ETIME;
+			goto exit;
+		}
+
+		/* stop FQS */
+		reg = mxc_tsadcc_read(ts_dev, TCQCR);
+		reg &= ~CQCR_QSM_MASK;
+		mxc_tsadcc_write(ts_dev, TCQCR, reg);
+		reg = mxc_tsadcc_read(ts_dev, TCQCR);
+		reg &= ~CQCR_FQS;
+		mxc_tsadcc_write(ts_dev, TCQCR, reg);
+
+		/* clear status bit */
+		reg = mxc_tsadcc_read(ts_dev, TCQSR);
+		reg = CQSR_EOQ;
+		mxc_tsadcc_write(ts_dev, TCQSR, reg);
+	} else {
+		/* Config idle for 4-wire */
+		reg = TSC_4WIRE_TOUCH_DETECT;
+		mxc_tsadcc_write(ts_dev, TICR, reg);
+
+		/* Pen interrupt starts new conversion queue */
+		reg = mxc_tsadcc_read(ts_dev, TCQCR);
+		reg &= ~CQCR_QSM_MASK;
+		reg |= CQCR_QSM_PEN;
+		mxc_tsadcc_write(ts_dev, TCQCR, reg);
+
+		/* PDEN and PDBEN */
+		reg = mxc_tsadcc_read(ts_dev, TGCR);
+		reg |= (TGCR_PDB_EN | TGCR_PD_EN);
+		mxc_tsadcc_write(ts_dev, TGCR, reg);
+
+		wait_event_timeout(ts_dev->wq,
+				   mxc_tsadcc_read(ts_dev, TCQSR) &
+				   CQSR_EOQ, timeout);
+		if (timeout == 0 &&
+		    !(mxc_tsadcc_read(ts_dev, TCQSR) & CQSR_EOQ)) {
+			dev_err(&input_dev->dev,
+				"Timeout waiting for TSC data\n");
+			ret = -ETIME;
+			goto exit;
+		}
+
+		/* stop the conversion */
+		reg = mxc_tsadcc_read(ts_dev, TCQCR);
+		reg &= ~CQCR_QSM_MASK;
+		mxc_tsadcc_write(ts_dev, TCQCR, reg);
+
+		/* clear interrupt status flags */
+		reg = CQSR_PD | CQSR_EOQ;
+		mxc_tsadcc_write(ts_dev, TCQSR, reg);
+
+		/* change configuration for FQS mode */
+		reg = (0x1 << CC_YPLLSW_SHIFT) | (0x1 << CC_XNURSW_SHIFT) |
+		      CC_XPULSW;
+		mxc_tsadcc_write(ts_dev, TICR, reg);
+	}
+
+	while (!(mxc_tsadcc_read(ts_dev, TCQSR) & CQSR_EMPT)) {
+		BUG_ON(data_num >= ARRAY_SIZE(fifo_data->fifo));
+		reg = mxc_tsadcc_read(ts_dev, TCQFIFO);
+		fifo_data->fifo[data_num] = reg;
+		data_num++;
+	}
+	DBG(0, "%s: Read %u words from fifo\n", __FUNCTION__, data_num);
+
+	ret = tsc_data->pendown[0].data <= 0x600 &&
+		tsc_data->pendown2[0].data <= 0x600;
+
+	if (ret) {
+		DBG(0, "%s: pos_x=%03x pos_y=%03x\n",
+		    __FUNCTION__, tsc_data->pos_x[0].data,
+		    tsc_data->pos_y[0].data);
+#ifdef REPORT_PRESSURE
+		DBG(0, "%s: pos_x=%03x pos_y=%03x xp=%03x yn=%03x\n",
+		    __FUNCTION__, tsc_data->xp[0].data,
+		    tsc_data->yn[0].data);
+#endif
+		if (/*(mxc_tsadcc_read(ts_dev, TCQSR) & CQSR_PD) && */
+		    tsc_data->pos_x[0].data &&
+		    tsc_data->pos_x[1].data &&
+		    tsc_data->pos_x[2].data) {
+#ifdef REPORT_PRESSURE
+			ts_dev->pressure = ts_dev->r_xplate *
+				(tsc_data->pos_x[0].data / 4096) *
+				((tsc_data->yn[0].data - tsc_data->xp[0].data) /
+				 tsc_data->xp[0].data);
+#else
+			ts_dev->pressure = 4095;
+#endif
+			DBG(0, "%s: Detected PEN DOWN with pressure %03x\n",
+			    __FUNCTION__, ts_dev->pressure);
+			ts_dev->pendown = 1;
+		} else {
+			DBG(0, "%s: Detected PEN UP\n", __FUNCTION__);
+			ts_dev->pendown = 0;
+		}
+	} else {
+		DBG(0, "%s: Discarding measurement\n", __FUNCTION__);
+		ts_dev->pendown = 0;
+	}
+ exit:
+	mutex_unlock(&ts_dev->convert_mutex);
+
+	return ret;
+}
+
+static inline void mxc_tsadcc_enable_pendown(struct mxc_tsadcc *ts_dev)
+{
+	unsigned long reg;
+
+	/* Config idle for 4-wire */
+	reg = TSC_4WIRE_TOUCH_DETECT;
+	mxc_tsadcc_write(ts_dev, TICR, reg);
+
+	DBG(0, "%s: Enable PD detect\n", __FUNCTION__);
+	reg = mxc_tsadcc_read(ts_dev, TGCR);
+	reg |= TGCR_PD_EN;
+	mxc_tsadcc_write(ts_dev, TGCR, reg);
+}
+
+static void mxc_tsadcc_work(struct work_struct *w)
+{
+	struct mxc_tsadcc *ts_dev = container_of(w, struct mxc_tsadcc, work);
+	struct input_dev *input_dev = ts_dev->input;
+
+	if (mxc_tsadcc_read_ts(ts_dev, 1)) {
+		DBG(0, "%s: Got sample %d\n", __FUNCTION__, ts_dev->pendown);
+		if (mxc_tsadcc_pendown(ts_dev)) {
+			if (!ts_dev->valid_measure) {
+				ts_dev->valid_measure = 1;
+			} else {
+				DBG(0, "%s: Reporting PD event %03x @ %03x,%03x\n",
+				    __FUNCTION__, ts_dev->pressure,
+				    ts_dev->tsc_data->pos_x[0].data,
+				    ts_dev->tsc_data->pos_y[0].data);
+
+				input_report_abs(input_dev, ABS_X,
+						 ts_dev->tsc_data->pos_x[0].data);
+				input_report_abs(input_dev, ABS_Y,
+						 ts_dev->tsc_data->pos_y[0].data);
+#ifdef REPORT_PRESSURE
+				input_report_abs(input_dev, ABS_PRESSURE,
+						 ts_dev->pressure);
+#endif
+				input_report_key(input_dev, BTN_TOUCH, 1);
+				input_sync(input_dev);
+			}
+			ts_dev->prev_absx = ts_dev->tsc_data->pos_x[0].data;
+			ts_dev->prev_absy = ts_dev->tsc_data->pos_y[0].data;
+			DBG(0, "%s: Enabling timer\n", __FUNCTION__);
+			mod_timer(&ts_dev->timer, jiffies +
+				  msecs_to_jiffies(10));
+			return;
+		}
+	}
+	if (ts_dev->valid_measure) {
+		DBG(0, "%s: Reporting PU event: %03x,%03x\n", __FUNCTION__,
+		    ts_dev->prev_absx, ts_dev->prev_absy);
+		input_report_abs(input_dev, ABS_X,
+				 ts_dev->prev_absx);
+		input_report_abs(input_dev, ABS_Y,
+				 ts_dev->prev_absy);
+#ifdef REPORT_PRESSURE
+		input_report_abs(input_dev, ABS_PRESSURE, 0);
+#endif
+		input_report_key(input_dev, BTN_TOUCH, 0);
+		input_sync(input_dev);
+	}
+	ts_dev->valid_measure = 0;
+	mxc_tsadcc_enable_pendown(ts_dev);
+}
+
+static void mxc_tsadcc_timer(unsigned long data)
+{
+	struct mxc_tsadcc *ts_dev = (void *)data;
+	schedule_work(&ts_dev->work);
+}
+
+static irqreturn_t mxc_tsadcc_interrupt(int irq, void *dev)
+{
+	struct mxc_tsadcc *ts_dev = dev;
+	//struct input_dev *input_dev = ts_dev->input;
+	unsigned long reg;
+	unsigned long status = mxc_tsadcc_read(ts_dev, TGSR);
+
+	DBG(0, "%s: TCSR= %08lx\n", __FUNCTION__, status);
+
+	if (status & TGSR_TCQ_INT) {
+		DBG(0, "%s: TCQSR=%08lx\n", __FUNCTION__,
+		    mxc_tsadcc_read(ts_dev, TCQSR));
+		reg = mxc_tsadcc_read(ts_dev, TCQSR);
+		if (reg & CQSR_PD) {
+			/* disable pen down detect */
+			DBG(0, "%s: Disable PD detect\n", __FUNCTION__);
+			reg = mxc_tsadcc_read(ts_dev, TGCR);
+			reg &= ~TGCR_PD_EN;
+			mxc_tsadcc_write(ts_dev, TGCR, reg);
+
+			/* Now schedule new measurement */
+			schedule_work(&ts_dev->work);
+		}
+	}
+	if (status & TGSR_GCQ_INT) {
+		DBG(0, "%s: GCQSR=%08lx\n", __FUNCTION__,
+		    mxc_tsadcc_read(ts_dev, GCQSR));
+		reg = mxc_tsadcc_read(ts_dev, GCQSR);
+		if (reg & CQSR_EOQ) {
+			reg = mxc_tsadcc_read(ts_dev, GCQMR);
+			reg |= CQMR_EOQ_IRQ_MSK;
+			mxc_tsadcc_write(ts_dev, GCQMR, reg);
+		}
+	}		
+	return IRQ_HANDLED;
+}
+
+static void mxc_tsadcc_4wire_config(struct mxc_tsadcc *ts_dev)
+{
+	unsigned long reg;
+	int lastitemid;
+
+	/* Level sense */
+	reg = mxc_tsadcc_read(ts_dev, TCQCR);
+	reg |= CQCR_PD_CFG;
+	reg |= (0xf << CQCR_FIFOWATERMARK_SHIFT);  /* watermark */
+	mxc_tsadcc_write(ts_dev, TCQCR, reg);
+
+	/* Configure 4-wire */
+	reg = TSC_4WIRE_PRECHARGE;
+	reg |= CC_IGS;
+	mxc_tsadcc_write(ts_dev, TCC0, reg);
+
+	reg = TSC_4WIRE_TOUCH_DETECT;
+	reg |= (TSC_NUM_SAMPLES - 1) << CC_NOS_SHIFT;	/* 4 samples */
+	reg |= 32 << CC_SETTLING_TIME_SHIFT;	/* it's important! */
+	mxc_tsadcc_write(ts_dev, TCC1, reg);
+
+	reg = TSC_4WIRE_X_MEASURE;
+	reg |= (TSC_NUM_SAMPLES - 1) << CC_NOS_SHIFT;	/* 4 samples */
+	reg |= 16 << CC_SETTLING_TIME_SHIFT;	/* settling time */
+	mxc_tsadcc_write(ts_dev, TCC2, reg);
+
+	reg = TSC_4WIRE_Y_MEASURE;
+	reg |= (TSC_NUM_SAMPLES - 1) << CC_NOS_SHIFT;	/* 4 samples */
+	reg |= 16 << CC_SETTLING_TIME_SHIFT;	/* settling time */
+	mxc_tsadcc_write(ts_dev, TCC3, reg);
+
+	reg = TSC_4WIRE_YN_MEASURE;
+	reg |= (TSC_NUM_SAMPLES - 1) << CC_NOS_SHIFT;	/* 4 samples */
+	reg |= 16 << CC_SETTLING_TIME_SHIFT;	/* settling time */
+	mxc_tsadcc_write(ts_dev, TCC4, reg);
+
+	reg = TSC_4WIRE_XP_MEASURE;
+	reg |= (TSC_NUM_SAMPLES - 1) << CC_NOS_SHIFT;	/* 4 samples */
+	reg |= 16 << CC_SETTLING_TIME_SHIFT;	/* settling time */
+	mxc_tsadcc_write(ts_dev, TCC5, reg);
+
+	reg = (TCQ_ITEM_TCC0 << CQ_ITEM0_SHIFT) |
+		(TCQ_ITEM_TCC1 << CQ_ITEM1_SHIFT) |
+		(TCQ_ITEM_TCC2 << CQ_ITEM2_SHIFT) |
+		(TCQ_ITEM_TCC3 << CQ_ITEM3_SHIFT) |
+		(TCQ_ITEM_TCC0 << CQ_ITEM4_SHIFT) |
+		(TCQ_ITEM_TCC1 << CQ_ITEM5_SHIFT);
+	mxc_tsadcc_write(ts_dev, TCQ_ITEM_7_0, reg);
+
+	lastitemid = 5;
+	reg = mxc_tsadcc_read(ts_dev, TCQCR);
+	reg = (reg & ~CQCR_LAST_ITEM_ID_MASK) |
+	      (lastitemid << CQCR_LAST_ITEM_ID_SHIFT);
+	mxc_tsadcc_write(ts_dev, TCQCR, reg);
+
+	/* pen down enable */
+	reg = mxc_tsadcc_read(ts_dev, TCQCR);
+	reg &= ~CQCR_PD_MSK;
+	mxc_tsadcc_write(ts_dev, TCQCR, reg);
+	reg = mxc_tsadcc_read(ts_dev, TCQMR);
+	reg &= ~CQMR_PD_IRQ_MSK;
+	mxc_tsadcc_write(ts_dev, TCQMR, reg);
+
+	/* Config idle for 4-wire */
+	reg = TSC_4WIRE_TOUCH_DETECT;
+	mxc_tsadcc_write(ts_dev, TICR, reg);
+
+	/* Pen interrupt starts new conversion queue */
+	reg = mxc_tsadcc_read(ts_dev, TCQCR);
+	reg &= ~CQCR_QSM_MASK;
+	reg |= CQCR_QSM_PEN;
+	mxc_tsadcc_write(ts_dev, TCQCR, reg);
+}
+
+static void mxc_tsadcc_config(struct platform_device *pdev)
+{
+	struct mxc_tsadcc *ts_dev = platform_get_drvdata(pdev);
+	struct mxc_tsadcc_pdata *pdata = pdev->dev.platform_data;
+	unsigned int tgcr;
+	unsigned int pdbt;
+	unsigned int pdben;
+	unsigned int intref;
+	unsigned int adc_clk = DEFAULT_ADC_CLOCK;
+	unsigned long ipg_clk;
+	unsigned int clkdiv;
+
+	if (pdata) {
+		pdbt = pdata->pen_debounce_time - 1;
+		pdben = pdata->pen_debounce_time > 0;
+		intref = !!pdata->intref;
+		if (pdata->adc_clk > 0) {
+			adc_clk = pdata->adc_clk;
+		}
+		ts_dev->r_xplate = pdata->r_xplate;
+	} else {
+		dev_dbg(&pdev->dev, "No platform_data; using defaults\n");
+		pdbt = TGCR_PDBTIME128;
+		pdben = 1;
+		intref = 1;
+	}
+	if (ts_dev->r_xplate == 0) {
+		ts_dev->r_xplate = DEFAULT_RX_VALUE;
+		DBG(0, "%s: Assuming default Rx value of %u Ohms\n",
+		    __FUNCTION__, ts_dev->r_xplate);
+	}
+	ipg_clk = clk_get_rate(ts_dev->clk);
+	dev_info(&pdev->dev, "Master clock is: %lu.%06luMHz requested ADC clock: %u.%06uMHz\n",
+		 ipg_clk / 1000000, ipg_clk % 1000000,
+		 adc_clk / 1000000, adc_clk % 1000000);
+	/*
+	 * adc_clk = ipg_clk / (2 * clkdiv + 2)
+	 * The exact formula for the clock divider would be:
+	 * clkdiv = ipg_clk / (2 * adc_clk) - 1
+	 * but we drop the '- 1' due to integer truncation
+	 * and to make sure the actual clock is always less or equal
+	 * to the designated clock.
+	*/
+	clkdiv = ipg_clk / (2 * adc_clk + 1);
+	if (clkdiv > 31) {
+		clkdiv = 31;
+		dev_warn(&pdev->dev,
+			 "cannot accomodate designated clock of %u.%06uMHz; using %lu.%06luMHz\n",
+			 adc_clk / 1000000, adc_clk % 1000000,
+			 ipg_clk / (2 * clkdiv + 2) / 1000000,
+			 ipg_clk / (2 * clkdiv + 2) % 1000000);
+	} else {
+		dev_dbg(&pdev->dev,
+			"clkdiv=%u actual ADC clock: %lu.%06luMHz\n",
+			clkdiv, ipg_clk / (2 * (clkdiv + 1)) / 1000000,
+			ipg_clk / (2 * clkdiv + 2) % 1000000);
+	}
+
+	tgcr = ((pdbt << TGCR_PDBTIME_SHIFT) & TGCR_PDBTIME_MASK) | /* pen debounce time */
+		(pdben * TGCR_PDB_EN) | /* pen debounce enable */
+		(intref * TGCR_INTREFEN) | /* pen debounce enable */
+		TGCR_POWER_SAVE | /* Switch TSC on */
+		TGCR_PD_EN |	/* Enable Pen Detect */
+		((clkdiv << TGCR_ADCCLKCFG_SHIFT) & TGCR_ADCCLKCFG_MASK);
+
+	/* reset TSC */
+	mxc_tsadcc_write(ts_dev, TGCR, TGCR_TSC_RST);
+	while (mxc_tsadcc_read(ts_dev, TGCR) & TGCR_TSC_RST) {
+		cpu_relax();
+	}
+	mxc_tsadcc_write(ts_dev, TGCR, tgcr);
+
+	mxc_tsadcc_4wire_config(ts_dev);
+	tsc_clk_enable(ts_dev);
+}
+
+static int __devinit mxc_tsadcc_probe(struct platform_device *pdev)
+{
+	int err;
+	struct mxc_tsadcc *ts_dev;
+	struct input_dev *input_dev;
+	struct resource	*res;
+	int irq;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "No mmio resource defined\n");
+		return -ENODEV;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "No IRQ assigned\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(res->start, resource_size(res),
+				"mxc tsadcc regs")) {
+		return -EBUSY;
+	}
+
+	/* Allocate memory for device */
+	ts_dev = kzalloc(sizeof(struct mxc_tsadcc), GFP_KERNEL);
+	if (!ts_dev) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		err = -ENOMEM;
+		goto err_release_mem;
+	}
+
+	/* allocate conversion buffers separately to prevent
+	 * cacheline alignment issues when using DMA */
+	ts_dev->tsc_data = kzalloc(sizeof(struct mxc_tsadcc_tsc_data), GFP_KERNEL);
+	ts_dev->adc_data = kzalloc(sizeof(struct mxc_tsadcc_adc_data), GFP_KERNEL);
+	if (ts_dev->tsc_data == NULL || ts_dev->adc_data == NULL) {
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+	ts_dev->irq = irq;
+	INIT_WORK(&ts_dev->work, mxc_tsadcc_work);
+	mutex_init(&ts_dev->convert_mutex);
+	setup_timer(&ts_dev->timer, mxc_tsadcc_timer, (unsigned long)ts_dev);
+	init_waitqueue_head(&ts_dev->wq);
+
+	platform_set_drvdata(pdev, ts_dev);
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		dev_err(&pdev->dev, "Failed to allocate input device\n");
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	ts_dev->reg_base = ioremap(res->start, resource_size(res));
+	if (!ts_dev->reg_base) {
+		dev_err(&pdev->dev, "Failed to map registers\n");
+		err = -ENOMEM;
+		goto err_free_dev;
+	}
+
+	err = request_irq(ts_dev->irq, mxc_tsadcc_interrupt, 0,
+			pdev->dev.driver->name, ts_dev);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to install irq handler: %d\n", err);
+		goto err_unmap_regs;
+	}
+
+	ts_dev->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(ts_dev->clk)) {
+		dev_err(&pdev->dev, "Failed to get ts_clk\n");
+		err = PTR_ERR(ts_dev->clk);
+		goto err_free_irq;
+	}
+
+	ts_dev->input = input_dev;
+
+	snprintf(ts_dev->phys, sizeof(ts_dev->phys),
+		 "%s/input0", dev_name(&pdev->dev));
+
+	input_dev->name = "mxc touch screen controller";
+	input_dev->phys = ts_dev->phys;
+	input_dev->dev.parent = &pdev->dev;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_dev->absbit[0] = BIT_MASK(ABS_X) |
+		BIT_MASK(ABS_Y) |
+		BIT_MASK(ABS_PRESSURE);
+
+	input_set_abs_params(input_dev, ABS_X, 0, 0xFFF, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, 0xFFF, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 0xFFF, 0, 0);
+
+	mxc_tsadcc_config(pdev);
+
+	/* All went ok, so register to the input system */
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_fail;
+
+	err = sysfs_create_group(&pdev->dev.kobj, &mxc_tsadcc_attr_group);
+	if (err) {
+		dev_warn(&pdev->dev, "Failed to create sysfs attributes: %d\n",
+			 err);
+	}
+	ts_dev->attrs = !err;
+
+	return 0;
+
+err_fail:
+	clk_disable(ts_dev->clk);
+	clk_put(ts_dev->clk);
+err_free_irq:
+	free_irq(ts_dev->irq, ts_dev);
+err_unmap_regs:
+	iounmap(ts_dev->reg_base);
+err_free_dev:
+	input_free_device(ts_dev->input);
+err_free_mem:
+	kfree(ts_dev->tsc_data);
+	kfree(ts_dev->adc_data);
+	kfree(ts_dev);
+err_release_mem:
+	release_mem_region(res->start, resource_size(res));
+	return err;
+}
+
+static int __devexit mxc_tsadcc_remove(struct platform_device *pdev)
+{
+	struct mxc_tsadcc *ts_dev = dev_get_drvdata(&pdev->dev);
+	struct resource *res;
+
+	if (ts_dev->attrs) {
+		DBG(0, "%s: Removing sysfs attributes\n", __FUNCTION__);
+		sysfs_remove_group(&pdev->dev.kobj, &mxc_tsadcc_attr_group);
+	}
+	del_timer_sync(&ts_dev->timer);
+	input_unregister_device(ts_dev->input);
+
+	clk_disable(ts_dev->clk);
+	clk_put(ts_dev->clk);
+
+	free_irq(ts_dev->irq, ts_dev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	iounmap(ts_dev->reg_base);
+	release_mem_region(res->start, resource_size(res));
+
+	kfree(ts_dev->tsc_data);
+	kfree(ts_dev->adc_data);
+	kfree(ts_dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mxc_tsadcc_suspend(struct platform_device *pdev, pm_message_t msg)
+{
+	struct mxc_tsadcc *ts_dev = dev_get_drvdata(&pdev->dev);
+
+	if (ts_dev->clk_enabled) {
+		tsc_clk_disable(ts_dev);
+		ts_dev->clk_enabled = 1;
+	}
+	return 0;
+}
+
+static int mxc_tsadcc_resume(struct platform_device *pdev)
+{
+	struct mxc_tsadcc *ts_dev = dev_get_drvdata(&pdev->dev);
+
+	if (ts_dev->clk_enabled) {
+		ts_dev->clk_enabled = 0;
+		tsc_clk_enable(ts_dev);
+	}
+	return 0;
+}
+#else
+#define mxc_tsadcc_suspend	NULL
+#define mxc_tsadcc_resume	NULL
+#endif
+
+static struct platform_driver mxc_tsadcc_driver = {
+	.probe		= mxc_tsadcc_probe,
+	.remove		= __devexit_p(mxc_tsadcc_remove),
+	.suspend	= mxc_tsadcc_suspend,
+	.resume		= mxc_tsadcc_resume,
+	.driver		= {
+		.name	= "mxc-tsadcc",
+	},
+};
+
+static int __init mxc_tsadcc_init(void)
+{
+	return platform_driver_register(&mxc_tsadcc_driver);
+}
+
+static void __exit mxc_tsadcc_exit(void)
+{
+	platform_driver_unregister(&mxc_tsadcc_driver);
+}
+
+module_init(mxc_tsadcc_init);
+module_exit(mxc_tsadcc_exit);
+
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("i.MX25 TouchScreen Driver");
+MODULE_AUTHOR("Lothar Wassmann <LW@KARO-electronics.de>");
+
Index: linux-2.6.30-karo/drivers/input/touchscreen/mxc_tsadcc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-karo/drivers/input/touchscreen/mxc_tsadcc.h	2009-06-23 13:46:20.000000000 +0200
@@ -0,0 +1,243 @@
+/*
+ *  Freescale i.MX25 Touch Screen Driver
+ *
+ *  Copyright (c) 2009 Lothar Wassmann <LW@KARO-electronics.de>
+ *
+ * Based on code from Freescale BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+/* TSC General Config Register */
+#define TGCR			0x000
+#define TGCR_IPG_CLK_EN		(1 << 0)
+#define TGCR_TSC_RST		(1 << 1)
+#define TGCR_FUNC_RST		(1 << 2)
+#define TGCR_SLPC		(1 << 4)
+#define TGCR_STLC		(1 << 5)
+#define TGCR_HSYNC_EN		(1 << 6)
+#define TGCR_HSYNC_POL		(1 << 7)
+#define TGCR_POWERMODE_SHIFT	8
+#define TGCR_POWER_OFF		(0x0 << TGCR_POWERMODE_SHIFT)
+#define TGCR_POWER_SAVE		(0x1 << TGCR_POWERMODE_SHIFT)
+#define TGCR_POWER_ON		(0x3 << TGCR_POWERMODE_SHIFT)
+#define TGCR_POWER_MASK		(0x3 << TGCR_POWERMODE_SHIFT)
+#define TGCR_INTREFEN		(1 << 10)
+#define TGCR_ADCCLKCFG_SHIFT	16
+#define TGCR_ADCCLKCFG_MASK	(0x1f << TGCR_ADCCLKCFG_SHIFT)
+#define TGCR_PD_EN		(1 << 23)
+#define TGCR_PDB_EN		(1 << 24)
+#define TGCR_PDBTIME_SHIFT	25
+#define TGCR_PDBTIME128		(0x3f << TGCR_PDBTIME_SHIFT)
+#define TGCR_PDBTIME_MASK	(0x7f << TGCR_PDBTIME_SHIFT)
+
+/* TSC General Status Register */
+#define TGSR			0x004
+#define TGSR_TCQ_INT		(1 << 0)
+#define TGSR_GCQ_INT		(1 << 1)
+#define TGSR_SLP_INT		(1 << 2)
+#define TGSR_TCQ_DMA		(1 << 16)
+#define TGSR_GCQ_DMA		(1 << 17)
+
+/* TSC IDLE Config Register */
+#define TICR			0x008
+
+/* TouchScreen Convert Queue FIFO Register */
+#define TCQFIFO			0x400
+/* TouchScreen Convert Queue Control Register */
+#define TCQCR			0x404
+#define CQCR_QSM_SHIFT		0
+#define CQCR_QSM_STOP		(0x0 << CQCR_QSM_SHIFT)
+#define CQCR_QSM_PEN		(0x1 << CQCR_QSM_SHIFT)
+#define CQCR_QSM_FQS		(0x2 << CQCR_QSM_SHIFT)
+#define CQCR_QSM_FQS_PEN	(0x3 << CQCR_QSM_SHIFT)
+#define CQCR_QSM_MASK		(0x3 << CQCR_QSM_SHIFT)
+#define CQCR_FQS		(1 << 2)
+#define CQCR_RPT		(1 << 3)
+#define CQCR_LAST_ITEM_ID_SHIFT 4
+#define CQCR_LAST_ITEM_ID_MASK	(0xf << CQCR_LAST_ITEM_ID_SHIFT)
+#define CQCR_FIFOWATERMARK_SHIFT 8
+#define CQCR_FIFOWATERMARK_MASK (0xf << CQCR_FIFOWATERMARK_SHIFT)
+#define CQCR_REPEATWAIT_SHIFT	12
+#define CQCR_REPEATWAIT_MASK	(0xf << CQCR_REPEATWAIT_SHIFT)
+#define CQCR_QRST		(1 << 16)
+#define CQCR_FRST		(1 << 17)
+#define CQCR_PD_MSK		(1 << 18)
+#define CQCR_PD_CFG		(1 << 19)
+
+/* TouchScreen Convert Queue Status Register */
+#define TCQSR			0x408
+#define CQSR_PD			(1 << 0)
+#define CQSR_EOQ		(1 << 1)
+#define CQSR_FOR		(1 << 4)
+#define CQSR_FUR		(1 << 5)
+#define CQSR_FER		(1 << 6)
+#define CQSR_EMPT		(1 << 13)
+#define CQSR_FULL		(1 << 14)
+#define CQSR_FDRY		(1 << 15)
+
+/* TouchScreen Convert Queue Mask Register */
+#define TCQMR			0x40c
+#define CQMR_PD_IRQ_MSK		(1 << 0)
+#define CQMR_EOQ_IRQ_MSK	(1 << 1)
+#define CQMR_FOR_IRQ_MSK	(1 << 4)
+#define CQMR_FUR_IRQ_MSK	(1 << 5)
+#define CQMR_FER_IRQ_MSK	(1 << 6)
+#define CQMR_PD_DMA_MSK		(1 << 16)
+#define CQMR_EOQ_DMA_MSK	(1 << 17)
+#define CQMR_FOR_DMA_MSK	(1 << 20)
+#define CQMR_FUR_DMA_MSK	(1 << 21)
+#define CQMR_FER_DMA_MSK	(1 << 22)
+#define CQMR_FDRY_DMA_MSK	(1 << 31)
+
+/* TouchScreen Convert Queue ITEM 7~0 */
+#define TCQ_ITEM_7_0		0x420
+
+/* TouchScreen Convert Queue ITEM 15~8 */
+#define TCQ_ITEM_15_8		0x424
+
+#define TCQ_ITEM_TCC0		0x0
+#define TCQ_ITEM_TCC1		0x1
+#define TCQ_ITEM_TCC2		0x2
+#define TCQ_ITEM_TCC3		0x3
+#define TCQ_ITEM_TCC4		0x4
+#define TCQ_ITEM_TCC5		0x5
+#define TCQ_ITEM_TCC6		0x6
+#define TCQ_ITEM_TCC7		0x7
+#define TCQ_ITEM_GCC7		0x8
+#define TCQ_ITEM_GCC6		0x9
+#define TCQ_ITEM_GCC5		0xa
+#define TCQ_ITEM_GCC4		0xb
+#define TCQ_ITEM_GCC3		0xc
+#define TCQ_ITEM_GCC2		0xd
+#define TCQ_ITEM_GCC1		0xe
+#define TCQ_ITEM_GCC0		0xf
+
+/* TouchScreen Convert Config 0-7 */
+#define TCC0			0x440
+#define TCC1			0x444
+#define TCC2			0x448
+#define TCC3			0x44c
+#define TCC4			0x450
+#define TCC5			0x454
+#define TCC6			0x458
+#define TCC7			0x45c
+#define CC_PEN_IACK		(1 << 1)
+#define CC_SEL_REFN_SHIFT	2
+#define CC_SEL_REFN_YNLR	(0x1 << CC_SEL_REFN_SHIFT)
+#define CC_SEL_REFN_AGND	(0x2 << CC_SEL_REFN_SHIFT)
+#define CC_SEL_REFN_MASK	(0x3 << CC_SEL_REFN_SHIFT)
+#define CC_SELIN_SHIFT		4
+#define CC_SELIN_XPUL		(0x0 << CC_SELIN_SHIFT)
+#define CC_SELIN_YPLL		(0x1 << CC_SELIN_SHIFT)
+#define CC_SELIN_XNUR		(0x2 << CC_SELIN_SHIFT)
+#define CC_SELIN_YNLR		(0x3 << CC_SELIN_SHIFT)
+#define CC_SELIN_WIPER		(0x4 << CC_SELIN_SHIFT)
+#define CC_SELIN_INAUX0		(0x5 << CC_SELIN_SHIFT)
+#define CC_SELIN_INAUX1		(0x6 << CC_SELIN_SHIFT)
+#define CC_SELIN_INAUX2		(0x7 << CC_SELIN_SHIFT)
+#define CC_SELIN_MASK		(0x7 << CC_SELIN_SHIFT)
+#define CC_SELREFP_SHIFT	7
+#define CC_SELREFP_YPLL		(0x0 << CC_SELREFP_SHIFT)
+#define CC_SELREFP_XPUL		(0x1 << CC_SELREFP_SHIFT)
+#define CC_SELREFP_EXT		(0x2 << CC_SELREFP_SHIFT)
+#define CC_SELREFP_INT		(0x3 << CC_SELREFP_SHIFT)
+#define CC_SELREFP_MASK		(0x3 << CC_SELREFP_SHIFT)
+#define CC_XPULSW		(1 << 9)
+#define CC_XNURSW_SHIFT		10
+#define CC_XNURSW_HIGH		(0x0 << CC_XNURSW_SHIFT)
+#define CC_XNURSW_OFF		(0x1 << CC_XNURSW_SHIFT)
+#define CC_XNURSW_LOW		(0x3 << CC_XNURSW_SHIFT)
+#define CC_XNURSW_MASK		(0x3 << CC_XNURSW_SHIFT)
+#define CC_YPLLSW_SHIFT		12
+#define CC_YPLLSW_HIGH		(0x0 << CC_YPLLSW_SHIFT)
+#define CC_YPLLSW_OFF		(0x1 << CC_YPLLSW_SHIFT)
+#define CC_YPLLSW_LOW		(0x3 << CC_YPLLSW_SHIFT)
+#define CC_YPLLSW_MASK		(0x3 << CC_YPLLSW_SHIFT)
+#define CC_YNLRSW		(1 << 14)
+#define CC_WIPERSW		(1 << 15)
+#define CC_NOS_SHIFT		16
+#define CC_NOS_MASK		(0xf << CC_NOS_SHIFT)
+#define CC_IGS			(1 << 20)
+#define CC_SETTLING_TIME_SHIFT	24
+#define CC_SETTLING_TIME_MASK	(0xff << CC_SETTLING_TIME_SHIFT)
+
+#define TSC_4WIRE_PRECHARGE	0x158c
+#define TSC_4WIRE_TOUCH_DETECT	0x578e
+
+#define TSC_4WIRE_X_MEASURE	0x1c90
+#define TSC_4WIRE_Y_MEASURE	0x4604
+#define TSC_4WIRE_XP_MEASURE	0x0f8c
+#define TSC_4WIRE_YN_MEASURE	0x0fbc
+
+#define TSC_GENERAL_ADC_GCC0	0x17dc
+#define TSC_GENERAL_ADC_GCC1	0x17ec
+#define TSC_GENERAL_ADC_GCC2	0x17fc
+
+/* GeneralADC Convert Queue FIFO Register */
+#define GCQFIFO			0x800
+#define GCQFIFO_ADCOUT_SHIFT	4
+#define GCQFIFO_ADCOUT_MASK	(0xfff << GCQFIFO_ADCOUT_SHIFT)
+
+/* GeneralADC Convert Queue Control Register */
+#define GCQCR			0x804
+
+/* GeneralADC Convert Queue Status Register */
+#define GCQSR			0x808
+
+/* GeneralADC Convert Queue Mask Register */
+#define GCQMR			0x80c
+
+/* GeneralADC Convert Queue ITEM 7~0 */
+#define GCQ_ITEM_7_0		0x820
+
+/* GeneralADC Convert Queue ITEM 15~8 */
+#define GCQ_ITEM_15_8		0x824
+
+#define CQ_ITEM7_SHIFT		28
+#define CQ_ITEM6_SHIFT		24
+#define CQ_ITEM5_SHIFT		20
+#define CQ_ITEM4_SHIFT		16
+#define CQ_ITEM3_SHIFT		12
+#define CQ_ITEM2_SHIFT		 8
+#define CQ_ITEM1_SHIFT		 4
+#define CQ_ITEM0_SHIFT		 0
+
+#define CQ_ITEM8_SHIFT		28
+#define CQ_ITEM9_SHIFT		24
+#define CQ_ITEM10_SHIFT		20
+#define CQ_ITEM11_SHIFT		16
+#define CQ_ITEM12_SHIFT		12
+#define CQ_ITEM13_SHIFT		 8
+#define CQ_ITEM14_SHIFT		 4
+#define CQ_ITEM15_SHIFT		 0
+
+#define GCQ_ITEM_GCC0		0x0
+#define GCQ_ITEM_GCC1		0x1
+#define GCQ_ITEM_GCC2		0x2
+#define GCQ_ITEM_GCC3		0x3
+
+/* GeneralADC Convert Config 0-7 */
+#define GCC0			0x840
+#define GCC1			0x844
+#define GCC2			0x848
+#define GCC3			0x84c
+#define GCC4			0x850
+#define GCC5			0x854
+#define GCC6			0x858
+#define GCC7			0x85c
+
+/* TSC Test Register R/W */
+#define TTR			0xc00
+/* TSC Monitor Register 1, 2 */
+#define MNT1			0xc04
+#define MNT2			0xc04
+
+#define DETECT_ITEM_ID_1	1
+#define DETECT_ITEM_ID_2	5
+#define TS_X_ITEM_ID		2
+#define TS_Y_ITEM_ID		3
+#define TSI_DATA		1
+#define FQS_DATA		0
